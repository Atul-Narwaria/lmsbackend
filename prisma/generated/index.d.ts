
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export interface PrismaPromise<A> extends Promise<A> {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Designation
 * 
 */
export type Designation = {
  id: string
  roles: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model Country
 * 
 */
export type Country = {
  id: string
  CounrtyName: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model State
 * 
 */
export type State = {
  id: string
  StateName: string
  fkCountryId: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model City
 * 
 */
export type City = {
  id: string
  CityName: string
  fkStateId: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model Admin
 * 
 */
export type Admin = {
  id: string
  email: string
  password: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model SalesTeam
 * 
 */
export type SalesTeam = {
  id: string
  email: string
  phone: string
  password: string
  dob: Date
  fkDesignationId: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model SalesTeamDocuments
 * 
 */
export type SalesTeamDocuments = {
  id: string
  fkSalesTeamId: string
  category: string
  comment: string
  url: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model SalesTeamAddress
 * 
 */
export type SalesTeamAddress = {
  id: string
  fkSalesTeamId: string
  fkCountryId: string
  fkStateId: string
  fkCityId: string
  Address: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model SchoolBoard
 * 
 */
export type SchoolBoard = {
  id: string
  boardname: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model schoolType
 * 
 */
export type schoolType = {
  id: string
  schoolType: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model schoolMaster
 * 
 */
export type schoolMaster = {
  id: string
  name: string
  afflicationCode: string
  fkSchoolType: string
  fkSchoolBoard: string
  fkSalesTeamId: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model SchoolMasterAddress
 * 
 */
export type SchoolMasterAddress = {
  id: string
  fkSchoolId: string
  fkCountryId: string
  fkStateId: string
  fkCityId: string
  Address: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model Classmaster
 * 
 */
export type Classmaster = {
  id: string
  name: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model Subjectmaster
 * 
 */
export type Subjectmaster = {
  id: string
  name: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model StudentMaster
 * 
 */
export type StudentMaster = {
  id: string
  firstName: string
  lastName: string
  email: string
  phone: string
  password: string
  dob: Date
  admissionId: string
  rollNo: string
  profileImg: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model StudentParents
 * 
 */
export type StudentParents = {
  id: string
  fkStudentId: string
  name: string
  relation: string
  phone: string
  email: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model StudentDocuments
 * 
 */
export type StudentDocuments = {
  id: string
  fkStudentId: string
  category: string
  docUrl: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model StudentAddress
 * 
 */
export type StudentAddress = {
  id: string
  fkStudentId: string
  fkCountryId: string
  fkStateId: string
  fkCityId: string
  Address: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model TeacherDepartment
 * 
 */
export type TeacherDepartment = {
  id: string
  department: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model TeacherMaster
 * 
 */
export type TeacherMaster = {
  id: string
  firstName: string
  lastName: string
  email: string
  phone: string
  password: string
  gender: string
  dob: Date
  teacherId: string
  fkTeacherDepartmentId: string
  profileImg: string
  joiningDate: Date
  fkDesignationId: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model TeacherExprience
 * 
 */
export type TeacherExprience = {
  id: string
  fkTeacherId: string
  skills: Prisma.JsonValue[]
  experience: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model TeacherDocuments
 * 
 */
export type TeacherDocuments = {
  id: string
  fkTeacherId: string
  category: string
  docUrl: string
  status: boolean
  createAt: Date
  updatedAt: Date
}

/**
 * Model TeacherAddress
 * 
 */
export type TeacherAddress = {
  id: string
  fkTeacherId: string
  fkCountryId: string
  fkStateId: string
  fkCityId: string
  Address: string
  status: boolean
  createAt: Date
  updatedAt: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Designations
 * const designations = await prisma.designation.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Designations
   * const designations = await prisma.designation.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.designation`: Exposes CRUD operations for the **Designation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Designations
    * const designations = await prisma.designation.findMany()
    * ```
    */
  get designation(): Prisma.DesignationDelegate<GlobalReject>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<GlobalReject>;

  /**
   * `prisma.state`: Exposes CRUD operations for the **State** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.state.findMany()
    * ```
    */
  get state(): Prisma.StateDelegate<GlobalReject>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<GlobalReject>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<GlobalReject>;

  /**
   * `prisma.salesTeam`: Exposes CRUD operations for the **SalesTeam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesTeams
    * const salesTeams = await prisma.salesTeam.findMany()
    * ```
    */
  get salesTeam(): Prisma.SalesTeamDelegate<GlobalReject>;

  /**
   * `prisma.salesTeamDocuments`: Exposes CRUD operations for the **SalesTeamDocuments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesTeamDocuments
    * const salesTeamDocuments = await prisma.salesTeamDocuments.findMany()
    * ```
    */
  get salesTeamDocuments(): Prisma.SalesTeamDocumentsDelegate<GlobalReject>;

  /**
   * `prisma.salesTeamAddress`: Exposes CRUD operations for the **SalesTeamAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesTeamAddresses
    * const salesTeamAddresses = await prisma.salesTeamAddress.findMany()
    * ```
    */
  get salesTeamAddress(): Prisma.SalesTeamAddressDelegate<GlobalReject>;

  /**
   * `prisma.schoolBoard`: Exposes CRUD operations for the **SchoolBoard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolBoards
    * const schoolBoards = await prisma.schoolBoard.findMany()
    * ```
    */
  get schoolBoard(): Prisma.SchoolBoardDelegate<GlobalReject>;

  /**
   * `prisma.schoolType`: Exposes CRUD operations for the **schoolType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolTypes
    * const schoolTypes = await prisma.schoolType.findMany()
    * ```
    */
  get schoolType(): Prisma.schoolTypeDelegate<GlobalReject>;

  /**
   * `prisma.schoolMaster`: Exposes CRUD operations for the **schoolMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolMasters
    * const schoolMasters = await prisma.schoolMaster.findMany()
    * ```
    */
  get schoolMaster(): Prisma.schoolMasterDelegate<GlobalReject>;

  /**
   * `prisma.schoolMasterAddress`: Exposes CRUD operations for the **SchoolMasterAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolMasterAddresses
    * const schoolMasterAddresses = await prisma.schoolMasterAddress.findMany()
    * ```
    */
  get schoolMasterAddress(): Prisma.SchoolMasterAddressDelegate<GlobalReject>;

  /**
   * `prisma.classmaster`: Exposes CRUD operations for the **Classmaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classmasters
    * const classmasters = await prisma.classmaster.findMany()
    * ```
    */
  get classmaster(): Prisma.ClassmasterDelegate<GlobalReject>;

  /**
   * `prisma.subjectmaster`: Exposes CRUD operations for the **Subjectmaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjectmasters
    * const subjectmasters = await prisma.subjectmaster.findMany()
    * ```
    */
  get subjectmaster(): Prisma.SubjectmasterDelegate<GlobalReject>;

  /**
   * `prisma.studentMaster`: Exposes CRUD operations for the **StudentMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentMasters
    * const studentMasters = await prisma.studentMaster.findMany()
    * ```
    */
  get studentMaster(): Prisma.StudentMasterDelegate<GlobalReject>;

  /**
   * `prisma.studentParents`: Exposes CRUD operations for the **StudentParents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentParents
    * const studentParents = await prisma.studentParents.findMany()
    * ```
    */
  get studentParents(): Prisma.StudentParentsDelegate<GlobalReject>;

  /**
   * `prisma.studentDocuments`: Exposes CRUD operations for the **StudentDocuments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentDocuments
    * const studentDocuments = await prisma.studentDocuments.findMany()
    * ```
    */
  get studentDocuments(): Prisma.StudentDocumentsDelegate<GlobalReject>;

  /**
   * `prisma.studentAddress`: Exposes CRUD operations for the **StudentAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAddresses
    * const studentAddresses = await prisma.studentAddress.findMany()
    * ```
    */
  get studentAddress(): Prisma.StudentAddressDelegate<GlobalReject>;

  /**
   * `prisma.teacherDepartment`: Exposes CRUD operations for the **TeacherDepartment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherDepartments
    * const teacherDepartments = await prisma.teacherDepartment.findMany()
    * ```
    */
  get teacherDepartment(): Prisma.TeacherDepartmentDelegate<GlobalReject>;

  /**
   * `prisma.teacherMaster`: Exposes CRUD operations for the **TeacherMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherMasters
    * const teacherMasters = await prisma.teacherMaster.findMany()
    * ```
    */
  get teacherMaster(): Prisma.TeacherMasterDelegate<GlobalReject>;

  /**
   * `prisma.teacherExprience`: Exposes CRUD operations for the **TeacherExprience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherExpriences
    * const teacherExpriences = await prisma.teacherExprience.findMany()
    * ```
    */
  get teacherExprience(): Prisma.TeacherExprienceDelegate<GlobalReject>;

  /**
   * `prisma.teacherDocuments`: Exposes CRUD operations for the **TeacherDocuments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherDocuments
    * const teacherDocuments = await prisma.teacherDocuments.findMany()
    * ```
    */
  get teacherDocuments(): Prisma.TeacherDocumentsDelegate<GlobalReject>;

  /**
   * `prisma.teacherAddress`: Exposes CRUD operations for the **TeacherAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherAddresses
    * const teacherAddresses = await prisma.teacherAddress.findMany()
    * ```
    */
  get teacherAddress(): Prisma.TeacherAddressDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.9.0
   * Query Engine version: ceb5c99003b99c9ee2c1d2e618e359c14aef2ea5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Designation: 'Designation',
    Country: 'Country',
    State: 'State',
    City: 'City',
    Admin: 'Admin',
    SalesTeam: 'SalesTeam',
    SalesTeamDocuments: 'SalesTeamDocuments',
    SalesTeamAddress: 'SalesTeamAddress',
    SchoolBoard: 'SchoolBoard',
    schoolType: 'schoolType',
    schoolMaster: 'schoolMaster',
    SchoolMasterAddress: 'SchoolMasterAddress',
    Classmaster: 'Classmaster',
    Subjectmaster: 'Subjectmaster',
    StudentMaster: 'StudentMaster',
    StudentParents: 'StudentParents',
    StudentDocuments: 'StudentDocuments',
    StudentAddress: 'StudentAddress',
    TeacherDepartment: 'TeacherDepartment',
    TeacherMaster: 'TeacherMaster',
    TeacherExprience: 'TeacherExprience',
    TeacherDocuments: 'TeacherDocuments',
    TeacherAddress: 'TeacherAddress'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DesignationCountOutputType
   */


  export type DesignationCountOutputType = {
    SalesTeam: number
    TeacherMaster: number
  }

  export type DesignationCountOutputTypeSelect = {
    SalesTeam?: boolean
    TeacherMaster?: boolean
  }

  export type DesignationCountOutputTypeGetPayload<S extends boolean | null | undefined | DesignationCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DesignationCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DesignationCountOutputTypeArgs)
    ? DesignationCountOutputType 
    : S extends { select: any } & (DesignationCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DesignationCountOutputType ? DesignationCountOutputType[P] : never
  } 
      : DesignationCountOutputType




  // Custom InputTypes

  /**
   * DesignationCountOutputType without action
   */
  export type DesignationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DesignationCountOutputType
     */
    select?: DesignationCountOutputTypeSelect | null
  }



  /**
   * Count Type CountryCountOutputType
   */


  export type CountryCountOutputType = {
    State: number
    StudentAddress: number
    TeacherAddress: number
    SalesTeamAddress: number
    SchoolMasterAddress: number
  }

  export type CountryCountOutputTypeSelect = {
    State?: boolean
    StudentAddress?: boolean
    TeacherAddress?: boolean
    SalesTeamAddress?: boolean
    SchoolMasterAddress?: boolean
  }

  export type CountryCountOutputTypeGetPayload<S extends boolean | null | undefined | CountryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CountryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CountryCountOutputTypeArgs)
    ? CountryCountOutputType 
    : S extends { select: any } & (CountryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CountryCountOutputType ? CountryCountOutputType[P] : never
  } 
      : CountryCountOutputType




  // Custom InputTypes

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect | null
  }



  /**
   * Count Type StateCountOutputType
   */


  export type StateCountOutputType = {
    City: number
    StudentAddress: number
    TeacherAddress: number
    SalesTeamAddress: number
    SchoolMasterAddress: number
  }

  export type StateCountOutputTypeSelect = {
    City?: boolean
    StudentAddress?: boolean
    TeacherAddress?: boolean
    SalesTeamAddress?: boolean
    SchoolMasterAddress?: boolean
  }

  export type StateCountOutputTypeGetPayload<S extends boolean | null | undefined | StateCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StateCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (StateCountOutputTypeArgs)
    ? StateCountOutputType 
    : S extends { select: any } & (StateCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof StateCountOutputType ? StateCountOutputType[P] : never
  } 
      : StateCountOutputType




  // Custom InputTypes

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StateCountOutputType
     */
    select?: StateCountOutputTypeSelect | null
  }



  /**
   * Count Type CityCountOutputType
   */


  export type CityCountOutputType = {
    StudentAddress: number
    TeacherAddress: number
    SalesTeamAddress: number
    SchoolMasterAddress: number
  }

  export type CityCountOutputTypeSelect = {
    StudentAddress?: boolean
    TeacherAddress?: boolean
    SalesTeamAddress?: boolean
    SchoolMasterAddress?: boolean
  }

  export type CityCountOutputTypeGetPayload<S extends boolean | null | undefined | CityCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CityCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CityCountOutputTypeArgs)
    ? CityCountOutputType 
    : S extends { select: any } & (CityCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CityCountOutputType ? CityCountOutputType[P] : never
  } 
      : CityCountOutputType




  // Custom InputTypes

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect | null
  }



  /**
   * Count Type SalesTeamCountOutputType
   */


  export type SalesTeamCountOutputType = {
    SalesTeamDocuments: number
    SalesTeamAddress: number
    schoolMaster: number
  }

  export type SalesTeamCountOutputTypeSelect = {
    SalesTeamDocuments?: boolean
    SalesTeamAddress?: boolean
    schoolMaster?: boolean
  }

  export type SalesTeamCountOutputTypeGetPayload<S extends boolean | null | undefined | SalesTeamCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SalesTeamCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SalesTeamCountOutputTypeArgs)
    ? SalesTeamCountOutputType 
    : S extends { select: any } & (SalesTeamCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SalesTeamCountOutputType ? SalesTeamCountOutputType[P] : never
  } 
      : SalesTeamCountOutputType




  // Custom InputTypes

  /**
   * SalesTeamCountOutputType without action
   */
  export type SalesTeamCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamCountOutputType
     */
    select?: SalesTeamCountOutputTypeSelect | null
  }



  /**
   * Count Type SchoolBoardCountOutputType
   */


  export type SchoolBoardCountOutputType = {
    schoolMaster: number
  }

  export type SchoolBoardCountOutputTypeSelect = {
    schoolMaster?: boolean
  }

  export type SchoolBoardCountOutputTypeGetPayload<S extends boolean | null | undefined | SchoolBoardCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SchoolBoardCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SchoolBoardCountOutputTypeArgs)
    ? SchoolBoardCountOutputType 
    : S extends { select: any } & (SchoolBoardCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SchoolBoardCountOutputType ? SchoolBoardCountOutputType[P] : never
  } 
      : SchoolBoardCountOutputType




  // Custom InputTypes

  /**
   * SchoolBoardCountOutputType without action
   */
  export type SchoolBoardCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SchoolBoardCountOutputType
     */
    select?: SchoolBoardCountOutputTypeSelect | null
  }



  /**
   * Count Type SchoolTypeCountOutputType
   */


  export type SchoolTypeCountOutputType = {
    schoolMaster: number
  }

  export type SchoolTypeCountOutputTypeSelect = {
    schoolMaster?: boolean
  }

  export type SchoolTypeCountOutputTypeGetPayload<S extends boolean | null | undefined | SchoolTypeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SchoolTypeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SchoolTypeCountOutputTypeArgs)
    ? SchoolTypeCountOutputType 
    : S extends { select: any } & (SchoolTypeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SchoolTypeCountOutputType ? SchoolTypeCountOutputType[P] : never
  } 
      : SchoolTypeCountOutputType




  // Custom InputTypes

  /**
   * SchoolTypeCountOutputType without action
   */
  export type SchoolTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SchoolTypeCountOutputType
     */
    select?: SchoolTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type SchoolMasterCountOutputType
   */


  export type SchoolMasterCountOutputType = {
    SchoolMasterAddress: number
  }

  export type SchoolMasterCountOutputTypeSelect = {
    SchoolMasterAddress?: boolean
  }

  export type SchoolMasterCountOutputTypeGetPayload<S extends boolean | null | undefined | SchoolMasterCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SchoolMasterCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SchoolMasterCountOutputTypeArgs)
    ? SchoolMasterCountOutputType 
    : S extends { select: any } & (SchoolMasterCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SchoolMasterCountOutputType ? SchoolMasterCountOutputType[P] : never
  } 
      : SchoolMasterCountOutputType




  // Custom InputTypes

  /**
   * SchoolMasterCountOutputType without action
   */
  export type SchoolMasterCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterCountOutputType
     */
    select?: SchoolMasterCountOutputTypeSelect | null
  }



  /**
   * Count Type StudentMasterCountOutputType
   */


  export type StudentMasterCountOutputType = {
    StudentDetail: number
    StudentAddress: number
    StudentParents: number
  }

  export type StudentMasterCountOutputTypeSelect = {
    StudentDetail?: boolean
    StudentAddress?: boolean
    StudentParents?: boolean
  }

  export type StudentMasterCountOutputTypeGetPayload<S extends boolean | null | undefined | StudentMasterCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StudentMasterCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (StudentMasterCountOutputTypeArgs)
    ? StudentMasterCountOutputType 
    : S extends { select: any } & (StudentMasterCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof StudentMasterCountOutputType ? StudentMasterCountOutputType[P] : never
  } 
      : StudentMasterCountOutputType




  // Custom InputTypes

  /**
   * StudentMasterCountOutputType without action
   */
  export type StudentMasterCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StudentMasterCountOutputType
     */
    select?: StudentMasterCountOutputTypeSelect | null
  }



  /**
   * Count Type TeacherDepartmentCountOutputType
   */


  export type TeacherDepartmentCountOutputType = {
    TeacherMaster: number
  }

  export type TeacherDepartmentCountOutputTypeSelect = {
    TeacherMaster?: boolean
  }

  export type TeacherDepartmentCountOutputTypeGetPayload<S extends boolean | null | undefined | TeacherDepartmentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TeacherDepartmentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TeacherDepartmentCountOutputTypeArgs)
    ? TeacherDepartmentCountOutputType 
    : S extends { select: any } & (TeacherDepartmentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TeacherDepartmentCountOutputType ? TeacherDepartmentCountOutputType[P] : never
  } 
      : TeacherDepartmentCountOutputType




  // Custom InputTypes

  /**
   * TeacherDepartmentCountOutputType without action
   */
  export type TeacherDepartmentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TeacherDepartmentCountOutputType
     */
    select?: TeacherDepartmentCountOutputTypeSelect | null
  }



  /**
   * Count Type TeacherMasterCountOutputType
   */


  export type TeacherMasterCountOutputType = {
    TeacherDocuments: number
    TeacherAddress: number
    TeacherExprience: number
  }

  export type TeacherMasterCountOutputTypeSelect = {
    TeacherDocuments?: boolean
    TeacherAddress?: boolean
    TeacherExprience?: boolean
  }

  export type TeacherMasterCountOutputTypeGetPayload<S extends boolean | null | undefined | TeacherMasterCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TeacherMasterCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TeacherMasterCountOutputTypeArgs)
    ? TeacherMasterCountOutputType 
    : S extends { select: any } & (TeacherMasterCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TeacherMasterCountOutputType ? TeacherMasterCountOutputType[P] : never
  } 
      : TeacherMasterCountOutputType




  // Custom InputTypes

  /**
   * TeacherMasterCountOutputType without action
   */
  export type TeacherMasterCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TeacherMasterCountOutputType
     */
    select?: TeacherMasterCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Designation
   */


  export type AggregateDesignation = {
    _count: DesignationCountAggregateOutputType | null
    _min: DesignationMinAggregateOutputType | null
    _max: DesignationMaxAggregateOutputType | null
  }

  export type DesignationMinAggregateOutputType = {
    id: string | null
    roles: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type DesignationMaxAggregateOutputType = {
    id: string | null
    roles: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type DesignationCountAggregateOutputType = {
    id: number
    roles: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type DesignationMinAggregateInputType = {
    id?: true
    roles?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type DesignationMaxAggregateInputType = {
    id?: true
    roles?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type DesignationCountAggregateInputType = {
    id?: true
    roles?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DesignationAggregateArgs = {
    /**
     * Filter which Designation to aggregate.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: Enumerable<DesignationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Designations
    **/
    _count?: true | DesignationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignationMaxAggregateInputType
  }

  export type GetDesignationAggregateType<T extends DesignationAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignation[P]>
      : GetScalarType<T[P], AggregateDesignation[P]>
  }




  export type DesignationGroupByArgs = {
    where?: DesignationWhereInput
    orderBy?: Enumerable<DesignationOrderByWithAggregationInput>
    by: DesignationScalarFieldEnum[]
    having?: DesignationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignationCountAggregateInputType | true
    _min?: DesignationMinAggregateInputType
    _max?: DesignationMaxAggregateInputType
  }


  export type DesignationGroupByOutputType = {
    id: string
    roles: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: DesignationCountAggregateOutputType | null
    _min: DesignationMinAggregateOutputType | null
    _max: DesignationMaxAggregateOutputType | null
  }

  type GetDesignationGroupByPayload<T extends DesignationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DesignationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignationGroupByOutputType[P]>
            : GetScalarType<T[P], DesignationGroupByOutputType[P]>
        }
      >
    >


  export type DesignationSelect = {
    id?: boolean
    roles?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
    SalesTeam?: boolean | Designation$SalesTeamArgs
    TeacherMaster?: boolean | Designation$TeacherMasterArgs
    _count?: boolean | DesignationCountOutputTypeArgs
  }


  export type DesignationInclude = {
    SalesTeam?: boolean | Designation$SalesTeamArgs
    TeacherMaster?: boolean | Designation$TeacherMasterArgs
    _count?: boolean | DesignationCountOutputTypeArgs
  }

  export type DesignationGetPayload<S extends boolean | null | undefined | DesignationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Designation :
    S extends undefined ? never :
    S extends { include: any } & (DesignationArgs | DesignationFindManyArgs)
    ? Designation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'SalesTeam' ? Array < SalesTeamGetPayload<S['include'][P]>>  :
        P extends 'TeacherMaster' ? Array < TeacherMasterGetPayload<S['include'][P]>>  :
        P extends '_count' ? DesignationCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DesignationArgs | DesignationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'SalesTeam' ? Array < SalesTeamGetPayload<S['select'][P]>>  :
        P extends 'TeacherMaster' ? Array < TeacherMasterGetPayload<S['select'][P]>>  :
        P extends '_count' ? DesignationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Designation ? Designation[P] : never
  } 
      : Designation


  type DesignationCountArgs = 
    Omit<DesignationFindManyArgs, 'select' | 'include'> & {
      select?: DesignationCountAggregateInputType | true
    }

  export interface DesignationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Designation that matches the filter.
     * @param {DesignationFindUniqueArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DesignationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DesignationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Designation'> extends True ? Prisma__DesignationClient<DesignationGetPayload<T>> : Prisma__DesignationClient<DesignationGetPayload<T> | null, null>

    /**
     * Find one Designation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DesignationFindUniqueOrThrowArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DesignationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DesignationFindUniqueOrThrowArgs>
    ): Prisma__DesignationClient<DesignationGetPayload<T>>

    /**
     * Find the first Designation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationFindFirstArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DesignationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DesignationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Designation'> extends True ? Prisma__DesignationClient<DesignationGetPayload<T>> : Prisma__DesignationClient<DesignationGetPayload<T> | null, null>

    /**
     * Find the first Designation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationFindFirstOrThrowArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DesignationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DesignationFindFirstOrThrowArgs>
    ): Prisma__DesignationClient<DesignationGetPayload<T>>

    /**
     * Find zero or more Designations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Designations
     * const designations = await prisma.designation.findMany()
     * 
     * // Get first 10 Designations
     * const designations = await prisma.designation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designationWithIdOnly = await prisma.designation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DesignationFindManyArgs>(
      args?: SelectSubset<T, DesignationFindManyArgs>
    ): PrismaPromise<Array<DesignationGetPayload<T>>>

    /**
     * Create a Designation.
     * @param {DesignationCreateArgs} args - Arguments to create a Designation.
     * @example
     * // Create one Designation
     * const Designation = await prisma.designation.create({
     *   data: {
     *     // ... data to create a Designation
     *   }
     * })
     * 
    **/
    create<T extends DesignationCreateArgs>(
      args: SelectSubset<T, DesignationCreateArgs>
    ): Prisma__DesignationClient<DesignationGetPayload<T>>

    /**
     * Create many Designations.
     *     @param {DesignationCreateManyArgs} args - Arguments to create many Designations.
     *     @example
     *     // Create many Designations
     *     const designation = await prisma.designation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DesignationCreateManyArgs>(
      args?: SelectSubset<T, DesignationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Designation.
     * @param {DesignationDeleteArgs} args - Arguments to delete one Designation.
     * @example
     * // Delete one Designation
     * const Designation = await prisma.designation.delete({
     *   where: {
     *     // ... filter to delete one Designation
     *   }
     * })
     * 
    **/
    delete<T extends DesignationDeleteArgs>(
      args: SelectSubset<T, DesignationDeleteArgs>
    ): Prisma__DesignationClient<DesignationGetPayload<T>>

    /**
     * Update one Designation.
     * @param {DesignationUpdateArgs} args - Arguments to update one Designation.
     * @example
     * // Update one Designation
     * const designation = await prisma.designation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DesignationUpdateArgs>(
      args: SelectSubset<T, DesignationUpdateArgs>
    ): Prisma__DesignationClient<DesignationGetPayload<T>>

    /**
     * Delete zero or more Designations.
     * @param {DesignationDeleteManyArgs} args - Arguments to filter Designations to delete.
     * @example
     * // Delete a few Designations
     * const { count } = await prisma.designation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DesignationDeleteManyArgs>(
      args?: SelectSubset<T, DesignationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Designations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Designations
     * const designation = await prisma.designation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DesignationUpdateManyArgs>(
      args: SelectSubset<T, DesignationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Designation.
     * @param {DesignationUpsertArgs} args - Arguments to update or create a Designation.
     * @example
     * // Update or create a Designation
     * const designation = await prisma.designation.upsert({
     *   create: {
     *     // ... data to create a Designation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Designation we want to update
     *   }
     * })
    **/
    upsert<T extends DesignationUpsertArgs>(
      args: SelectSubset<T, DesignationUpsertArgs>
    ): Prisma__DesignationClient<DesignationGetPayload<T>>

    /**
     * Count the number of Designations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationCountArgs} args - Arguments to filter Designations to count.
     * @example
     * // Count the number of Designations
     * const count = await prisma.designation.count({
     *   where: {
     *     // ... the filter for the Designations we want to count
     *   }
     * })
    **/
    count<T extends DesignationCountArgs>(
      args?: Subset<T, DesignationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Designation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignationAggregateArgs>(args: Subset<T, DesignationAggregateArgs>): PrismaPromise<GetDesignationAggregateType<T>>

    /**
     * Group by Designation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignationGroupByArgs['orderBy'] }
        : { orderBy?: DesignationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Designation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DesignationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    SalesTeam<T extends Designation$SalesTeamArgs= {}>(args?: Subset<T, Designation$SalesTeamArgs>): PrismaPromise<Array<SalesTeamGetPayload<T>>| Null>;

    TeacherMaster<T extends Designation$TeacherMasterArgs= {}>(args?: Subset<T, Designation$TeacherMasterArgs>): PrismaPromise<Array<TeacherMasterGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Designation base type for findUnique actions
   */
  export type DesignationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesignationInclude | null
    /**
     * Filter, which Designation to fetch.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation findUnique
   */
  export interface DesignationFindUniqueArgs extends DesignationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Designation findUniqueOrThrow
   */
  export type DesignationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesignationInclude | null
    /**
     * Filter, which Designation to fetch.
     */
    where: DesignationWhereUniqueInput
  }


  /**
   * Designation base type for findFirst actions
   */
  export type DesignationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesignationInclude | null
    /**
     * Filter, which Designation to fetch.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: Enumerable<DesignationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Designations.
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Designations.
     */
    distinct?: Enumerable<DesignationScalarFieldEnum>
  }

  /**
   * Designation findFirst
   */
  export interface DesignationFindFirstArgs extends DesignationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Designation findFirstOrThrow
   */
  export type DesignationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesignationInclude | null
    /**
     * Filter, which Designation to fetch.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: Enumerable<DesignationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Designations.
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Designations.
     */
    distinct?: Enumerable<DesignationScalarFieldEnum>
  }


  /**
   * Designation findMany
   */
  export type DesignationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesignationInclude | null
    /**
     * Filter, which Designations to fetch.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: Enumerable<DesignationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Designations.
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    distinct?: Enumerable<DesignationScalarFieldEnum>
  }


  /**
   * Designation create
   */
  export type DesignationCreateArgs = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesignationInclude | null
    /**
     * The data needed to create a Designation.
     */
    data: XOR<DesignationCreateInput, DesignationUncheckedCreateInput>
  }


  /**
   * Designation createMany
   */
  export type DesignationCreateManyArgs = {
    /**
     * The data used to create many Designations.
     */
    data: Enumerable<DesignationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Designation update
   */
  export type DesignationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesignationInclude | null
    /**
     * The data needed to update a Designation.
     */
    data: XOR<DesignationUpdateInput, DesignationUncheckedUpdateInput>
    /**
     * Choose, which Designation to update.
     */
    where: DesignationWhereUniqueInput
  }


  /**
   * Designation updateMany
   */
  export type DesignationUpdateManyArgs = {
    /**
     * The data used to update Designations.
     */
    data: XOR<DesignationUpdateManyMutationInput, DesignationUncheckedUpdateManyInput>
    /**
     * Filter which Designations to update
     */
    where?: DesignationWhereInput
  }


  /**
   * Designation upsert
   */
  export type DesignationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesignationInclude | null
    /**
     * The filter to search for the Designation to update in case it exists.
     */
    where: DesignationWhereUniqueInput
    /**
     * In case the Designation found by the `where` argument doesn't exist, create a new Designation with this data.
     */
    create: XOR<DesignationCreateInput, DesignationUncheckedCreateInput>
    /**
     * In case the Designation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignationUpdateInput, DesignationUncheckedUpdateInput>
  }


  /**
   * Designation delete
   */
  export type DesignationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesignationInclude | null
    /**
     * Filter which Designation to delete.
     */
    where: DesignationWhereUniqueInput
  }


  /**
   * Designation deleteMany
   */
  export type DesignationDeleteManyArgs = {
    /**
     * Filter which Designations to delete
     */
    where?: DesignationWhereInput
  }


  /**
   * Designation.SalesTeam
   */
  export type Designation$SalesTeamArgs = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamInclude | null
    where?: SalesTeamWhereInput
    orderBy?: Enumerable<SalesTeamOrderByWithRelationInput>
    cursor?: SalesTeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesTeamScalarFieldEnum>
  }


  /**
   * Designation.TeacherMaster
   */
  export type Designation$TeacherMasterArgs = {
    /**
     * Select specific fields to fetch from the TeacherMaster
     */
    select?: TeacherMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherMasterInclude | null
    where?: TeacherMasterWhereInput
    orderBy?: Enumerable<TeacherMasterOrderByWithRelationInput>
    cursor?: TeacherMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherMasterScalarFieldEnum>
  }


  /**
   * Designation without action
   */
  export type DesignationArgs = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesignationInclude | null
  }



  /**
   * Model Country
   */


  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    CounrtyName: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    CounrtyName: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    CounrtyName: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    id?: true
    CounrtyName?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    CounrtyName?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    CounrtyName?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountryAggregateArgs = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs = {
    where?: CountryWhereInput
    orderBy?: Enumerable<CountryOrderByWithAggregationInput>
    by: CountryScalarFieldEnum[]
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }


  export type CountryGroupByOutputType = {
    id: string
    CounrtyName: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect = {
    id?: boolean
    CounrtyName?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
    State?: boolean | Country$StateArgs
    StudentAddress?: boolean | Country$StudentAddressArgs
    TeacherAddress?: boolean | Country$TeacherAddressArgs
    SalesTeamAddress?: boolean | Country$SalesTeamAddressArgs
    SchoolMasterAddress?: boolean | Country$SchoolMasterAddressArgs
    _count?: boolean | CountryCountOutputTypeArgs
  }


  export type CountryInclude = {
    State?: boolean | Country$StateArgs
    StudentAddress?: boolean | Country$StudentAddressArgs
    TeacherAddress?: boolean | Country$TeacherAddressArgs
    SalesTeamAddress?: boolean | Country$SalesTeamAddressArgs
    SchoolMasterAddress?: boolean | Country$SchoolMasterAddressArgs
    _count?: boolean | CountryCountOutputTypeArgs
  }

  export type CountryGetPayload<S extends boolean | null | undefined | CountryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Country :
    S extends undefined ? never :
    S extends { include: any } & (CountryArgs | CountryFindManyArgs)
    ? Country  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'State' ? Array < StateGetPayload<S['include'][P]>>  :
        P extends 'StudentAddress' ? Array < StudentAddressGetPayload<S['include'][P]>>  :
        P extends 'TeacherAddress' ? Array < TeacherAddressGetPayload<S['include'][P]>>  :
        P extends 'SalesTeamAddress' ? Array < SalesTeamAddressGetPayload<S['include'][P]>>  :
        P extends 'SchoolMasterAddress' ? Array < SchoolMasterAddressGetPayload<S['include'][P]>>  :
        P extends '_count' ? CountryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CountryArgs | CountryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'State' ? Array < StateGetPayload<S['select'][P]>>  :
        P extends 'StudentAddress' ? Array < StudentAddressGetPayload<S['select'][P]>>  :
        P extends 'TeacherAddress' ? Array < TeacherAddressGetPayload<S['select'][P]>>  :
        P extends 'SalesTeamAddress' ? Array < SalesTeamAddressGetPayload<S['select'][P]>>  :
        P extends 'SchoolMasterAddress' ? Array < SchoolMasterAddressGetPayload<S['select'][P]>>  :
        P extends '_count' ? CountryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Country ? Country[P] : never
  } 
      : Country


  type CountryCountArgs = 
    Omit<CountryFindManyArgs, 'select' | 'include'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CountryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Country'> extends True ? Prisma__CountryClient<CountryGetPayload<T>> : Prisma__CountryClient<CountryGetPayload<T> | null, null>

    /**
     * Find one Country that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CountryFindUniqueOrThrowArgs>
    ): Prisma__CountryClient<CountryGetPayload<T>>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CountryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Country'> extends True ? Prisma__CountryClient<CountryGetPayload<T>> : Prisma__CountryClient<CountryGetPayload<T> | null, null>

    /**
     * Find the first Country that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CountryFindFirstOrThrowArgs>
    ): Prisma__CountryClient<CountryGetPayload<T>>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountryFindManyArgs>(
      args?: SelectSubset<T, CountryFindManyArgs>
    ): PrismaPromise<Array<CountryGetPayload<T>>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends CountryCreateArgs>(
      args: SelectSubset<T, CountryCreateArgs>
    ): Prisma__CountryClient<CountryGetPayload<T>>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountryCreateManyArgs>(
      args?: SelectSubset<T, CountryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends CountryDeleteArgs>(
      args: SelectSubset<T, CountryDeleteArgs>
    ): Prisma__CountryClient<CountryGetPayload<T>>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountryUpdateArgs>(
      args: SelectSubset<T, CountryUpdateArgs>
    ): Prisma__CountryClient<CountryGetPayload<T>>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountryDeleteManyArgs>(
      args?: SelectSubset<T, CountryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountryUpdateManyArgs>(
      args: SelectSubset<T, CountryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs>(
      args: SelectSubset<T, CountryUpsertArgs>
    ): Prisma__CountryClient<CountryGetPayload<T>>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CountryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    State<T extends Country$StateArgs= {}>(args?: Subset<T, Country$StateArgs>): PrismaPromise<Array<StateGetPayload<T>>| Null>;

    StudentAddress<T extends Country$StudentAddressArgs= {}>(args?: Subset<T, Country$StudentAddressArgs>): PrismaPromise<Array<StudentAddressGetPayload<T>>| Null>;

    TeacherAddress<T extends Country$TeacherAddressArgs= {}>(args?: Subset<T, Country$TeacherAddressArgs>): PrismaPromise<Array<TeacherAddressGetPayload<T>>| Null>;

    SalesTeamAddress<T extends Country$SalesTeamAddressArgs= {}>(args?: Subset<T, Country$SalesTeamAddressArgs>): PrismaPromise<Array<SalesTeamAddressGetPayload<T>>| Null>;

    SchoolMasterAddress<T extends Country$SchoolMasterAddressArgs= {}>(args?: Subset<T, Country$SchoolMasterAddressArgs>): PrismaPromise<Array<SchoolMasterAddressGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Country base type for findUnique actions
   */
  export type CountryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUnique
   */
  export interface CountryFindUniqueArgs extends CountryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country base type for findFirst actions
   */
  export type CountryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: Enumerable<CountryScalarFieldEnum>
  }

  /**
   * Country findFirst
   */
  export interface CountryFindFirstArgs extends CountryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country findMany
   */
  export type CountryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country create
   */
  export type CountryCreateArgs = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }


  /**
   * Country createMany
   */
  export type CountryCreateManyArgs = {
    /**
     * The data used to create many Countries.
     */
    data: Enumerable<CountryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Country update
   */
  export type CountryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
  }


  /**
   * Country upsert
   */
  export type CountryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }


  /**
   * Country delete
   */
  export type CountryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
  }


  /**
   * Country.State
   */
  export type Country$StateArgs = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude | null
    where?: StateWhereInput
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    cursor?: StateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * Country.StudentAddress
   */
  export type Country$StudentAddressArgs = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    where?: StudentAddressWhereInput
    orderBy?: Enumerable<StudentAddressOrderByWithRelationInput>
    cursor?: StudentAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentAddressScalarFieldEnum>
  }


  /**
   * Country.TeacherAddress
   */
  export type Country$TeacherAddressArgs = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    where?: TeacherAddressWhereInput
    orderBy?: Enumerable<TeacherAddressOrderByWithRelationInput>
    cursor?: TeacherAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherAddressScalarFieldEnum>
  }


  /**
   * Country.SalesTeamAddress
   */
  export type Country$SalesTeamAddressArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    where?: SalesTeamAddressWhereInput
    orderBy?: Enumerable<SalesTeamAddressOrderByWithRelationInput>
    cursor?: SalesTeamAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesTeamAddressScalarFieldEnum>
  }


  /**
   * Country.SchoolMasterAddress
   */
  export type Country$SchoolMasterAddressArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    where?: SchoolMasterAddressWhereInput
    orderBy?: Enumerable<SchoolMasterAddressOrderByWithRelationInput>
    cursor?: SchoolMasterAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SchoolMasterAddressScalarFieldEnum>
  }


  /**
   * Country without action
   */
  export type CountryArgs = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude | null
  }



  /**
   * Model State
   */


  export type AggregateState = {
    _count: StateCountAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  export type StateMinAggregateOutputType = {
    id: string | null
    StateName: string | null
    fkCountryId: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type StateMaxAggregateOutputType = {
    id: string | null
    StateName: string | null
    fkCountryId: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type StateCountAggregateOutputType = {
    id: number
    StateName: number
    fkCountryId: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type StateMinAggregateInputType = {
    id?: true
    StateName?: true
    fkCountryId?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type StateMaxAggregateInputType = {
    id?: true
    StateName?: true
    fkCountryId?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type StateCountAggregateInputType = {
    id?: true
    StateName?: true
    fkCountryId?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StateAggregateArgs = {
    /**
     * Filter which State to aggregate.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned States
    **/
    _count?: true | StateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateMaxAggregateInputType
  }

  export type GetStateAggregateType<T extends StateAggregateArgs> = {
        [P in keyof T & keyof AggregateState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateState[P]>
      : GetScalarType<T[P], AggregateState[P]>
  }




  export type StateGroupByArgs = {
    where?: StateWhereInput
    orderBy?: Enumerable<StateOrderByWithAggregationInput>
    by: StateScalarFieldEnum[]
    having?: StateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateCountAggregateInputType | true
    _min?: StateMinAggregateInputType
    _max?: StateMaxAggregateInputType
  }


  export type StateGroupByOutputType = {
    id: string
    StateName: string
    fkCountryId: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: StateCountAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  type GetStateGroupByPayload<T extends StateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateGroupByOutputType[P]>
            : GetScalarType<T[P], StateGroupByOutputType[P]>
        }
      >
    >


  export type StateSelect = {
    id?: boolean
    StateName?: boolean
    Country?: boolean | CountryArgs
    fkCountryId?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
    City?: boolean | State$CityArgs
    StudentAddress?: boolean | State$StudentAddressArgs
    TeacherAddress?: boolean | State$TeacherAddressArgs
    SalesTeamAddress?: boolean | State$SalesTeamAddressArgs
    SchoolMasterAddress?: boolean | State$SchoolMasterAddressArgs
    _count?: boolean | StateCountOutputTypeArgs
  }


  export type StateInclude = {
    Country?: boolean | CountryArgs
    City?: boolean | State$CityArgs
    StudentAddress?: boolean | State$StudentAddressArgs
    TeacherAddress?: boolean | State$TeacherAddressArgs
    SalesTeamAddress?: boolean | State$SalesTeamAddressArgs
    SchoolMasterAddress?: boolean | State$SchoolMasterAddressArgs
    _count?: boolean | StateCountOutputTypeArgs
  }

  export type StateGetPayload<S extends boolean | null | undefined | StateArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? State :
    S extends undefined ? never :
    S extends { include: any } & (StateArgs | StateFindManyArgs)
    ? State  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Country' ? CountryGetPayload<S['include'][P]> :
        P extends 'City' ? Array < CityGetPayload<S['include'][P]>>  :
        P extends 'StudentAddress' ? Array < StudentAddressGetPayload<S['include'][P]>>  :
        P extends 'TeacherAddress' ? Array < TeacherAddressGetPayload<S['include'][P]>>  :
        P extends 'SalesTeamAddress' ? Array < SalesTeamAddressGetPayload<S['include'][P]>>  :
        P extends 'SchoolMasterAddress' ? Array < SchoolMasterAddressGetPayload<S['include'][P]>>  :
        P extends '_count' ? StateCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (StateArgs | StateFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Country' ? CountryGetPayload<S['select'][P]> :
        P extends 'City' ? Array < CityGetPayload<S['select'][P]>>  :
        P extends 'StudentAddress' ? Array < StudentAddressGetPayload<S['select'][P]>>  :
        P extends 'TeacherAddress' ? Array < TeacherAddressGetPayload<S['select'][P]>>  :
        P extends 'SalesTeamAddress' ? Array < SalesTeamAddressGetPayload<S['select'][P]>>  :
        P extends 'SchoolMasterAddress' ? Array < SchoolMasterAddressGetPayload<S['select'][P]>>  :
        P extends '_count' ? StateCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof State ? State[P] : never
  } 
      : State


  type StateCountArgs = 
    Omit<StateFindManyArgs, 'select' | 'include'> & {
      select?: StateCountAggregateInputType | true
    }

  export interface StateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one State that matches the filter.
     * @param {StateFindUniqueArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'State'> extends True ? Prisma__StateClient<StateGetPayload<T>> : Prisma__StateClient<StateGetPayload<T> | null, null>

    /**
     * Find one State that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StateFindUniqueOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StateFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StateFindUniqueOrThrowArgs>
    ): Prisma__StateClient<StateGetPayload<T>>

    /**
     * Find the first State that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'State'> extends True ? Prisma__StateClient<StateGetPayload<T>> : Prisma__StateClient<StateGetPayload<T> | null, null>

    /**
     * Find the first State that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StateFindFirstOrThrowArgs>
    ): Prisma__StateClient<StateGetPayload<T>>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.state.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stateWithIdOnly = await prisma.state.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StateFindManyArgs>(
      args?: SelectSubset<T, StateFindManyArgs>
    ): PrismaPromise<Array<StateGetPayload<T>>>

    /**
     * Create a State.
     * @param {StateCreateArgs} args - Arguments to create a State.
     * @example
     * // Create one State
     * const State = await prisma.state.create({
     *   data: {
     *     // ... data to create a State
     *   }
     * })
     * 
    **/
    create<T extends StateCreateArgs>(
      args: SelectSubset<T, StateCreateArgs>
    ): Prisma__StateClient<StateGetPayload<T>>

    /**
     * Create many States.
     *     @param {StateCreateManyArgs} args - Arguments to create many States.
     *     @example
     *     // Create many States
     *     const state = await prisma.state.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StateCreateManyArgs>(
      args?: SelectSubset<T, StateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a State.
     * @param {StateDeleteArgs} args - Arguments to delete one State.
     * @example
     * // Delete one State
     * const State = await prisma.state.delete({
     *   where: {
     *     // ... filter to delete one State
     *   }
     * })
     * 
    **/
    delete<T extends StateDeleteArgs>(
      args: SelectSubset<T, StateDeleteArgs>
    ): Prisma__StateClient<StateGetPayload<T>>

    /**
     * Update one State.
     * @param {StateUpdateArgs} args - Arguments to update one State.
     * @example
     * // Update one State
     * const state = await prisma.state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StateUpdateArgs>(
      args: SelectSubset<T, StateUpdateArgs>
    ): Prisma__StateClient<StateGetPayload<T>>

    /**
     * Delete zero or more States.
     * @param {StateDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StateDeleteManyArgs>(
      args?: SelectSubset<T, StateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const state = await prisma.state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StateUpdateManyArgs>(
      args: SelectSubset<T, StateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one State.
     * @param {StateUpsertArgs} args - Arguments to update or create a State.
     * @example
     * // Update or create a State
     * const state = await prisma.state.upsert({
     *   create: {
     *     // ... data to create a State
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State we want to update
     *   }
     * })
    **/
    upsert<T extends StateUpsertArgs>(
      args: SelectSubset<T, StateUpsertArgs>
    ): Prisma__StateClient<StateGetPayload<T>>

    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.state.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends StateCountArgs>(
      args?: Subset<T, StateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateAggregateArgs>(args: Subset<T, StateAggregateArgs>): PrismaPromise<GetStateAggregateType<T>>

    /**
     * Group by State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StateGroupByArgs['orderBy'] }
        : { orderBy?: StateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for State.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StateClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Country<T extends CountryArgs= {}>(args?: Subset<T, CountryArgs>): Prisma__CountryClient<CountryGetPayload<T> | Null>;

    City<T extends State$CityArgs= {}>(args?: Subset<T, State$CityArgs>): PrismaPromise<Array<CityGetPayload<T>>| Null>;

    StudentAddress<T extends State$StudentAddressArgs= {}>(args?: Subset<T, State$StudentAddressArgs>): PrismaPromise<Array<StudentAddressGetPayload<T>>| Null>;

    TeacherAddress<T extends State$TeacherAddressArgs= {}>(args?: Subset<T, State$TeacherAddressArgs>): PrismaPromise<Array<TeacherAddressGetPayload<T>>| Null>;

    SalesTeamAddress<T extends State$SalesTeamAddressArgs= {}>(args?: Subset<T, State$SalesTeamAddressArgs>): PrismaPromise<Array<SalesTeamAddressGetPayload<T>>| Null>;

    SchoolMasterAddress<T extends State$SchoolMasterAddressArgs= {}>(args?: Subset<T, State$SchoolMasterAddressArgs>): PrismaPromise<Array<SchoolMasterAddressGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * State base type for findUnique actions
   */
  export type StateFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude | null
    /**
     * Filter, which State to fetch.
     */
    where: StateWhereUniqueInput
  }

  /**
   * State findUnique
   */
  export interface StateFindUniqueArgs extends StateFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * State findUniqueOrThrow
   */
  export type StateFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude | null
    /**
     * Filter, which State to fetch.
     */
    where: StateWhereUniqueInput
  }


  /**
   * State base type for findFirst actions
   */
  export type StateFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude | null
    /**
     * Filter, which State to fetch.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     */
    distinct?: Enumerable<StateScalarFieldEnum>
  }

  /**
   * State findFirst
   */
  export interface StateFindFirstArgs extends StateFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * State findFirstOrThrow
   */
  export type StateFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude | null
    /**
     * Filter, which State to fetch.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     */
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * State findMany
   */
  export type StateFindManyArgs = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude | null
    /**
     * Filter, which States to fetch.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing States.
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * State create
   */
  export type StateCreateArgs = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude | null
    /**
     * The data needed to create a State.
     */
    data: XOR<StateCreateInput, StateUncheckedCreateInput>
  }


  /**
   * State createMany
   */
  export type StateCreateManyArgs = {
    /**
     * The data used to create many States.
     */
    data: Enumerable<StateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * State update
   */
  export type StateUpdateArgs = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude | null
    /**
     * The data needed to update a State.
     */
    data: XOR<StateUpdateInput, StateUncheckedUpdateInput>
    /**
     * Choose, which State to update.
     */
    where: StateWhereUniqueInput
  }


  /**
   * State updateMany
   */
  export type StateUpdateManyArgs = {
    /**
     * The data used to update States.
     */
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyInput>
    /**
     * Filter which States to update
     */
    where?: StateWhereInput
  }


  /**
   * State upsert
   */
  export type StateUpsertArgs = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude | null
    /**
     * The filter to search for the State to update in case it exists.
     */
    where: StateWhereUniqueInput
    /**
     * In case the State found by the `where` argument doesn't exist, create a new State with this data.
     */
    create: XOR<StateCreateInput, StateUncheckedCreateInput>
    /**
     * In case the State was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StateUpdateInput, StateUncheckedUpdateInput>
  }


  /**
   * State delete
   */
  export type StateDeleteArgs = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude | null
    /**
     * Filter which State to delete.
     */
    where: StateWhereUniqueInput
  }


  /**
   * State deleteMany
   */
  export type StateDeleteManyArgs = {
    /**
     * Filter which States to delete
     */
    where?: StateWhereInput
  }


  /**
   * State.City
   */
  export type State$CityArgs = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude | null
    where?: CityWhereInput
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * State.StudentAddress
   */
  export type State$StudentAddressArgs = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    where?: StudentAddressWhereInput
    orderBy?: Enumerable<StudentAddressOrderByWithRelationInput>
    cursor?: StudentAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentAddressScalarFieldEnum>
  }


  /**
   * State.TeacherAddress
   */
  export type State$TeacherAddressArgs = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    where?: TeacherAddressWhereInput
    orderBy?: Enumerable<TeacherAddressOrderByWithRelationInput>
    cursor?: TeacherAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherAddressScalarFieldEnum>
  }


  /**
   * State.SalesTeamAddress
   */
  export type State$SalesTeamAddressArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    where?: SalesTeamAddressWhereInput
    orderBy?: Enumerable<SalesTeamAddressOrderByWithRelationInput>
    cursor?: SalesTeamAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesTeamAddressScalarFieldEnum>
  }


  /**
   * State.SchoolMasterAddress
   */
  export type State$SchoolMasterAddressArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    where?: SchoolMasterAddressWhereInput
    orderBy?: Enumerable<SchoolMasterAddressOrderByWithRelationInput>
    cursor?: SchoolMasterAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SchoolMasterAddressScalarFieldEnum>
  }


  /**
   * State without action
   */
  export type StateArgs = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude | null
  }



  /**
   * Model City
   */


  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    CityName: string | null
    fkStateId: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    CityName: string | null
    fkStateId: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    CityName: number
    fkStateId: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type CityMinAggregateInputType = {
    id?: true
    CityName?: true
    fkStateId?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    CityName?: true
    fkStateId?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    CityName?: true
    fkStateId?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CityAggregateArgs = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs = {
    where?: CityWhereInput
    orderBy?: Enumerable<CityOrderByWithAggregationInput>
    by: CityScalarFieldEnum[]
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }


  export type CityGroupByOutputType = {
    id: string
    CityName: string
    fkStateId: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect = {
    id?: boolean
    CityName?: boolean
    State?: boolean | StateArgs
    fkStateId?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
    StudentAddress?: boolean | City$StudentAddressArgs
    TeacherAddress?: boolean | City$TeacherAddressArgs
    SalesTeamAddress?: boolean | City$SalesTeamAddressArgs
    SchoolMasterAddress?: boolean | City$SchoolMasterAddressArgs
    _count?: boolean | CityCountOutputTypeArgs
  }


  export type CityInclude = {
    State?: boolean | StateArgs
    StudentAddress?: boolean | City$StudentAddressArgs
    TeacherAddress?: boolean | City$TeacherAddressArgs
    SalesTeamAddress?: boolean | City$SalesTeamAddressArgs
    SchoolMasterAddress?: boolean | City$SchoolMasterAddressArgs
    _count?: boolean | CityCountOutputTypeArgs
  }

  export type CityGetPayload<S extends boolean | null | undefined | CityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? City :
    S extends undefined ? never :
    S extends { include: any } & (CityArgs | CityFindManyArgs)
    ? City  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'State' ? StateGetPayload<S['include'][P]> :
        P extends 'StudentAddress' ? Array < StudentAddressGetPayload<S['include'][P]>>  :
        P extends 'TeacherAddress' ? Array < TeacherAddressGetPayload<S['include'][P]>>  :
        P extends 'SalesTeamAddress' ? Array < SalesTeamAddressGetPayload<S['include'][P]>>  :
        P extends 'SchoolMasterAddress' ? Array < SchoolMasterAddressGetPayload<S['include'][P]>>  :
        P extends '_count' ? CityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CityArgs | CityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'State' ? StateGetPayload<S['select'][P]> :
        P extends 'StudentAddress' ? Array < StudentAddressGetPayload<S['select'][P]>>  :
        P extends 'TeacherAddress' ? Array < TeacherAddressGetPayload<S['select'][P]>>  :
        P extends 'SalesTeamAddress' ? Array < SalesTeamAddressGetPayload<S['select'][P]>>  :
        P extends 'SchoolMasterAddress' ? Array < SchoolMasterAddressGetPayload<S['select'][P]>>  :
        P extends '_count' ? CityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof City ? City[P] : never
  } 
      : City


  type CityCountArgs = 
    Omit<CityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'City'> extends True ? Prisma__CityClient<CityGetPayload<T>> : Prisma__CityClient<CityGetPayload<T> | null, null>

    /**
     * Find one City that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CityFindUniqueOrThrowArgs>
    ): Prisma__CityClient<CityGetPayload<T>>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'City'> extends True ? Prisma__CityClient<CityGetPayload<T>> : Prisma__CityClient<CityGetPayload<T> | null, null>

    /**
     * Find the first City that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CityFindFirstOrThrowArgs>
    ): Prisma__CityClient<CityGetPayload<T>>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs>(
      args?: SelectSubset<T, CityFindManyArgs>
    ): PrismaPromise<Array<CityGetPayload<T>>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs>(
      args: SelectSubset<T, CityCreateArgs>
    ): Prisma__CityClient<CityGetPayload<T>>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs>(
      args?: SelectSubset<T, CityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs>(
      args: SelectSubset<T, CityDeleteArgs>
    ): Prisma__CityClient<CityGetPayload<T>>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs>(
      args: SelectSubset<T, CityUpdateArgs>
    ): Prisma__CityClient<CityGetPayload<T>>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs>(
      args?: SelectSubset<T, CityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs>(
      args: SelectSubset<T, CityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs>(
      args: SelectSubset<T, CityUpsertArgs>
    ): Prisma__CityClient<CityGetPayload<T>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CityClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    State<T extends StateArgs= {}>(args?: Subset<T, StateArgs>): Prisma__StateClient<StateGetPayload<T> | Null>;

    StudentAddress<T extends City$StudentAddressArgs= {}>(args?: Subset<T, City$StudentAddressArgs>): PrismaPromise<Array<StudentAddressGetPayload<T>>| Null>;

    TeacherAddress<T extends City$TeacherAddressArgs= {}>(args?: Subset<T, City$TeacherAddressArgs>): PrismaPromise<Array<TeacherAddressGetPayload<T>>| Null>;

    SalesTeamAddress<T extends City$SalesTeamAddressArgs= {}>(args?: Subset<T, City$SalesTeamAddressArgs>): PrismaPromise<Array<SalesTeamAddressGetPayload<T>>| Null>;

    SchoolMasterAddress<T extends City$SchoolMasterAddressArgs= {}>(args?: Subset<T, City$SchoolMasterAddressArgs>): PrismaPromise<Array<SchoolMasterAddressGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * City base type for findUnique actions
   */
  export type CityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUnique
   */
  export interface CityFindUniqueArgs extends CityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City base type for findFirst actions
   */
  export type CityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: Enumerable<CityScalarFieldEnum>
  }

  /**
   * City findFirst
   */
  export interface CityFindFirstArgs extends CityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City findMany
   */
  export type CityFindManyArgs = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City create
   */
  export type CityCreateArgs = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs = {
    /**
     * The data used to create many Cities.
     */
    data: Enumerable<CityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * City update
   */
  export type CityUpdateArgs = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
  }


  /**
   * City.StudentAddress
   */
  export type City$StudentAddressArgs = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    where?: StudentAddressWhereInput
    orderBy?: Enumerable<StudentAddressOrderByWithRelationInput>
    cursor?: StudentAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentAddressScalarFieldEnum>
  }


  /**
   * City.TeacherAddress
   */
  export type City$TeacherAddressArgs = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    where?: TeacherAddressWhereInput
    orderBy?: Enumerable<TeacherAddressOrderByWithRelationInput>
    cursor?: TeacherAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherAddressScalarFieldEnum>
  }


  /**
   * City.SalesTeamAddress
   */
  export type City$SalesTeamAddressArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    where?: SalesTeamAddressWhereInput
    orderBy?: Enumerable<SalesTeamAddressOrderByWithRelationInput>
    cursor?: SalesTeamAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesTeamAddressScalarFieldEnum>
  }


  /**
   * City.SchoolMasterAddress
   */
  export type City$SchoolMasterAddressArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    where?: SchoolMasterAddressWhereInput
    orderBy?: Enumerable<SchoolMasterAddressOrderByWithRelationInput>
    cursor?: SchoolMasterAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SchoolMasterAddressScalarFieldEnum>
  }


  /**
   * City without action
   */
  export type CityArgs = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude | null
  }



  /**
   * Model Admin
   */


  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    email: number
    password: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs = {
    where?: AdminWhereInput
    orderBy?: Enumerable<AdminOrderByWithAggregationInput>
    by: AdminScalarFieldEnum[]
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }


  export type AdminGroupByOutputType = {
    id: string
    email: string
    password: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect = {
    id?: boolean
    email?: boolean
    password?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type AdminGetPayload<S extends boolean | null | undefined | AdminArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Admin :
    S extends undefined ? never :
    S extends { include: any } & (AdminArgs | AdminFindManyArgs)
    ? Admin 
    : S extends { select: any } & (AdminArgs | AdminFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Admin ? Admin[P] : never
  } 
      : Admin


  type AdminCountArgs = 
    Omit<AdminFindManyArgs, 'select' | 'include'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdminFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Admin'> extends True ? Prisma__AdminClient<AdminGetPayload<T>> : Prisma__AdminClient<AdminGetPayload<T> | null, null>

    /**
     * Find one Admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AdminFindUniqueOrThrowArgs>
    ): Prisma__AdminClient<AdminGetPayload<T>>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdminFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Admin'> extends True ? Prisma__AdminClient<AdminGetPayload<T>> : Prisma__AdminClient<AdminGetPayload<T> | null, null>

    /**
     * Find the first Admin that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AdminFindFirstOrThrowArgs>
    ): Prisma__AdminClient<AdminGetPayload<T>>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs>(
      args?: SelectSubset<T, AdminFindManyArgs>
    ): PrismaPromise<Array<AdminGetPayload<T>>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs>(
      args: SelectSubset<T, AdminCreateArgs>
    ): Prisma__AdminClient<AdminGetPayload<T>>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs>(
      args?: SelectSubset<T, AdminCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs>(
      args: SelectSubset<T, AdminDeleteArgs>
    ): Prisma__AdminClient<AdminGetPayload<T>>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs>(
      args: SelectSubset<T, AdminUpdateArgs>
    ): Prisma__AdminClient<AdminGetPayload<T>>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs>(
      args?: SelectSubset<T, AdminDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs>(
      args: SelectSubset<T, AdminUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs>(
      args: SelectSubset<T, AdminUpsertArgs>
    ): Prisma__AdminClient<AdminGetPayload<T>>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdminClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Admin base type for findUnique actions
   */
  export type AdminFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUnique
   */
  export interface AdminFindUniqueArgs extends AdminFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin base type for findFirst actions
   */
  export type AdminFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: Enumerable<AdminScalarFieldEnum>
  }

  /**
   * Admin findFirst
   */
  export interface AdminFindFirstArgs extends AdminFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs = {
    /**
     * The data used to create many Admins.
     */
    data: Enumerable<AdminCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminArgs = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect | null
  }



  /**
   * Model SalesTeam
   */


  export type AggregateSalesTeam = {
    _count: SalesTeamCountAggregateOutputType | null
    _min: SalesTeamMinAggregateOutputType | null
    _max: SalesTeamMaxAggregateOutputType | null
  }

  export type SalesTeamMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    password: string | null
    dob: Date | null
    fkDesignationId: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SalesTeamMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    password: string | null
    dob: Date | null
    fkDesignationId: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SalesTeamCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    password: number
    dob: number
    fkDesignationId: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type SalesTeamMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    dob?: true
    fkDesignationId?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SalesTeamMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    dob?: true
    fkDesignationId?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SalesTeamCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    dob?: true
    fkDesignationId?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesTeamAggregateArgs = {
    /**
     * Filter which SalesTeam to aggregate.
     */
    where?: SalesTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeams to fetch.
     */
    orderBy?: Enumerable<SalesTeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesTeams
    **/
    _count?: true | SalesTeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesTeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesTeamMaxAggregateInputType
  }

  export type GetSalesTeamAggregateType<T extends SalesTeamAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesTeam[P]>
      : GetScalarType<T[P], AggregateSalesTeam[P]>
  }




  export type SalesTeamGroupByArgs = {
    where?: SalesTeamWhereInput
    orderBy?: Enumerable<SalesTeamOrderByWithAggregationInput>
    by: SalesTeamScalarFieldEnum[]
    having?: SalesTeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesTeamCountAggregateInputType | true
    _min?: SalesTeamMinAggregateInputType
    _max?: SalesTeamMaxAggregateInputType
  }


  export type SalesTeamGroupByOutputType = {
    id: string
    email: string
    phone: string
    password: string
    dob: Date
    fkDesignationId: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: SalesTeamCountAggregateOutputType | null
    _min: SalesTeamMinAggregateOutputType | null
    _max: SalesTeamMaxAggregateOutputType | null
  }

  type GetSalesTeamGroupByPayload<T extends SalesTeamGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SalesTeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesTeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesTeamGroupByOutputType[P]>
            : GetScalarType<T[P], SalesTeamGroupByOutputType[P]>
        }
      >
    >


  export type SalesTeamSelect = {
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    dob?: boolean
    designation?: boolean | DesignationArgs
    fkDesignationId?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
    SalesTeamDocuments?: boolean | SalesTeam$SalesTeamDocumentsArgs
    SalesTeamAddress?: boolean | SalesTeam$SalesTeamAddressArgs
    schoolMaster?: boolean | SalesTeam$schoolMasterArgs
    _count?: boolean | SalesTeamCountOutputTypeArgs
  }


  export type SalesTeamInclude = {
    designation?: boolean | DesignationArgs
    SalesTeamDocuments?: boolean | SalesTeam$SalesTeamDocumentsArgs
    SalesTeamAddress?: boolean | SalesTeam$SalesTeamAddressArgs
    schoolMaster?: boolean | SalesTeam$schoolMasterArgs
    _count?: boolean | SalesTeamCountOutputTypeArgs
  }

  export type SalesTeamGetPayload<S extends boolean | null | undefined | SalesTeamArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SalesTeam :
    S extends undefined ? never :
    S extends { include: any } & (SalesTeamArgs | SalesTeamFindManyArgs)
    ? SalesTeam  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'designation' ? DesignationGetPayload<S['include'][P]> :
        P extends 'SalesTeamDocuments' ? Array < SalesTeamDocumentsGetPayload<S['include'][P]>>  :
        P extends 'SalesTeamAddress' ? Array < SalesTeamAddressGetPayload<S['include'][P]>>  :
        P extends 'schoolMaster' ? Array < schoolMasterGetPayload<S['include'][P]>>  :
        P extends '_count' ? SalesTeamCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SalesTeamArgs | SalesTeamFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'designation' ? DesignationGetPayload<S['select'][P]> :
        P extends 'SalesTeamDocuments' ? Array < SalesTeamDocumentsGetPayload<S['select'][P]>>  :
        P extends 'SalesTeamAddress' ? Array < SalesTeamAddressGetPayload<S['select'][P]>>  :
        P extends 'schoolMaster' ? Array < schoolMasterGetPayload<S['select'][P]>>  :
        P extends '_count' ? SalesTeamCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SalesTeam ? SalesTeam[P] : never
  } 
      : SalesTeam


  type SalesTeamCountArgs = 
    Omit<SalesTeamFindManyArgs, 'select' | 'include'> & {
      select?: SalesTeamCountAggregateInputType | true
    }

  export interface SalesTeamDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SalesTeam that matches the filter.
     * @param {SalesTeamFindUniqueArgs} args - Arguments to find a SalesTeam
     * @example
     * // Get one SalesTeam
     * const salesTeam = await prisma.salesTeam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SalesTeamFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SalesTeamFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SalesTeam'> extends True ? Prisma__SalesTeamClient<SalesTeamGetPayload<T>> : Prisma__SalesTeamClient<SalesTeamGetPayload<T> | null, null>

    /**
     * Find one SalesTeam that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SalesTeamFindUniqueOrThrowArgs} args - Arguments to find a SalesTeam
     * @example
     * // Get one SalesTeam
     * const salesTeam = await prisma.salesTeam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SalesTeamFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SalesTeamFindUniqueOrThrowArgs>
    ): Prisma__SalesTeamClient<SalesTeamGetPayload<T>>

    /**
     * Find the first SalesTeam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamFindFirstArgs} args - Arguments to find a SalesTeam
     * @example
     * // Get one SalesTeam
     * const salesTeam = await prisma.salesTeam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SalesTeamFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SalesTeamFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SalesTeam'> extends True ? Prisma__SalesTeamClient<SalesTeamGetPayload<T>> : Prisma__SalesTeamClient<SalesTeamGetPayload<T> | null, null>

    /**
     * Find the first SalesTeam that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamFindFirstOrThrowArgs} args - Arguments to find a SalesTeam
     * @example
     * // Get one SalesTeam
     * const salesTeam = await prisma.salesTeam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SalesTeamFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SalesTeamFindFirstOrThrowArgs>
    ): Prisma__SalesTeamClient<SalesTeamGetPayload<T>>

    /**
     * Find zero or more SalesTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesTeams
     * const salesTeams = await prisma.salesTeam.findMany()
     * 
     * // Get first 10 SalesTeams
     * const salesTeams = await prisma.salesTeam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesTeamWithIdOnly = await prisma.salesTeam.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SalesTeamFindManyArgs>(
      args?: SelectSubset<T, SalesTeamFindManyArgs>
    ): PrismaPromise<Array<SalesTeamGetPayload<T>>>

    /**
     * Create a SalesTeam.
     * @param {SalesTeamCreateArgs} args - Arguments to create a SalesTeam.
     * @example
     * // Create one SalesTeam
     * const SalesTeam = await prisma.salesTeam.create({
     *   data: {
     *     // ... data to create a SalesTeam
     *   }
     * })
     * 
    **/
    create<T extends SalesTeamCreateArgs>(
      args: SelectSubset<T, SalesTeamCreateArgs>
    ): Prisma__SalesTeamClient<SalesTeamGetPayload<T>>

    /**
     * Create many SalesTeams.
     *     @param {SalesTeamCreateManyArgs} args - Arguments to create many SalesTeams.
     *     @example
     *     // Create many SalesTeams
     *     const salesTeam = await prisma.salesTeam.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SalesTeamCreateManyArgs>(
      args?: SelectSubset<T, SalesTeamCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SalesTeam.
     * @param {SalesTeamDeleteArgs} args - Arguments to delete one SalesTeam.
     * @example
     * // Delete one SalesTeam
     * const SalesTeam = await prisma.salesTeam.delete({
     *   where: {
     *     // ... filter to delete one SalesTeam
     *   }
     * })
     * 
    **/
    delete<T extends SalesTeamDeleteArgs>(
      args: SelectSubset<T, SalesTeamDeleteArgs>
    ): Prisma__SalesTeamClient<SalesTeamGetPayload<T>>

    /**
     * Update one SalesTeam.
     * @param {SalesTeamUpdateArgs} args - Arguments to update one SalesTeam.
     * @example
     * // Update one SalesTeam
     * const salesTeam = await prisma.salesTeam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SalesTeamUpdateArgs>(
      args: SelectSubset<T, SalesTeamUpdateArgs>
    ): Prisma__SalesTeamClient<SalesTeamGetPayload<T>>

    /**
     * Delete zero or more SalesTeams.
     * @param {SalesTeamDeleteManyArgs} args - Arguments to filter SalesTeams to delete.
     * @example
     * // Delete a few SalesTeams
     * const { count } = await prisma.salesTeam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SalesTeamDeleteManyArgs>(
      args?: SelectSubset<T, SalesTeamDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesTeams
     * const salesTeam = await prisma.salesTeam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SalesTeamUpdateManyArgs>(
      args: SelectSubset<T, SalesTeamUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesTeam.
     * @param {SalesTeamUpsertArgs} args - Arguments to update or create a SalesTeam.
     * @example
     * // Update or create a SalesTeam
     * const salesTeam = await prisma.salesTeam.upsert({
     *   create: {
     *     // ... data to create a SalesTeam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesTeam we want to update
     *   }
     * })
    **/
    upsert<T extends SalesTeamUpsertArgs>(
      args: SelectSubset<T, SalesTeamUpsertArgs>
    ): Prisma__SalesTeamClient<SalesTeamGetPayload<T>>

    /**
     * Count the number of SalesTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamCountArgs} args - Arguments to filter SalesTeams to count.
     * @example
     * // Count the number of SalesTeams
     * const count = await prisma.salesTeam.count({
     *   where: {
     *     // ... the filter for the SalesTeams we want to count
     *   }
     * })
    **/
    count<T extends SalesTeamCountArgs>(
      args?: Subset<T, SalesTeamCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesTeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesTeamAggregateArgs>(args: Subset<T, SalesTeamAggregateArgs>): PrismaPromise<GetSalesTeamAggregateType<T>>

    /**
     * Group by SalesTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesTeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesTeamGroupByArgs['orderBy'] }
        : { orderBy?: SalesTeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesTeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesTeamGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesTeam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SalesTeamClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    designation<T extends DesignationArgs= {}>(args?: Subset<T, DesignationArgs>): Prisma__DesignationClient<DesignationGetPayload<T> | Null>;

    SalesTeamDocuments<T extends SalesTeam$SalesTeamDocumentsArgs= {}>(args?: Subset<T, SalesTeam$SalesTeamDocumentsArgs>): PrismaPromise<Array<SalesTeamDocumentsGetPayload<T>>| Null>;

    SalesTeamAddress<T extends SalesTeam$SalesTeamAddressArgs= {}>(args?: Subset<T, SalesTeam$SalesTeamAddressArgs>): PrismaPromise<Array<SalesTeamAddressGetPayload<T>>| Null>;

    schoolMaster<T extends SalesTeam$schoolMasterArgs= {}>(args?: Subset<T, SalesTeam$schoolMasterArgs>): PrismaPromise<Array<schoolMasterGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SalesTeam base type for findUnique actions
   */
  export type SalesTeamFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamInclude | null
    /**
     * Filter, which SalesTeam to fetch.
     */
    where: SalesTeamWhereUniqueInput
  }

  /**
   * SalesTeam findUnique
   */
  export interface SalesTeamFindUniqueArgs extends SalesTeamFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SalesTeam findUniqueOrThrow
   */
  export type SalesTeamFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamInclude | null
    /**
     * Filter, which SalesTeam to fetch.
     */
    where: SalesTeamWhereUniqueInput
  }


  /**
   * SalesTeam base type for findFirst actions
   */
  export type SalesTeamFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamInclude | null
    /**
     * Filter, which SalesTeam to fetch.
     */
    where?: SalesTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeams to fetch.
     */
    orderBy?: Enumerable<SalesTeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesTeams.
     */
    cursor?: SalesTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesTeams.
     */
    distinct?: Enumerable<SalesTeamScalarFieldEnum>
  }

  /**
   * SalesTeam findFirst
   */
  export interface SalesTeamFindFirstArgs extends SalesTeamFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SalesTeam findFirstOrThrow
   */
  export type SalesTeamFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamInclude | null
    /**
     * Filter, which SalesTeam to fetch.
     */
    where?: SalesTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeams to fetch.
     */
    orderBy?: Enumerable<SalesTeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesTeams.
     */
    cursor?: SalesTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesTeams.
     */
    distinct?: Enumerable<SalesTeamScalarFieldEnum>
  }


  /**
   * SalesTeam findMany
   */
  export type SalesTeamFindManyArgs = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamInclude | null
    /**
     * Filter, which SalesTeams to fetch.
     */
    where?: SalesTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeams to fetch.
     */
    orderBy?: Enumerable<SalesTeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesTeams.
     */
    cursor?: SalesTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeams.
     */
    skip?: number
    distinct?: Enumerable<SalesTeamScalarFieldEnum>
  }


  /**
   * SalesTeam create
   */
  export type SalesTeamCreateArgs = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamInclude | null
    /**
     * The data needed to create a SalesTeam.
     */
    data: XOR<SalesTeamCreateInput, SalesTeamUncheckedCreateInput>
  }


  /**
   * SalesTeam createMany
   */
  export type SalesTeamCreateManyArgs = {
    /**
     * The data used to create many SalesTeams.
     */
    data: Enumerable<SalesTeamCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SalesTeam update
   */
  export type SalesTeamUpdateArgs = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamInclude | null
    /**
     * The data needed to update a SalesTeam.
     */
    data: XOR<SalesTeamUpdateInput, SalesTeamUncheckedUpdateInput>
    /**
     * Choose, which SalesTeam to update.
     */
    where: SalesTeamWhereUniqueInput
  }


  /**
   * SalesTeam updateMany
   */
  export type SalesTeamUpdateManyArgs = {
    /**
     * The data used to update SalesTeams.
     */
    data: XOR<SalesTeamUpdateManyMutationInput, SalesTeamUncheckedUpdateManyInput>
    /**
     * Filter which SalesTeams to update
     */
    where?: SalesTeamWhereInput
  }


  /**
   * SalesTeam upsert
   */
  export type SalesTeamUpsertArgs = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamInclude | null
    /**
     * The filter to search for the SalesTeam to update in case it exists.
     */
    where: SalesTeamWhereUniqueInput
    /**
     * In case the SalesTeam found by the `where` argument doesn't exist, create a new SalesTeam with this data.
     */
    create: XOR<SalesTeamCreateInput, SalesTeamUncheckedCreateInput>
    /**
     * In case the SalesTeam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesTeamUpdateInput, SalesTeamUncheckedUpdateInput>
  }


  /**
   * SalesTeam delete
   */
  export type SalesTeamDeleteArgs = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamInclude | null
    /**
     * Filter which SalesTeam to delete.
     */
    where: SalesTeamWhereUniqueInput
  }


  /**
   * SalesTeam deleteMany
   */
  export type SalesTeamDeleteManyArgs = {
    /**
     * Filter which SalesTeams to delete
     */
    where?: SalesTeamWhereInput
  }


  /**
   * SalesTeam.SalesTeamDocuments
   */
  export type SalesTeam$SalesTeamDocumentsArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamDocuments
     */
    select?: SalesTeamDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamDocumentsInclude | null
    where?: SalesTeamDocumentsWhereInput
    orderBy?: Enumerable<SalesTeamDocumentsOrderByWithRelationInput>
    cursor?: SalesTeamDocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesTeamDocumentsScalarFieldEnum>
  }


  /**
   * SalesTeam.SalesTeamAddress
   */
  export type SalesTeam$SalesTeamAddressArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    where?: SalesTeamAddressWhereInput
    orderBy?: Enumerable<SalesTeamAddressOrderByWithRelationInput>
    cursor?: SalesTeamAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesTeamAddressScalarFieldEnum>
  }


  /**
   * SalesTeam.schoolMaster
   */
  export type SalesTeam$schoolMasterArgs = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
    where?: schoolMasterWhereInput
    orderBy?: Enumerable<schoolMasterOrderByWithRelationInput>
    cursor?: schoolMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SchoolMasterScalarFieldEnum>
  }


  /**
   * SalesTeam without action
   */
  export type SalesTeamArgs = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamInclude | null
  }



  /**
   * Model SalesTeamDocuments
   */


  export type AggregateSalesTeamDocuments = {
    _count: SalesTeamDocumentsCountAggregateOutputType | null
    _min: SalesTeamDocumentsMinAggregateOutputType | null
    _max: SalesTeamDocumentsMaxAggregateOutputType | null
  }

  export type SalesTeamDocumentsMinAggregateOutputType = {
    id: string | null
    fkSalesTeamId: string | null
    category: string | null
    comment: string | null
    url: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SalesTeamDocumentsMaxAggregateOutputType = {
    id: string | null
    fkSalesTeamId: string | null
    category: string | null
    comment: string | null
    url: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SalesTeamDocumentsCountAggregateOutputType = {
    id: number
    fkSalesTeamId: number
    category: number
    comment: number
    url: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type SalesTeamDocumentsMinAggregateInputType = {
    id?: true
    fkSalesTeamId?: true
    category?: true
    comment?: true
    url?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SalesTeamDocumentsMaxAggregateInputType = {
    id?: true
    fkSalesTeamId?: true
    category?: true
    comment?: true
    url?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SalesTeamDocumentsCountAggregateInputType = {
    id?: true
    fkSalesTeamId?: true
    category?: true
    comment?: true
    url?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesTeamDocumentsAggregateArgs = {
    /**
     * Filter which SalesTeamDocuments to aggregate.
     */
    where?: SalesTeamDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamDocuments to fetch.
     */
    orderBy?: Enumerable<SalesTeamDocumentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesTeamDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesTeamDocuments
    **/
    _count?: true | SalesTeamDocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesTeamDocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesTeamDocumentsMaxAggregateInputType
  }

  export type GetSalesTeamDocumentsAggregateType<T extends SalesTeamDocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesTeamDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesTeamDocuments[P]>
      : GetScalarType<T[P], AggregateSalesTeamDocuments[P]>
  }




  export type SalesTeamDocumentsGroupByArgs = {
    where?: SalesTeamDocumentsWhereInput
    orderBy?: Enumerable<SalesTeamDocumentsOrderByWithAggregationInput>
    by: SalesTeamDocumentsScalarFieldEnum[]
    having?: SalesTeamDocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesTeamDocumentsCountAggregateInputType | true
    _min?: SalesTeamDocumentsMinAggregateInputType
    _max?: SalesTeamDocumentsMaxAggregateInputType
  }


  export type SalesTeamDocumentsGroupByOutputType = {
    id: string
    fkSalesTeamId: string
    category: string
    comment: string
    url: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: SalesTeamDocumentsCountAggregateOutputType | null
    _min: SalesTeamDocumentsMinAggregateOutputType | null
    _max: SalesTeamDocumentsMaxAggregateOutputType | null
  }

  type GetSalesTeamDocumentsGroupByPayload<T extends SalesTeamDocumentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SalesTeamDocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesTeamDocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesTeamDocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], SalesTeamDocumentsGroupByOutputType[P]>
        }
      >
    >


  export type SalesTeamDocumentsSelect = {
    id?: boolean
    salesTeam?: boolean | SalesTeamArgs
    fkSalesTeamId?: boolean
    category?: boolean
    comment?: boolean
    url?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type SalesTeamDocumentsInclude = {
    salesTeam?: boolean | SalesTeamArgs
  }

  export type SalesTeamDocumentsGetPayload<S extends boolean | null | undefined | SalesTeamDocumentsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SalesTeamDocuments :
    S extends undefined ? never :
    S extends { include: any } & (SalesTeamDocumentsArgs | SalesTeamDocumentsFindManyArgs)
    ? SalesTeamDocuments  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'salesTeam' ? SalesTeamGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SalesTeamDocumentsArgs | SalesTeamDocumentsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'salesTeam' ? SalesTeamGetPayload<S['select'][P]> :  P extends keyof SalesTeamDocuments ? SalesTeamDocuments[P] : never
  } 
      : SalesTeamDocuments


  type SalesTeamDocumentsCountArgs = 
    Omit<SalesTeamDocumentsFindManyArgs, 'select' | 'include'> & {
      select?: SalesTeamDocumentsCountAggregateInputType | true
    }

  export interface SalesTeamDocumentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SalesTeamDocuments that matches the filter.
     * @param {SalesTeamDocumentsFindUniqueArgs} args - Arguments to find a SalesTeamDocuments
     * @example
     * // Get one SalesTeamDocuments
     * const salesTeamDocuments = await prisma.salesTeamDocuments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SalesTeamDocumentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SalesTeamDocumentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SalesTeamDocuments'> extends True ? Prisma__SalesTeamDocumentsClient<SalesTeamDocumentsGetPayload<T>> : Prisma__SalesTeamDocumentsClient<SalesTeamDocumentsGetPayload<T> | null, null>

    /**
     * Find one SalesTeamDocuments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SalesTeamDocumentsFindUniqueOrThrowArgs} args - Arguments to find a SalesTeamDocuments
     * @example
     * // Get one SalesTeamDocuments
     * const salesTeamDocuments = await prisma.salesTeamDocuments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SalesTeamDocumentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SalesTeamDocumentsFindUniqueOrThrowArgs>
    ): Prisma__SalesTeamDocumentsClient<SalesTeamDocumentsGetPayload<T>>

    /**
     * Find the first SalesTeamDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamDocumentsFindFirstArgs} args - Arguments to find a SalesTeamDocuments
     * @example
     * // Get one SalesTeamDocuments
     * const salesTeamDocuments = await prisma.salesTeamDocuments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SalesTeamDocumentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SalesTeamDocumentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SalesTeamDocuments'> extends True ? Prisma__SalesTeamDocumentsClient<SalesTeamDocumentsGetPayload<T>> : Prisma__SalesTeamDocumentsClient<SalesTeamDocumentsGetPayload<T> | null, null>

    /**
     * Find the first SalesTeamDocuments that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamDocumentsFindFirstOrThrowArgs} args - Arguments to find a SalesTeamDocuments
     * @example
     * // Get one SalesTeamDocuments
     * const salesTeamDocuments = await prisma.salesTeamDocuments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SalesTeamDocumentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SalesTeamDocumentsFindFirstOrThrowArgs>
    ): Prisma__SalesTeamDocumentsClient<SalesTeamDocumentsGetPayload<T>>

    /**
     * Find zero or more SalesTeamDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamDocumentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesTeamDocuments
     * const salesTeamDocuments = await prisma.salesTeamDocuments.findMany()
     * 
     * // Get first 10 SalesTeamDocuments
     * const salesTeamDocuments = await prisma.salesTeamDocuments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesTeamDocumentsWithIdOnly = await prisma.salesTeamDocuments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SalesTeamDocumentsFindManyArgs>(
      args?: SelectSubset<T, SalesTeamDocumentsFindManyArgs>
    ): PrismaPromise<Array<SalesTeamDocumentsGetPayload<T>>>

    /**
     * Create a SalesTeamDocuments.
     * @param {SalesTeamDocumentsCreateArgs} args - Arguments to create a SalesTeamDocuments.
     * @example
     * // Create one SalesTeamDocuments
     * const SalesTeamDocuments = await prisma.salesTeamDocuments.create({
     *   data: {
     *     // ... data to create a SalesTeamDocuments
     *   }
     * })
     * 
    **/
    create<T extends SalesTeamDocumentsCreateArgs>(
      args: SelectSubset<T, SalesTeamDocumentsCreateArgs>
    ): Prisma__SalesTeamDocumentsClient<SalesTeamDocumentsGetPayload<T>>

    /**
     * Create many SalesTeamDocuments.
     *     @param {SalesTeamDocumentsCreateManyArgs} args - Arguments to create many SalesTeamDocuments.
     *     @example
     *     // Create many SalesTeamDocuments
     *     const salesTeamDocuments = await prisma.salesTeamDocuments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SalesTeamDocumentsCreateManyArgs>(
      args?: SelectSubset<T, SalesTeamDocumentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SalesTeamDocuments.
     * @param {SalesTeamDocumentsDeleteArgs} args - Arguments to delete one SalesTeamDocuments.
     * @example
     * // Delete one SalesTeamDocuments
     * const SalesTeamDocuments = await prisma.salesTeamDocuments.delete({
     *   where: {
     *     // ... filter to delete one SalesTeamDocuments
     *   }
     * })
     * 
    **/
    delete<T extends SalesTeamDocumentsDeleteArgs>(
      args: SelectSubset<T, SalesTeamDocumentsDeleteArgs>
    ): Prisma__SalesTeamDocumentsClient<SalesTeamDocumentsGetPayload<T>>

    /**
     * Update one SalesTeamDocuments.
     * @param {SalesTeamDocumentsUpdateArgs} args - Arguments to update one SalesTeamDocuments.
     * @example
     * // Update one SalesTeamDocuments
     * const salesTeamDocuments = await prisma.salesTeamDocuments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SalesTeamDocumentsUpdateArgs>(
      args: SelectSubset<T, SalesTeamDocumentsUpdateArgs>
    ): Prisma__SalesTeamDocumentsClient<SalesTeamDocumentsGetPayload<T>>

    /**
     * Delete zero or more SalesTeamDocuments.
     * @param {SalesTeamDocumentsDeleteManyArgs} args - Arguments to filter SalesTeamDocuments to delete.
     * @example
     * // Delete a few SalesTeamDocuments
     * const { count } = await prisma.salesTeamDocuments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SalesTeamDocumentsDeleteManyArgs>(
      args?: SelectSubset<T, SalesTeamDocumentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesTeamDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamDocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesTeamDocuments
     * const salesTeamDocuments = await prisma.salesTeamDocuments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SalesTeamDocumentsUpdateManyArgs>(
      args: SelectSubset<T, SalesTeamDocumentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesTeamDocuments.
     * @param {SalesTeamDocumentsUpsertArgs} args - Arguments to update or create a SalesTeamDocuments.
     * @example
     * // Update or create a SalesTeamDocuments
     * const salesTeamDocuments = await prisma.salesTeamDocuments.upsert({
     *   create: {
     *     // ... data to create a SalesTeamDocuments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesTeamDocuments we want to update
     *   }
     * })
    **/
    upsert<T extends SalesTeamDocumentsUpsertArgs>(
      args: SelectSubset<T, SalesTeamDocumentsUpsertArgs>
    ): Prisma__SalesTeamDocumentsClient<SalesTeamDocumentsGetPayload<T>>

    /**
     * Count the number of SalesTeamDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamDocumentsCountArgs} args - Arguments to filter SalesTeamDocuments to count.
     * @example
     * // Count the number of SalesTeamDocuments
     * const count = await prisma.salesTeamDocuments.count({
     *   where: {
     *     // ... the filter for the SalesTeamDocuments we want to count
     *   }
     * })
    **/
    count<T extends SalesTeamDocumentsCountArgs>(
      args?: Subset<T, SalesTeamDocumentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesTeamDocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesTeamDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamDocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesTeamDocumentsAggregateArgs>(args: Subset<T, SalesTeamDocumentsAggregateArgs>): PrismaPromise<GetSalesTeamDocumentsAggregateType<T>>

    /**
     * Group by SalesTeamDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamDocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesTeamDocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesTeamDocumentsGroupByArgs['orderBy'] }
        : { orderBy?: SalesTeamDocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesTeamDocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesTeamDocumentsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesTeamDocuments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SalesTeamDocumentsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    salesTeam<T extends SalesTeamArgs= {}>(args?: Subset<T, SalesTeamArgs>): Prisma__SalesTeamClient<SalesTeamGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SalesTeamDocuments base type for findUnique actions
   */
  export type SalesTeamDocumentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SalesTeamDocuments
     */
    select?: SalesTeamDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamDocumentsInclude | null
    /**
     * Filter, which SalesTeamDocuments to fetch.
     */
    where: SalesTeamDocumentsWhereUniqueInput
  }

  /**
   * SalesTeamDocuments findUnique
   */
  export interface SalesTeamDocumentsFindUniqueArgs extends SalesTeamDocumentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SalesTeamDocuments findUniqueOrThrow
   */
  export type SalesTeamDocumentsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamDocuments
     */
    select?: SalesTeamDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamDocumentsInclude | null
    /**
     * Filter, which SalesTeamDocuments to fetch.
     */
    where: SalesTeamDocumentsWhereUniqueInput
  }


  /**
   * SalesTeamDocuments base type for findFirst actions
   */
  export type SalesTeamDocumentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SalesTeamDocuments
     */
    select?: SalesTeamDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamDocumentsInclude | null
    /**
     * Filter, which SalesTeamDocuments to fetch.
     */
    where?: SalesTeamDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamDocuments to fetch.
     */
    orderBy?: Enumerable<SalesTeamDocumentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesTeamDocuments.
     */
    cursor?: SalesTeamDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesTeamDocuments.
     */
    distinct?: Enumerable<SalesTeamDocumentsScalarFieldEnum>
  }

  /**
   * SalesTeamDocuments findFirst
   */
  export interface SalesTeamDocumentsFindFirstArgs extends SalesTeamDocumentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SalesTeamDocuments findFirstOrThrow
   */
  export type SalesTeamDocumentsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamDocuments
     */
    select?: SalesTeamDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamDocumentsInclude | null
    /**
     * Filter, which SalesTeamDocuments to fetch.
     */
    where?: SalesTeamDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamDocuments to fetch.
     */
    orderBy?: Enumerable<SalesTeamDocumentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesTeamDocuments.
     */
    cursor?: SalesTeamDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesTeamDocuments.
     */
    distinct?: Enumerable<SalesTeamDocumentsScalarFieldEnum>
  }


  /**
   * SalesTeamDocuments findMany
   */
  export type SalesTeamDocumentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamDocuments
     */
    select?: SalesTeamDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamDocumentsInclude | null
    /**
     * Filter, which SalesTeamDocuments to fetch.
     */
    where?: SalesTeamDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamDocuments to fetch.
     */
    orderBy?: Enumerable<SalesTeamDocumentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesTeamDocuments.
     */
    cursor?: SalesTeamDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamDocuments.
     */
    skip?: number
    distinct?: Enumerable<SalesTeamDocumentsScalarFieldEnum>
  }


  /**
   * SalesTeamDocuments create
   */
  export type SalesTeamDocumentsCreateArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamDocuments
     */
    select?: SalesTeamDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamDocumentsInclude | null
    /**
     * The data needed to create a SalesTeamDocuments.
     */
    data: XOR<SalesTeamDocumentsCreateInput, SalesTeamDocumentsUncheckedCreateInput>
  }


  /**
   * SalesTeamDocuments createMany
   */
  export type SalesTeamDocumentsCreateManyArgs = {
    /**
     * The data used to create many SalesTeamDocuments.
     */
    data: Enumerable<SalesTeamDocumentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SalesTeamDocuments update
   */
  export type SalesTeamDocumentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamDocuments
     */
    select?: SalesTeamDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamDocumentsInclude | null
    /**
     * The data needed to update a SalesTeamDocuments.
     */
    data: XOR<SalesTeamDocumentsUpdateInput, SalesTeamDocumentsUncheckedUpdateInput>
    /**
     * Choose, which SalesTeamDocuments to update.
     */
    where: SalesTeamDocumentsWhereUniqueInput
  }


  /**
   * SalesTeamDocuments updateMany
   */
  export type SalesTeamDocumentsUpdateManyArgs = {
    /**
     * The data used to update SalesTeamDocuments.
     */
    data: XOR<SalesTeamDocumentsUpdateManyMutationInput, SalesTeamDocumentsUncheckedUpdateManyInput>
    /**
     * Filter which SalesTeamDocuments to update
     */
    where?: SalesTeamDocumentsWhereInput
  }


  /**
   * SalesTeamDocuments upsert
   */
  export type SalesTeamDocumentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamDocuments
     */
    select?: SalesTeamDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamDocumentsInclude | null
    /**
     * The filter to search for the SalesTeamDocuments to update in case it exists.
     */
    where: SalesTeamDocumentsWhereUniqueInput
    /**
     * In case the SalesTeamDocuments found by the `where` argument doesn't exist, create a new SalesTeamDocuments with this data.
     */
    create: XOR<SalesTeamDocumentsCreateInput, SalesTeamDocumentsUncheckedCreateInput>
    /**
     * In case the SalesTeamDocuments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesTeamDocumentsUpdateInput, SalesTeamDocumentsUncheckedUpdateInput>
  }


  /**
   * SalesTeamDocuments delete
   */
  export type SalesTeamDocumentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamDocuments
     */
    select?: SalesTeamDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamDocumentsInclude | null
    /**
     * Filter which SalesTeamDocuments to delete.
     */
    where: SalesTeamDocumentsWhereUniqueInput
  }


  /**
   * SalesTeamDocuments deleteMany
   */
  export type SalesTeamDocumentsDeleteManyArgs = {
    /**
     * Filter which SalesTeamDocuments to delete
     */
    where?: SalesTeamDocumentsWhereInput
  }


  /**
   * SalesTeamDocuments without action
   */
  export type SalesTeamDocumentsArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamDocuments
     */
    select?: SalesTeamDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamDocumentsInclude | null
  }



  /**
   * Model SalesTeamAddress
   */


  export type AggregateSalesTeamAddress = {
    _count: SalesTeamAddressCountAggregateOutputType | null
    _min: SalesTeamAddressMinAggregateOutputType | null
    _max: SalesTeamAddressMaxAggregateOutputType | null
  }

  export type SalesTeamAddressMinAggregateOutputType = {
    id: string | null
    fkSalesTeamId: string | null
    fkCountryId: string | null
    fkStateId: string | null
    fkCityId: string | null
    Address: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SalesTeamAddressMaxAggregateOutputType = {
    id: string | null
    fkSalesTeamId: string | null
    fkCountryId: string | null
    fkStateId: string | null
    fkCityId: string | null
    Address: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SalesTeamAddressCountAggregateOutputType = {
    id: number
    fkSalesTeamId: number
    fkCountryId: number
    fkStateId: number
    fkCityId: number
    Address: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type SalesTeamAddressMinAggregateInputType = {
    id?: true
    fkSalesTeamId?: true
    fkCountryId?: true
    fkStateId?: true
    fkCityId?: true
    Address?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SalesTeamAddressMaxAggregateInputType = {
    id?: true
    fkSalesTeamId?: true
    fkCountryId?: true
    fkStateId?: true
    fkCityId?: true
    Address?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SalesTeamAddressCountAggregateInputType = {
    id?: true
    fkSalesTeamId?: true
    fkCountryId?: true
    fkStateId?: true
    fkCityId?: true
    Address?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesTeamAddressAggregateArgs = {
    /**
     * Filter which SalesTeamAddress to aggregate.
     */
    where?: SalesTeamAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamAddresses to fetch.
     */
    orderBy?: Enumerable<SalesTeamAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesTeamAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesTeamAddresses
    **/
    _count?: true | SalesTeamAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesTeamAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesTeamAddressMaxAggregateInputType
  }

  export type GetSalesTeamAddressAggregateType<T extends SalesTeamAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesTeamAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesTeamAddress[P]>
      : GetScalarType<T[P], AggregateSalesTeamAddress[P]>
  }




  export type SalesTeamAddressGroupByArgs = {
    where?: SalesTeamAddressWhereInput
    orderBy?: Enumerable<SalesTeamAddressOrderByWithAggregationInput>
    by: SalesTeamAddressScalarFieldEnum[]
    having?: SalesTeamAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesTeamAddressCountAggregateInputType | true
    _min?: SalesTeamAddressMinAggregateInputType
    _max?: SalesTeamAddressMaxAggregateInputType
  }


  export type SalesTeamAddressGroupByOutputType = {
    id: string
    fkSalesTeamId: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: SalesTeamAddressCountAggregateOutputType | null
    _min: SalesTeamAddressMinAggregateOutputType | null
    _max: SalesTeamAddressMaxAggregateOutputType | null
  }

  type GetSalesTeamAddressGroupByPayload<T extends SalesTeamAddressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SalesTeamAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesTeamAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesTeamAddressGroupByOutputType[P]>
            : GetScalarType<T[P], SalesTeamAddressGroupByOutputType[P]>
        }
      >
    >


  export type SalesTeamAddressSelect = {
    id?: boolean
    salesTeam?: boolean | SalesTeamArgs
    fkSalesTeamId?: boolean
    Country?: boolean | CountryArgs
    fkCountryId?: boolean
    State?: boolean | StateArgs
    fkStateId?: boolean
    City?: boolean | CityArgs
    fkCityId?: boolean
    Address?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type SalesTeamAddressInclude = {
    salesTeam?: boolean | SalesTeamArgs
    Country?: boolean | CountryArgs
    State?: boolean | StateArgs
    City?: boolean | CityArgs
  }

  export type SalesTeamAddressGetPayload<S extends boolean | null | undefined | SalesTeamAddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SalesTeamAddress :
    S extends undefined ? never :
    S extends { include: any } & (SalesTeamAddressArgs | SalesTeamAddressFindManyArgs)
    ? SalesTeamAddress  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'salesTeam' ? SalesTeamGetPayload<S['include'][P]> :
        P extends 'Country' ? CountryGetPayload<S['include'][P]> :
        P extends 'State' ? StateGetPayload<S['include'][P]> :
        P extends 'City' ? CityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SalesTeamAddressArgs | SalesTeamAddressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'salesTeam' ? SalesTeamGetPayload<S['select'][P]> :
        P extends 'Country' ? CountryGetPayload<S['select'][P]> :
        P extends 'State' ? StateGetPayload<S['select'][P]> :
        P extends 'City' ? CityGetPayload<S['select'][P]> :  P extends keyof SalesTeamAddress ? SalesTeamAddress[P] : never
  } 
      : SalesTeamAddress


  type SalesTeamAddressCountArgs = 
    Omit<SalesTeamAddressFindManyArgs, 'select' | 'include'> & {
      select?: SalesTeamAddressCountAggregateInputType | true
    }

  export interface SalesTeamAddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SalesTeamAddress that matches the filter.
     * @param {SalesTeamAddressFindUniqueArgs} args - Arguments to find a SalesTeamAddress
     * @example
     * // Get one SalesTeamAddress
     * const salesTeamAddress = await prisma.salesTeamAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SalesTeamAddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SalesTeamAddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SalesTeamAddress'> extends True ? Prisma__SalesTeamAddressClient<SalesTeamAddressGetPayload<T>> : Prisma__SalesTeamAddressClient<SalesTeamAddressGetPayload<T> | null, null>

    /**
     * Find one SalesTeamAddress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SalesTeamAddressFindUniqueOrThrowArgs} args - Arguments to find a SalesTeamAddress
     * @example
     * // Get one SalesTeamAddress
     * const salesTeamAddress = await prisma.salesTeamAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SalesTeamAddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SalesTeamAddressFindUniqueOrThrowArgs>
    ): Prisma__SalesTeamAddressClient<SalesTeamAddressGetPayload<T>>

    /**
     * Find the first SalesTeamAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamAddressFindFirstArgs} args - Arguments to find a SalesTeamAddress
     * @example
     * // Get one SalesTeamAddress
     * const salesTeamAddress = await prisma.salesTeamAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SalesTeamAddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SalesTeamAddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SalesTeamAddress'> extends True ? Prisma__SalesTeamAddressClient<SalesTeamAddressGetPayload<T>> : Prisma__SalesTeamAddressClient<SalesTeamAddressGetPayload<T> | null, null>

    /**
     * Find the first SalesTeamAddress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamAddressFindFirstOrThrowArgs} args - Arguments to find a SalesTeamAddress
     * @example
     * // Get one SalesTeamAddress
     * const salesTeamAddress = await prisma.salesTeamAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SalesTeamAddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SalesTeamAddressFindFirstOrThrowArgs>
    ): Prisma__SalesTeamAddressClient<SalesTeamAddressGetPayload<T>>

    /**
     * Find zero or more SalesTeamAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamAddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesTeamAddresses
     * const salesTeamAddresses = await prisma.salesTeamAddress.findMany()
     * 
     * // Get first 10 SalesTeamAddresses
     * const salesTeamAddresses = await prisma.salesTeamAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesTeamAddressWithIdOnly = await prisma.salesTeamAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SalesTeamAddressFindManyArgs>(
      args?: SelectSubset<T, SalesTeamAddressFindManyArgs>
    ): PrismaPromise<Array<SalesTeamAddressGetPayload<T>>>

    /**
     * Create a SalesTeamAddress.
     * @param {SalesTeamAddressCreateArgs} args - Arguments to create a SalesTeamAddress.
     * @example
     * // Create one SalesTeamAddress
     * const SalesTeamAddress = await prisma.salesTeamAddress.create({
     *   data: {
     *     // ... data to create a SalesTeamAddress
     *   }
     * })
     * 
    **/
    create<T extends SalesTeamAddressCreateArgs>(
      args: SelectSubset<T, SalesTeamAddressCreateArgs>
    ): Prisma__SalesTeamAddressClient<SalesTeamAddressGetPayload<T>>

    /**
     * Create many SalesTeamAddresses.
     *     @param {SalesTeamAddressCreateManyArgs} args - Arguments to create many SalesTeamAddresses.
     *     @example
     *     // Create many SalesTeamAddresses
     *     const salesTeamAddress = await prisma.salesTeamAddress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SalesTeamAddressCreateManyArgs>(
      args?: SelectSubset<T, SalesTeamAddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SalesTeamAddress.
     * @param {SalesTeamAddressDeleteArgs} args - Arguments to delete one SalesTeamAddress.
     * @example
     * // Delete one SalesTeamAddress
     * const SalesTeamAddress = await prisma.salesTeamAddress.delete({
     *   where: {
     *     // ... filter to delete one SalesTeamAddress
     *   }
     * })
     * 
    **/
    delete<T extends SalesTeamAddressDeleteArgs>(
      args: SelectSubset<T, SalesTeamAddressDeleteArgs>
    ): Prisma__SalesTeamAddressClient<SalesTeamAddressGetPayload<T>>

    /**
     * Update one SalesTeamAddress.
     * @param {SalesTeamAddressUpdateArgs} args - Arguments to update one SalesTeamAddress.
     * @example
     * // Update one SalesTeamAddress
     * const salesTeamAddress = await prisma.salesTeamAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SalesTeamAddressUpdateArgs>(
      args: SelectSubset<T, SalesTeamAddressUpdateArgs>
    ): Prisma__SalesTeamAddressClient<SalesTeamAddressGetPayload<T>>

    /**
     * Delete zero or more SalesTeamAddresses.
     * @param {SalesTeamAddressDeleteManyArgs} args - Arguments to filter SalesTeamAddresses to delete.
     * @example
     * // Delete a few SalesTeamAddresses
     * const { count } = await prisma.salesTeamAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SalesTeamAddressDeleteManyArgs>(
      args?: SelectSubset<T, SalesTeamAddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesTeamAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesTeamAddresses
     * const salesTeamAddress = await prisma.salesTeamAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SalesTeamAddressUpdateManyArgs>(
      args: SelectSubset<T, SalesTeamAddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesTeamAddress.
     * @param {SalesTeamAddressUpsertArgs} args - Arguments to update or create a SalesTeamAddress.
     * @example
     * // Update or create a SalesTeamAddress
     * const salesTeamAddress = await prisma.salesTeamAddress.upsert({
     *   create: {
     *     // ... data to create a SalesTeamAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesTeamAddress we want to update
     *   }
     * })
    **/
    upsert<T extends SalesTeamAddressUpsertArgs>(
      args: SelectSubset<T, SalesTeamAddressUpsertArgs>
    ): Prisma__SalesTeamAddressClient<SalesTeamAddressGetPayload<T>>

    /**
     * Count the number of SalesTeamAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamAddressCountArgs} args - Arguments to filter SalesTeamAddresses to count.
     * @example
     * // Count the number of SalesTeamAddresses
     * const count = await prisma.salesTeamAddress.count({
     *   where: {
     *     // ... the filter for the SalesTeamAddresses we want to count
     *   }
     * })
    **/
    count<T extends SalesTeamAddressCountArgs>(
      args?: Subset<T, SalesTeamAddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesTeamAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesTeamAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesTeamAddressAggregateArgs>(args: Subset<T, SalesTeamAddressAggregateArgs>): PrismaPromise<GetSalesTeamAddressAggregateType<T>>

    /**
     * Group by SalesTeamAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesTeamAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesTeamAddressGroupByArgs['orderBy'] }
        : { orderBy?: SalesTeamAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesTeamAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesTeamAddressGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesTeamAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SalesTeamAddressClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    salesTeam<T extends SalesTeamArgs= {}>(args?: Subset<T, SalesTeamArgs>): Prisma__SalesTeamClient<SalesTeamGetPayload<T> | Null>;

    Country<T extends CountryArgs= {}>(args?: Subset<T, CountryArgs>): Prisma__CountryClient<CountryGetPayload<T> | Null>;

    State<T extends StateArgs= {}>(args?: Subset<T, StateArgs>): Prisma__StateClient<StateGetPayload<T> | Null>;

    City<T extends CityArgs= {}>(args?: Subset<T, CityArgs>): Prisma__CityClient<CityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SalesTeamAddress base type for findUnique actions
   */
  export type SalesTeamAddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    /**
     * Filter, which SalesTeamAddress to fetch.
     */
    where: SalesTeamAddressWhereUniqueInput
  }

  /**
   * SalesTeamAddress findUnique
   */
  export interface SalesTeamAddressFindUniqueArgs extends SalesTeamAddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SalesTeamAddress findUniqueOrThrow
   */
  export type SalesTeamAddressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    /**
     * Filter, which SalesTeamAddress to fetch.
     */
    where: SalesTeamAddressWhereUniqueInput
  }


  /**
   * SalesTeamAddress base type for findFirst actions
   */
  export type SalesTeamAddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    /**
     * Filter, which SalesTeamAddress to fetch.
     */
    where?: SalesTeamAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamAddresses to fetch.
     */
    orderBy?: Enumerable<SalesTeamAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesTeamAddresses.
     */
    cursor?: SalesTeamAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesTeamAddresses.
     */
    distinct?: Enumerable<SalesTeamAddressScalarFieldEnum>
  }

  /**
   * SalesTeamAddress findFirst
   */
  export interface SalesTeamAddressFindFirstArgs extends SalesTeamAddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SalesTeamAddress findFirstOrThrow
   */
  export type SalesTeamAddressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    /**
     * Filter, which SalesTeamAddress to fetch.
     */
    where?: SalesTeamAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamAddresses to fetch.
     */
    orderBy?: Enumerable<SalesTeamAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesTeamAddresses.
     */
    cursor?: SalesTeamAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesTeamAddresses.
     */
    distinct?: Enumerable<SalesTeamAddressScalarFieldEnum>
  }


  /**
   * SalesTeamAddress findMany
   */
  export type SalesTeamAddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    /**
     * Filter, which SalesTeamAddresses to fetch.
     */
    where?: SalesTeamAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamAddresses to fetch.
     */
    orderBy?: Enumerable<SalesTeamAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesTeamAddresses.
     */
    cursor?: SalesTeamAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamAddresses.
     */
    skip?: number
    distinct?: Enumerable<SalesTeamAddressScalarFieldEnum>
  }


  /**
   * SalesTeamAddress create
   */
  export type SalesTeamAddressCreateArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    /**
     * The data needed to create a SalesTeamAddress.
     */
    data: XOR<SalesTeamAddressCreateInput, SalesTeamAddressUncheckedCreateInput>
  }


  /**
   * SalesTeamAddress createMany
   */
  export type SalesTeamAddressCreateManyArgs = {
    /**
     * The data used to create many SalesTeamAddresses.
     */
    data: Enumerable<SalesTeamAddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SalesTeamAddress update
   */
  export type SalesTeamAddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    /**
     * The data needed to update a SalesTeamAddress.
     */
    data: XOR<SalesTeamAddressUpdateInput, SalesTeamAddressUncheckedUpdateInput>
    /**
     * Choose, which SalesTeamAddress to update.
     */
    where: SalesTeamAddressWhereUniqueInput
  }


  /**
   * SalesTeamAddress updateMany
   */
  export type SalesTeamAddressUpdateManyArgs = {
    /**
     * The data used to update SalesTeamAddresses.
     */
    data: XOR<SalesTeamAddressUpdateManyMutationInput, SalesTeamAddressUncheckedUpdateManyInput>
    /**
     * Filter which SalesTeamAddresses to update
     */
    where?: SalesTeamAddressWhereInput
  }


  /**
   * SalesTeamAddress upsert
   */
  export type SalesTeamAddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    /**
     * The filter to search for the SalesTeamAddress to update in case it exists.
     */
    where: SalesTeamAddressWhereUniqueInput
    /**
     * In case the SalesTeamAddress found by the `where` argument doesn't exist, create a new SalesTeamAddress with this data.
     */
    create: XOR<SalesTeamAddressCreateInput, SalesTeamAddressUncheckedCreateInput>
    /**
     * In case the SalesTeamAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesTeamAddressUpdateInput, SalesTeamAddressUncheckedUpdateInput>
  }


  /**
   * SalesTeamAddress delete
   */
  export type SalesTeamAddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
    /**
     * Filter which SalesTeamAddress to delete.
     */
    where: SalesTeamAddressWhereUniqueInput
  }


  /**
   * SalesTeamAddress deleteMany
   */
  export type SalesTeamAddressDeleteManyArgs = {
    /**
     * Filter which SalesTeamAddresses to delete
     */
    where?: SalesTeamAddressWhereInput
  }


  /**
   * SalesTeamAddress without action
   */
  export type SalesTeamAddressArgs = {
    /**
     * Select specific fields to fetch from the SalesTeamAddress
     */
    select?: SalesTeamAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesTeamAddressInclude | null
  }



  /**
   * Model SchoolBoard
   */


  export type AggregateSchoolBoard = {
    _count: SchoolBoardCountAggregateOutputType | null
    _min: SchoolBoardMinAggregateOutputType | null
    _max: SchoolBoardMaxAggregateOutputType | null
  }

  export type SchoolBoardMinAggregateOutputType = {
    id: string | null
    boardname: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolBoardMaxAggregateOutputType = {
    id: string | null
    boardname: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolBoardCountAggregateOutputType = {
    id: number
    boardname: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolBoardMinAggregateInputType = {
    id?: true
    boardname?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SchoolBoardMaxAggregateInputType = {
    id?: true
    boardname?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SchoolBoardCountAggregateInputType = {
    id?: true
    boardname?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolBoardAggregateArgs = {
    /**
     * Filter which SchoolBoard to aggregate.
     */
    where?: SchoolBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolBoards to fetch.
     */
    orderBy?: Enumerable<SchoolBoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolBoards
    **/
    _count?: true | SchoolBoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolBoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolBoardMaxAggregateInputType
  }

  export type GetSchoolBoardAggregateType<T extends SchoolBoardAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolBoard[P]>
      : GetScalarType<T[P], AggregateSchoolBoard[P]>
  }




  export type SchoolBoardGroupByArgs = {
    where?: SchoolBoardWhereInput
    orderBy?: Enumerable<SchoolBoardOrderByWithAggregationInput>
    by: SchoolBoardScalarFieldEnum[]
    having?: SchoolBoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolBoardCountAggregateInputType | true
    _min?: SchoolBoardMinAggregateInputType
    _max?: SchoolBoardMaxAggregateInputType
  }


  export type SchoolBoardGroupByOutputType = {
    id: string
    boardname: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: SchoolBoardCountAggregateOutputType | null
    _min: SchoolBoardMinAggregateOutputType | null
    _max: SchoolBoardMaxAggregateOutputType | null
  }

  type GetSchoolBoardGroupByPayload<T extends SchoolBoardGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SchoolBoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolBoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolBoardGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolBoardGroupByOutputType[P]>
        }
      >
    >


  export type SchoolBoardSelect = {
    id?: boolean
    boardname?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
    schoolMaster?: boolean | SchoolBoard$schoolMasterArgs
    _count?: boolean | SchoolBoardCountOutputTypeArgs
  }


  export type SchoolBoardInclude = {
    schoolMaster?: boolean | SchoolBoard$schoolMasterArgs
    _count?: boolean | SchoolBoardCountOutputTypeArgs
  }

  export type SchoolBoardGetPayload<S extends boolean | null | undefined | SchoolBoardArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SchoolBoard :
    S extends undefined ? never :
    S extends { include: any } & (SchoolBoardArgs | SchoolBoardFindManyArgs)
    ? SchoolBoard  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'schoolMaster' ? Array < schoolMasterGetPayload<S['include'][P]>>  :
        P extends '_count' ? SchoolBoardCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SchoolBoardArgs | SchoolBoardFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'schoolMaster' ? Array < schoolMasterGetPayload<S['select'][P]>>  :
        P extends '_count' ? SchoolBoardCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SchoolBoard ? SchoolBoard[P] : never
  } 
      : SchoolBoard


  type SchoolBoardCountArgs = 
    Omit<SchoolBoardFindManyArgs, 'select' | 'include'> & {
      select?: SchoolBoardCountAggregateInputType | true
    }

  export interface SchoolBoardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SchoolBoard that matches the filter.
     * @param {SchoolBoardFindUniqueArgs} args - Arguments to find a SchoolBoard
     * @example
     * // Get one SchoolBoard
     * const schoolBoard = await prisma.schoolBoard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SchoolBoardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SchoolBoardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SchoolBoard'> extends True ? Prisma__SchoolBoardClient<SchoolBoardGetPayload<T>> : Prisma__SchoolBoardClient<SchoolBoardGetPayload<T> | null, null>

    /**
     * Find one SchoolBoard that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SchoolBoardFindUniqueOrThrowArgs} args - Arguments to find a SchoolBoard
     * @example
     * // Get one SchoolBoard
     * const schoolBoard = await prisma.schoolBoard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SchoolBoardFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SchoolBoardFindUniqueOrThrowArgs>
    ): Prisma__SchoolBoardClient<SchoolBoardGetPayload<T>>

    /**
     * Find the first SchoolBoard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolBoardFindFirstArgs} args - Arguments to find a SchoolBoard
     * @example
     * // Get one SchoolBoard
     * const schoolBoard = await prisma.schoolBoard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SchoolBoardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SchoolBoardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SchoolBoard'> extends True ? Prisma__SchoolBoardClient<SchoolBoardGetPayload<T>> : Prisma__SchoolBoardClient<SchoolBoardGetPayload<T> | null, null>

    /**
     * Find the first SchoolBoard that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolBoardFindFirstOrThrowArgs} args - Arguments to find a SchoolBoard
     * @example
     * // Get one SchoolBoard
     * const schoolBoard = await prisma.schoolBoard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SchoolBoardFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SchoolBoardFindFirstOrThrowArgs>
    ): Prisma__SchoolBoardClient<SchoolBoardGetPayload<T>>

    /**
     * Find zero or more SchoolBoards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolBoardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolBoards
     * const schoolBoards = await prisma.schoolBoard.findMany()
     * 
     * // Get first 10 SchoolBoards
     * const schoolBoards = await prisma.schoolBoard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolBoardWithIdOnly = await prisma.schoolBoard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SchoolBoardFindManyArgs>(
      args?: SelectSubset<T, SchoolBoardFindManyArgs>
    ): PrismaPromise<Array<SchoolBoardGetPayload<T>>>

    /**
     * Create a SchoolBoard.
     * @param {SchoolBoardCreateArgs} args - Arguments to create a SchoolBoard.
     * @example
     * // Create one SchoolBoard
     * const SchoolBoard = await prisma.schoolBoard.create({
     *   data: {
     *     // ... data to create a SchoolBoard
     *   }
     * })
     * 
    **/
    create<T extends SchoolBoardCreateArgs>(
      args: SelectSubset<T, SchoolBoardCreateArgs>
    ): Prisma__SchoolBoardClient<SchoolBoardGetPayload<T>>

    /**
     * Create many SchoolBoards.
     *     @param {SchoolBoardCreateManyArgs} args - Arguments to create many SchoolBoards.
     *     @example
     *     // Create many SchoolBoards
     *     const schoolBoard = await prisma.schoolBoard.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SchoolBoardCreateManyArgs>(
      args?: SelectSubset<T, SchoolBoardCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SchoolBoard.
     * @param {SchoolBoardDeleteArgs} args - Arguments to delete one SchoolBoard.
     * @example
     * // Delete one SchoolBoard
     * const SchoolBoard = await prisma.schoolBoard.delete({
     *   where: {
     *     // ... filter to delete one SchoolBoard
     *   }
     * })
     * 
    **/
    delete<T extends SchoolBoardDeleteArgs>(
      args: SelectSubset<T, SchoolBoardDeleteArgs>
    ): Prisma__SchoolBoardClient<SchoolBoardGetPayload<T>>

    /**
     * Update one SchoolBoard.
     * @param {SchoolBoardUpdateArgs} args - Arguments to update one SchoolBoard.
     * @example
     * // Update one SchoolBoard
     * const schoolBoard = await prisma.schoolBoard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SchoolBoardUpdateArgs>(
      args: SelectSubset<T, SchoolBoardUpdateArgs>
    ): Prisma__SchoolBoardClient<SchoolBoardGetPayload<T>>

    /**
     * Delete zero or more SchoolBoards.
     * @param {SchoolBoardDeleteManyArgs} args - Arguments to filter SchoolBoards to delete.
     * @example
     * // Delete a few SchoolBoards
     * const { count } = await prisma.schoolBoard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SchoolBoardDeleteManyArgs>(
      args?: SelectSubset<T, SchoolBoardDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolBoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolBoards
     * const schoolBoard = await prisma.schoolBoard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SchoolBoardUpdateManyArgs>(
      args: SelectSubset<T, SchoolBoardUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolBoard.
     * @param {SchoolBoardUpsertArgs} args - Arguments to update or create a SchoolBoard.
     * @example
     * // Update or create a SchoolBoard
     * const schoolBoard = await prisma.schoolBoard.upsert({
     *   create: {
     *     // ... data to create a SchoolBoard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolBoard we want to update
     *   }
     * })
    **/
    upsert<T extends SchoolBoardUpsertArgs>(
      args: SelectSubset<T, SchoolBoardUpsertArgs>
    ): Prisma__SchoolBoardClient<SchoolBoardGetPayload<T>>

    /**
     * Count the number of SchoolBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolBoardCountArgs} args - Arguments to filter SchoolBoards to count.
     * @example
     * // Count the number of SchoolBoards
     * const count = await prisma.schoolBoard.count({
     *   where: {
     *     // ... the filter for the SchoolBoards we want to count
     *   }
     * })
    **/
    count<T extends SchoolBoardCountArgs>(
      args?: Subset<T, SchoolBoardCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolBoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolBoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolBoardAggregateArgs>(args: Subset<T, SchoolBoardAggregateArgs>): PrismaPromise<GetSchoolBoardAggregateType<T>>

    /**
     * Group by SchoolBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolBoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolBoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolBoardGroupByArgs['orderBy'] }
        : { orderBy?: SchoolBoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolBoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolBoardGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolBoard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SchoolBoardClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    schoolMaster<T extends SchoolBoard$schoolMasterArgs= {}>(args?: Subset<T, SchoolBoard$schoolMasterArgs>): PrismaPromise<Array<schoolMasterGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SchoolBoard base type for findUnique actions
   */
  export type SchoolBoardFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SchoolBoard
     */
    select?: SchoolBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolBoardInclude | null
    /**
     * Filter, which SchoolBoard to fetch.
     */
    where: SchoolBoardWhereUniqueInput
  }

  /**
   * SchoolBoard findUnique
   */
  export interface SchoolBoardFindUniqueArgs extends SchoolBoardFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SchoolBoard findUniqueOrThrow
   */
  export type SchoolBoardFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SchoolBoard
     */
    select?: SchoolBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolBoardInclude | null
    /**
     * Filter, which SchoolBoard to fetch.
     */
    where: SchoolBoardWhereUniqueInput
  }


  /**
   * SchoolBoard base type for findFirst actions
   */
  export type SchoolBoardFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SchoolBoard
     */
    select?: SchoolBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolBoardInclude | null
    /**
     * Filter, which SchoolBoard to fetch.
     */
    where?: SchoolBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolBoards to fetch.
     */
    orderBy?: Enumerable<SchoolBoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolBoards.
     */
    cursor?: SchoolBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolBoards.
     */
    distinct?: Enumerable<SchoolBoardScalarFieldEnum>
  }

  /**
   * SchoolBoard findFirst
   */
  export interface SchoolBoardFindFirstArgs extends SchoolBoardFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SchoolBoard findFirstOrThrow
   */
  export type SchoolBoardFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SchoolBoard
     */
    select?: SchoolBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolBoardInclude | null
    /**
     * Filter, which SchoolBoard to fetch.
     */
    where?: SchoolBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolBoards to fetch.
     */
    orderBy?: Enumerable<SchoolBoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolBoards.
     */
    cursor?: SchoolBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolBoards.
     */
    distinct?: Enumerable<SchoolBoardScalarFieldEnum>
  }


  /**
   * SchoolBoard findMany
   */
  export type SchoolBoardFindManyArgs = {
    /**
     * Select specific fields to fetch from the SchoolBoard
     */
    select?: SchoolBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolBoardInclude | null
    /**
     * Filter, which SchoolBoards to fetch.
     */
    where?: SchoolBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolBoards to fetch.
     */
    orderBy?: Enumerable<SchoolBoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolBoards.
     */
    cursor?: SchoolBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolBoards.
     */
    skip?: number
    distinct?: Enumerable<SchoolBoardScalarFieldEnum>
  }


  /**
   * SchoolBoard create
   */
  export type SchoolBoardCreateArgs = {
    /**
     * Select specific fields to fetch from the SchoolBoard
     */
    select?: SchoolBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolBoardInclude | null
    /**
     * The data needed to create a SchoolBoard.
     */
    data: XOR<SchoolBoardCreateInput, SchoolBoardUncheckedCreateInput>
  }


  /**
   * SchoolBoard createMany
   */
  export type SchoolBoardCreateManyArgs = {
    /**
     * The data used to create many SchoolBoards.
     */
    data: Enumerable<SchoolBoardCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SchoolBoard update
   */
  export type SchoolBoardUpdateArgs = {
    /**
     * Select specific fields to fetch from the SchoolBoard
     */
    select?: SchoolBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolBoardInclude | null
    /**
     * The data needed to update a SchoolBoard.
     */
    data: XOR<SchoolBoardUpdateInput, SchoolBoardUncheckedUpdateInput>
    /**
     * Choose, which SchoolBoard to update.
     */
    where: SchoolBoardWhereUniqueInput
  }


  /**
   * SchoolBoard updateMany
   */
  export type SchoolBoardUpdateManyArgs = {
    /**
     * The data used to update SchoolBoards.
     */
    data: XOR<SchoolBoardUpdateManyMutationInput, SchoolBoardUncheckedUpdateManyInput>
    /**
     * Filter which SchoolBoards to update
     */
    where?: SchoolBoardWhereInput
  }


  /**
   * SchoolBoard upsert
   */
  export type SchoolBoardUpsertArgs = {
    /**
     * Select specific fields to fetch from the SchoolBoard
     */
    select?: SchoolBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolBoardInclude | null
    /**
     * The filter to search for the SchoolBoard to update in case it exists.
     */
    where: SchoolBoardWhereUniqueInput
    /**
     * In case the SchoolBoard found by the `where` argument doesn't exist, create a new SchoolBoard with this data.
     */
    create: XOR<SchoolBoardCreateInput, SchoolBoardUncheckedCreateInput>
    /**
     * In case the SchoolBoard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolBoardUpdateInput, SchoolBoardUncheckedUpdateInput>
  }


  /**
   * SchoolBoard delete
   */
  export type SchoolBoardDeleteArgs = {
    /**
     * Select specific fields to fetch from the SchoolBoard
     */
    select?: SchoolBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolBoardInclude | null
    /**
     * Filter which SchoolBoard to delete.
     */
    where: SchoolBoardWhereUniqueInput
  }


  /**
   * SchoolBoard deleteMany
   */
  export type SchoolBoardDeleteManyArgs = {
    /**
     * Filter which SchoolBoards to delete
     */
    where?: SchoolBoardWhereInput
  }


  /**
   * SchoolBoard.schoolMaster
   */
  export type SchoolBoard$schoolMasterArgs = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
    where?: schoolMasterWhereInput
    orderBy?: Enumerable<schoolMasterOrderByWithRelationInput>
    cursor?: schoolMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SchoolMasterScalarFieldEnum>
  }


  /**
   * SchoolBoard without action
   */
  export type SchoolBoardArgs = {
    /**
     * Select specific fields to fetch from the SchoolBoard
     */
    select?: SchoolBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolBoardInclude | null
  }



  /**
   * Model schoolType
   */


  export type AggregateSchoolType = {
    _count: SchoolTypeCountAggregateOutputType | null
    _min: SchoolTypeMinAggregateOutputType | null
    _max: SchoolTypeMaxAggregateOutputType | null
  }

  export type SchoolTypeMinAggregateOutputType = {
    id: string | null
    schoolType: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolTypeMaxAggregateOutputType = {
    id: string | null
    schoolType: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolTypeCountAggregateOutputType = {
    id: number
    schoolType: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolTypeMinAggregateInputType = {
    id?: true
    schoolType?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SchoolTypeMaxAggregateInputType = {
    id?: true
    schoolType?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SchoolTypeCountAggregateInputType = {
    id?: true
    schoolType?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolTypeAggregateArgs = {
    /**
     * Filter which schoolType to aggregate.
     */
    where?: schoolTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schoolTypes to fetch.
     */
    orderBy?: Enumerable<schoolTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: schoolTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schoolTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schoolTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned schoolTypes
    **/
    _count?: true | SchoolTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolTypeMaxAggregateInputType
  }

  export type GetSchoolTypeAggregateType<T extends SchoolTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolType[P]>
      : GetScalarType<T[P], AggregateSchoolType[P]>
  }




  export type SchoolTypeGroupByArgs = {
    where?: schoolTypeWhereInput
    orderBy?: Enumerable<schoolTypeOrderByWithAggregationInput>
    by: SchoolTypeScalarFieldEnum[]
    having?: schoolTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolTypeCountAggregateInputType | true
    _min?: SchoolTypeMinAggregateInputType
    _max?: SchoolTypeMaxAggregateInputType
  }


  export type SchoolTypeGroupByOutputType = {
    id: string
    schoolType: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: SchoolTypeCountAggregateOutputType | null
    _min: SchoolTypeMinAggregateOutputType | null
    _max: SchoolTypeMaxAggregateOutputType | null
  }

  type GetSchoolTypeGroupByPayload<T extends SchoolTypeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SchoolTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolTypeGroupByOutputType[P]>
        }
      >
    >


  export type schoolTypeSelect = {
    id?: boolean
    schoolType?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
    schoolMaster?: boolean | schoolType$schoolMasterArgs
    _count?: boolean | SchoolTypeCountOutputTypeArgs
  }


  export type schoolTypeInclude = {
    schoolMaster?: boolean | schoolType$schoolMasterArgs
    _count?: boolean | SchoolTypeCountOutputTypeArgs
  }

  export type schoolTypeGetPayload<S extends boolean | null | undefined | schoolTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? schoolType :
    S extends undefined ? never :
    S extends { include: any } & (schoolTypeArgs | schoolTypeFindManyArgs)
    ? schoolType  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'schoolMaster' ? Array < schoolMasterGetPayload<S['include'][P]>>  :
        P extends '_count' ? SchoolTypeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (schoolTypeArgs | schoolTypeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'schoolMaster' ? Array < schoolMasterGetPayload<S['select'][P]>>  :
        P extends '_count' ? SchoolTypeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof schoolType ? schoolType[P] : never
  } 
      : schoolType


  type schoolTypeCountArgs = 
    Omit<schoolTypeFindManyArgs, 'select' | 'include'> & {
      select?: SchoolTypeCountAggregateInputType | true
    }

  export interface schoolTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SchoolType that matches the filter.
     * @param {schoolTypeFindUniqueArgs} args - Arguments to find a SchoolType
     * @example
     * // Get one SchoolType
     * const schoolType = await prisma.schoolType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends schoolTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, schoolTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'schoolType'> extends True ? Prisma__schoolTypeClient<schoolTypeGetPayload<T>> : Prisma__schoolTypeClient<schoolTypeGetPayload<T> | null, null>

    /**
     * Find one SchoolType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {schoolTypeFindUniqueOrThrowArgs} args - Arguments to find a SchoolType
     * @example
     * // Get one SchoolType
     * const schoolType = await prisma.schoolType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends schoolTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, schoolTypeFindUniqueOrThrowArgs>
    ): Prisma__schoolTypeClient<schoolTypeGetPayload<T>>

    /**
     * Find the first SchoolType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolTypeFindFirstArgs} args - Arguments to find a SchoolType
     * @example
     * // Get one SchoolType
     * const schoolType = await prisma.schoolType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends schoolTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, schoolTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'schoolType'> extends True ? Prisma__schoolTypeClient<schoolTypeGetPayload<T>> : Prisma__schoolTypeClient<schoolTypeGetPayload<T> | null, null>

    /**
     * Find the first SchoolType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolTypeFindFirstOrThrowArgs} args - Arguments to find a SchoolType
     * @example
     * // Get one SchoolType
     * const schoolType = await prisma.schoolType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends schoolTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, schoolTypeFindFirstOrThrowArgs>
    ): Prisma__schoolTypeClient<schoolTypeGetPayload<T>>

    /**
     * Find zero or more SchoolTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolTypes
     * const schoolTypes = await prisma.schoolType.findMany()
     * 
     * // Get first 10 SchoolTypes
     * const schoolTypes = await prisma.schoolType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolTypeWithIdOnly = await prisma.schoolType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends schoolTypeFindManyArgs>(
      args?: SelectSubset<T, schoolTypeFindManyArgs>
    ): PrismaPromise<Array<schoolTypeGetPayload<T>>>

    /**
     * Create a SchoolType.
     * @param {schoolTypeCreateArgs} args - Arguments to create a SchoolType.
     * @example
     * // Create one SchoolType
     * const SchoolType = await prisma.schoolType.create({
     *   data: {
     *     // ... data to create a SchoolType
     *   }
     * })
     * 
    **/
    create<T extends schoolTypeCreateArgs>(
      args: SelectSubset<T, schoolTypeCreateArgs>
    ): Prisma__schoolTypeClient<schoolTypeGetPayload<T>>

    /**
     * Create many SchoolTypes.
     *     @param {schoolTypeCreateManyArgs} args - Arguments to create many SchoolTypes.
     *     @example
     *     // Create many SchoolTypes
     *     const schoolType = await prisma.schoolType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends schoolTypeCreateManyArgs>(
      args?: SelectSubset<T, schoolTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SchoolType.
     * @param {schoolTypeDeleteArgs} args - Arguments to delete one SchoolType.
     * @example
     * // Delete one SchoolType
     * const SchoolType = await prisma.schoolType.delete({
     *   where: {
     *     // ... filter to delete one SchoolType
     *   }
     * })
     * 
    **/
    delete<T extends schoolTypeDeleteArgs>(
      args: SelectSubset<T, schoolTypeDeleteArgs>
    ): Prisma__schoolTypeClient<schoolTypeGetPayload<T>>

    /**
     * Update one SchoolType.
     * @param {schoolTypeUpdateArgs} args - Arguments to update one SchoolType.
     * @example
     * // Update one SchoolType
     * const schoolType = await prisma.schoolType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends schoolTypeUpdateArgs>(
      args: SelectSubset<T, schoolTypeUpdateArgs>
    ): Prisma__schoolTypeClient<schoolTypeGetPayload<T>>

    /**
     * Delete zero or more SchoolTypes.
     * @param {schoolTypeDeleteManyArgs} args - Arguments to filter SchoolTypes to delete.
     * @example
     * // Delete a few SchoolTypes
     * const { count } = await prisma.schoolType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends schoolTypeDeleteManyArgs>(
      args?: SelectSubset<T, schoolTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolTypes
     * const schoolType = await prisma.schoolType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends schoolTypeUpdateManyArgs>(
      args: SelectSubset<T, schoolTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolType.
     * @param {schoolTypeUpsertArgs} args - Arguments to update or create a SchoolType.
     * @example
     * // Update or create a SchoolType
     * const schoolType = await prisma.schoolType.upsert({
     *   create: {
     *     // ... data to create a SchoolType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolType we want to update
     *   }
     * })
    **/
    upsert<T extends schoolTypeUpsertArgs>(
      args: SelectSubset<T, schoolTypeUpsertArgs>
    ): Prisma__schoolTypeClient<schoolTypeGetPayload<T>>

    /**
     * Count the number of SchoolTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolTypeCountArgs} args - Arguments to filter SchoolTypes to count.
     * @example
     * // Count the number of SchoolTypes
     * const count = await prisma.schoolType.count({
     *   where: {
     *     // ... the filter for the SchoolTypes we want to count
     *   }
     * })
    **/
    count<T extends schoolTypeCountArgs>(
      args?: Subset<T, schoolTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolTypeAggregateArgs>(args: Subset<T, SchoolTypeAggregateArgs>): PrismaPromise<GetSchoolTypeAggregateType<T>>

    /**
     * Group by SchoolType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolTypeGroupByArgs['orderBy'] }
        : { orderBy?: SchoolTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolTypeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for schoolType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__schoolTypeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    schoolMaster<T extends schoolType$schoolMasterArgs= {}>(args?: Subset<T, schoolType$schoolMasterArgs>): PrismaPromise<Array<schoolMasterGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * schoolType base type for findUnique actions
   */
  export type schoolTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the schoolType
     */
    select?: schoolTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolTypeInclude | null
    /**
     * Filter, which schoolType to fetch.
     */
    where: schoolTypeWhereUniqueInput
  }

  /**
   * schoolType findUnique
   */
  export interface schoolTypeFindUniqueArgs extends schoolTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * schoolType findUniqueOrThrow
   */
  export type schoolTypeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the schoolType
     */
    select?: schoolTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolTypeInclude | null
    /**
     * Filter, which schoolType to fetch.
     */
    where: schoolTypeWhereUniqueInput
  }


  /**
   * schoolType base type for findFirst actions
   */
  export type schoolTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the schoolType
     */
    select?: schoolTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolTypeInclude | null
    /**
     * Filter, which schoolType to fetch.
     */
    where?: schoolTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schoolTypes to fetch.
     */
    orderBy?: Enumerable<schoolTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schoolTypes.
     */
    cursor?: schoolTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schoolTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schoolTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schoolTypes.
     */
    distinct?: Enumerable<SchoolTypeScalarFieldEnum>
  }

  /**
   * schoolType findFirst
   */
  export interface schoolTypeFindFirstArgs extends schoolTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * schoolType findFirstOrThrow
   */
  export type schoolTypeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the schoolType
     */
    select?: schoolTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolTypeInclude | null
    /**
     * Filter, which schoolType to fetch.
     */
    where?: schoolTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schoolTypes to fetch.
     */
    orderBy?: Enumerable<schoolTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schoolTypes.
     */
    cursor?: schoolTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schoolTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schoolTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schoolTypes.
     */
    distinct?: Enumerable<SchoolTypeScalarFieldEnum>
  }


  /**
   * schoolType findMany
   */
  export type schoolTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the schoolType
     */
    select?: schoolTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolTypeInclude | null
    /**
     * Filter, which schoolTypes to fetch.
     */
    where?: schoolTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schoolTypes to fetch.
     */
    orderBy?: Enumerable<schoolTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing schoolTypes.
     */
    cursor?: schoolTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schoolTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schoolTypes.
     */
    skip?: number
    distinct?: Enumerable<SchoolTypeScalarFieldEnum>
  }


  /**
   * schoolType create
   */
  export type schoolTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the schoolType
     */
    select?: schoolTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolTypeInclude | null
    /**
     * The data needed to create a schoolType.
     */
    data: XOR<schoolTypeCreateInput, schoolTypeUncheckedCreateInput>
  }


  /**
   * schoolType createMany
   */
  export type schoolTypeCreateManyArgs = {
    /**
     * The data used to create many schoolTypes.
     */
    data: Enumerable<schoolTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * schoolType update
   */
  export type schoolTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the schoolType
     */
    select?: schoolTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolTypeInclude | null
    /**
     * The data needed to update a schoolType.
     */
    data: XOR<schoolTypeUpdateInput, schoolTypeUncheckedUpdateInput>
    /**
     * Choose, which schoolType to update.
     */
    where: schoolTypeWhereUniqueInput
  }


  /**
   * schoolType updateMany
   */
  export type schoolTypeUpdateManyArgs = {
    /**
     * The data used to update schoolTypes.
     */
    data: XOR<schoolTypeUpdateManyMutationInput, schoolTypeUncheckedUpdateManyInput>
    /**
     * Filter which schoolTypes to update
     */
    where?: schoolTypeWhereInput
  }


  /**
   * schoolType upsert
   */
  export type schoolTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the schoolType
     */
    select?: schoolTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolTypeInclude | null
    /**
     * The filter to search for the schoolType to update in case it exists.
     */
    where: schoolTypeWhereUniqueInput
    /**
     * In case the schoolType found by the `where` argument doesn't exist, create a new schoolType with this data.
     */
    create: XOR<schoolTypeCreateInput, schoolTypeUncheckedCreateInput>
    /**
     * In case the schoolType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<schoolTypeUpdateInput, schoolTypeUncheckedUpdateInput>
  }


  /**
   * schoolType delete
   */
  export type schoolTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the schoolType
     */
    select?: schoolTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolTypeInclude | null
    /**
     * Filter which schoolType to delete.
     */
    where: schoolTypeWhereUniqueInput
  }


  /**
   * schoolType deleteMany
   */
  export type schoolTypeDeleteManyArgs = {
    /**
     * Filter which schoolTypes to delete
     */
    where?: schoolTypeWhereInput
  }


  /**
   * schoolType.schoolMaster
   */
  export type schoolType$schoolMasterArgs = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
    where?: schoolMasterWhereInput
    orderBy?: Enumerable<schoolMasterOrderByWithRelationInput>
    cursor?: schoolMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SchoolMasterScalarFieldEnum>
  }


  /**
   * schoolType without action
   */
  export type schoolTypeArgs = {
    /**
     * Select specific fields to fetch from the schoolType
     */
    select?: schoolTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolTypeInclude | null
  }



  /**
   * Model schoolMaster
   */


  export type AggregateSchoolMaster = {
    _count: SchoolMasterCountAggregateOutputType | null
    _min: SchoolMasterMinAggregateOutputType | null
    _max: SchoolMasterMaxAggregateOutputType | null
  }

  export type SchoolMasterMinAggregateOutputType = {
    id: string | null
    name: string | null
    afflicationCode: string | null
    fkSchoolType: string | null
    fkSchoolBoard: string | null
    fkSalesTeamId: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMasterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    afflicationCode: string | null
    fkSchoolType: string | null
    fkSchoolBoard: string | null
    fkSalesTeamId: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMasterCountAggregateOutputType = {
    id: number
    name: number
    afflicationCode: number
    fkSchoolType: number
    fkSchoolBoard: number
    fkSalesTeamId: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolMasterMinAggregateInputType = {
    id?: true
    name?: true
    afflicationCode?: true
    fkSchoolType?: true
    fkSchoolBoard?: true
    fkSalesTeamId?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SchoolMasterMaxAggregateInputType = {
    id?: true
    name?: true
    afflicationCode?: true
    fkSchoolType?: true
    fkSchoolBoard?: true
    fkSalesTeamId?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SchoolMasterCountAggregateInputType = {
    id?: true
    name?: true
    afflicationCode?: true
    fkSchoolType?: true
    fkSchoolBoard?: true
    fkSalesTeamId?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolMasterAggregateArgs = {
    /**
     * Filter which schoolMaster to aggregate.
     */
    where?: schoolMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schoolMasters to fetch.
     */
    orderBy?: Enumerable<schoolMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: schoolMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schoolMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schoolMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned schoolMasters
    **/
    _count?: true | SchoolMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMasterMaxAggregateInputType
  }

  export type GetSchoolMasterAggregateType<T extends SchoolMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolMaster[P]>
      : GetScalarType<T[P], AggregateSchoolMaster[P]>
  }




  export type SchoolMasterGroupByArgs = {
    where?: schoolMasterWhereInput
    orderBy?: Enumerable<schoolMasterOrderByWithAggregationInput>
    by: SchoolMasterScalarFieldEnum[]
    having?: schoolMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolMasterCountAggregateInputType | true
    _min?: SchoolMasterMinAggregateInputType
    _max?: SchoolMasterMaxAggregateInputType
  }


  export type SchoolMasterGroupByOutputType = {
    id: string
    name: string
    afflicationCode: string
    fkSchoolType: string
    fkSchoolBoard: string
    fkSalesTeamId: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: SchoolMasterCountAggregateOutputType | null
    _min: SchoolMasterMinAggregateOutputType | null
    _max: SchoolMasterMaxAggregateOutputType | null
  }

  type GetSchoolMasterGroupByPayload<T extends SchoolMasterGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SchoolMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolMasterGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolMasterGroupByOutputType[P]>
        }
      >
    >


  export type schoolMasterSelect = {
    id?: boolean
    name?: boolean
    afflicationCode?: boolean
    schoolType?: boolean | schoolTypeArgs
    fkSchoolType?: boolean
    schoolBoard?: boolean | SchoolBoardArgs
    fkSchoolBoard?: boolean
    salesTeam?: boolean | SalesTeamArgs
    fkSalesTeamId?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
    SchoolMasterAddress?: boolean | schoolMaster$SchoolMasterAddressArgs
    _count?: boolean | SchoolMasterCountOutputTypeArgs
  }


  export type schoolMasterInclude = {
    schoolType?: boolean | schoolTypeArgs
    schoolBoard?: boolean | SchoolBoardArgs
    salesTeam?: boolean | SalesTeamArgs
    SchoolMasterAddress?: boolean | schoolMaster$SchoolMasterAddressArgs
    _count?: boolean | SchoolMasterCountOutputTypeArgs
  }

  export type schoolMasterGetPayload<S extends boolean | null | undefined | schoolMasterArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? schoolMaster :
    S extends undefined ? never :
    S extends { include: any } & (schoolMasterArgs | schoolMasterFindManyArgs)
    ? schoolMaster  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'schoolType' ? schoolTypeGetPayload<S['include'][P]> :
        P extends 'schoolBoard' ? SchoolBoardGetPayload<S['include'][P]> :
        P extends 'salesTeam' ? SalesTeamGetPayload<S['include'][P]> :
        P extends 'SchoolMasterAddress' ? Array < SchoolMasterAddressGetPayload<S['include'][P]>>  :
        P extends '_count' ? SchoolMasterCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (schoolMasterArgs | schoolMasterFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'schoolType' ? schoolTypeGetPayload<S['select'][P]> :
        P extends 'schoolBoard' ? SchoolBoardGetPayload<S['select'][P]> :
        P extends 'salesTeam' ? SalesTeamGetPayload<S['select'][P]> :
        P extends 'SchoolMasterAddress' ? Array < SchoolMasterAddressGetPayload<S['select'][P]>>  :
        P extends '_count' ? SchoolMasterCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof schoolMaster ? schoolMaster[P] : never
  } 
      : schoolMaster


  type schoolMasterCountArgs = 
    Omit<schoolMasterFindManyArgs, 'select' | 'include'> & {
      select?: SchoolMasterCountAggregateInputType | true
    }

  export interface schoolMasterDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SchoolMaster that matches the filter.
     * @param {schoolMasterFindUniqueArgs} args - Arguments to find a SchoolMaster
     * @example
     * // Get one SchoolMaster
     * const schoolMaster = await prisma.schoolMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends schoolMasterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, schoolMasterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'schoolMaster'> extends True ? Prisma__schoolMasterClient<schoolMasterGetPayload<T>> : Prisma__schoolMasterClient<schoolMasterGetPayload<T> | null, null>

    /**
     * Find one SchoolMaster that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {schoolMasterFindUniqueOrThrowArgs} args - Arguments to find a SchoolMaster
     * @example
     * // Get one SchoolMaster
     * const schoolMaster = await prisma.schoolMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends schoolMasterFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, schoolMasterFindUniqueOrThrowArgs>
    ): Prisma__schoolMasterClient<schoolMasterGetPayload<T>>

    /**
     * Find the first SchoolMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolMasterFindFirstArgs} args - Arguments to find a SchoolMaster
     * @example
     * // Get one SchoolMaster
     * const schoolMaster = await prisma.schoolMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends schoolMasterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, schoolMasterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'schoolMaster'> extends True ? Prisma__schoolMasterClient<schoolMasterGetPayload<T>> : Prisma__schoolMasterClient<schoolMasterGetPayload<T> | null, null>

    /**
     * Find the first SchoolMaster that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolMasterFindFirstOrThrowArgs} args - Arguments to find a SchoolMaster
     * @example
     * // Get one SchoolMaster
     * const schoolMaster = await prisma.schoolMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends schoolMasterFindFirstOrThrowArgs>(
      args?: SelectSubset<T, schoolMasterFindFirstOrThrowArgs>
    ): Prisma__schoolMasterClient<schoolMasterGetPayload<T>>

    /**
     * Find zero or more SchoolMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolMasterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolMasters
     * const schoolMasters = await prisma.schoolMaster.findMany()
     * 
     * // Get first 10 SchoolMasters
     * const schoolMasters = await prisma.schoolMaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolMasterWithIdOnly = await prisma.schoolMaster.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends schoolMasterFindManyArgs>(
      args?: SelectSubset<T, schoolMasterFindManyArgs>
    ): PrismaPromise<Array<schoolMasterGetPayload<T>>>

    /**
     * Create a SchoolMaster.
     * @param {schoolMasterCreateArgs} args - Arguments to create a SchoolMaster.
     * @example
     * // Create one SchoolMaster
     * const SchoolMaster = await prisma.schoolMaster.create({
     *   data: {
     *     // ... data to create a SchoolMaster
     *   }
     * })
     * 
    **/
    create<T extends schoolMasterCreateArgs>(
      args: SelectSubset<T, schoolMasterCreateArgs>
    ): Prisma__schoolMasterClient<schoolMasterGetPayload<T>>

    /**
     * Create many SchoolMasters.
     *     @param {schoolMasterCreateManyArgs} args - Arguments to create many SchoolMasters.
     *     @example
     *     // Create many SchoolMasters
     *     const schoolMaster = await prisma.schoolMaster.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends schoolMasterCreateManyArgs>(
      args?: SelectSubset<T, schoolMasterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SchoolMaster.
     * @param {schoolMasterDeleteArgs} args - Arguments to delete one SchoolMaster.
     * @example
     * // Delete one SchoolMaster
     * const SchoolMaster = await prisma.schoolMaster.delete({
     *   where: {
     *     // ... filter to delete one SchoolMaster
     *   }
     * })
     * 
    **/
    delete<T extends schoolMasterDeleteArgs>(
      args: SelectSubset<T, schoolMasterDeleteArgs>
    ): Prisma__schoolMasterClient<schoolMasterGetPayload<T>>

    /**
     * Update one SchoolMaster.
     * @param {schoolMasterUpdateArgs} args - Arguments to update one SchoolMaster.
     * @example
     * // Update one SchoolMaster
     * const schoolMaster = await prisma.schoolMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends schoolMasterUpdateArgs>(
      args: SelectSubset<T, schoolMasterUpdateArgs>
    ): Prisma__schoolMasterClient<schoolMasterGetPayload<T>>

    /**
     * Delete zero or more SchoolMasters.
     * @param {schoolMasterDeleteManyArgs} args - Arguments to filter SchoolMasters to delete.
     * @example
     * // Delete a few SchoolMasters
     * const { count } = await prisma.schoolMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends schoolMasterDeleteManyArgs>(
      args?: SelectSubset<T, schoolMasterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolMasters
     * const schoolMaster = await prisma.schoolMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends schoolMasterUpdateManyArgs>(
      args: SelectSubset<T, schoolMasterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolMaster.
     * @param {schoolMasterUpsertArgs} args - Arguments to update or create a SchoolMaster.
     * @example
     * // Update or create a SchoolMaster
     * const schoolMaster = await prisma.schoolMaster.upsert({
     *   create: {
     *     // ... data to create a SchoolMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolMaster we want to update
     *   }
     * })
    **/
    upsert<T extends schoolMasterUpsertArgs>(
      args: SelectSubset<T, schoolMasterUpsertArgs>
    ): Prisma__schoolMasterClient<schoolMasterGetPayload<T>>

    /**
     * Count the number of SchoolMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolMasterCountArgs} args - Arguments to filter SchoolMasters to count.
     * @example
     * // Count the number of SchoolMasters
     * const count = await prisma.schoolMaster.count({
     *   where: {
     *     // ... the filter for the SchoolMasters we want to count
     *   }
     * })
    **/
    count<T extends schoolMasterCountArgs>(
      args?: Subset<T, schoolMasterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolMasterAggregateArgs>(args: Subset<T, SchoolMasterAggregateArgs>): PrismaPromise<GetSchoolMasterAggregateType<T>>

    /**
     * Group by SchoolMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolMasterGroupByArgs['orderBy'] }
        : { orderBy?: SchoolMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolMasterGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for schoolMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__schoolMasterClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    schoolType<T extends schoolTypeArgs= {}>(args?: Subset<T, schoolTypeArgs>): Prisma__schoolTypeClient<schoolTypeGetPayload<T> | Null>;

    schoolBoard<T extends SchoolBoardArgs= {}>(args?: Subset<T, SchoolBoardArgs>): Prisma__SchoolBoardClient<SchoolBoardGetPayload<T> | Null>;

    salesTeam<T extends SalesTeamArgs= {}>(args?: Subset<T, SalesTeamArgs>): Prisma__SalesTeamClient<SalesTeamGetPayload<T> | Null>;

    SchoolMasterAddress<T extends schoolMaster$SchoolMasterAddressArgs= {}>(args?: Subset<T, schoolMaster$SchoolMasterAddressArgs>): PrismaPromise<Array<SchoolMasterAddressGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * schoolMaster base type for findUnique actions
   */
  export type schoolMasterFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
    /**
     * Filter, which schoolMaster to fetch.
     */
    where: schoolMasterWhereUniqueInput
  }

  /**
   * schoolMaster findUnique
   */
  export interface schoolMasterFindUniqueArgs extends schoolMasterFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * schoolMaster findUniqueOrThrow
   */
  export type schoolMasterFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
    /**
     * Filter, which schoolMaster to fetch.
     */
    where: schoolMasterWhereUniqueInput
  }


  /**
   * schoolMaster base type for findFirst actions
   */
  export type schoolMasterFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
    /**
     * Filter, which schoolMaster to fetch.
     */
    where?: schoolMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schoolMasters to fetch.
     */
    orderBy?: Enumerable<schoolMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schoolMasters.
     */
    cursor?: schoolMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schoolMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schoolMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schoolMasters.
     */
    distinct?: Enumerable<SchoolMasterScalarFieldEnum>
  }

  /**
   * schoolMaster findFirst
   */
  export interface schoolMasterFindFirstArgs extends schoolMasterFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * schoolMaster findFirstOrThrow
   */
  export type schoolMasterFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
    /**
     * Filter, which schoolMaster to fetch.
     */
    where?: schoolMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schoolMasters to fetch.
     */
    orderBy?: Enumerable<schoolMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schoolMasters.
     */
    cursor?: schoolMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schoolMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schoolMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schoolMasters.
     */
    distinct?: Enumerable<SchoolMasterScalarFieldEnum>
  }


  /**
   * schoolMaster findMany
   */
  export type schoolMasterFindManyArgs = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
    /**
     * Filter, which schoolMasters to fetch.
     */
    where?: schoolMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schoolMasters to fetch.
     */
    orderBy?: Enumerable<schoolMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing schoolMasters.
     */
    cursor?: schoolMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schoolMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schoolMasters.
     */
    skip?: number
    distinct?: Enumerable<SchoolMasterScalarFieldEnum>
  }


  /**
   * schoolMaster create
   */
  export type schoolMasterCreateArgs = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
    /**
     * The data needed to create a schoolMaster.
     */
    data: XOR<schoolMasterCreateInput, schoolMasterUncheckedCreateInput>
  }


  /**
   * schoolMaster createMany
   */
  export type schoolMasterCreateManyArgs = {
    /**
     * The data used to create many schoolMasters.
     */
    data: Enumerable<schoolMasterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * schoolMaster update
   */
  export type schoolMasterUpdateArgs = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
    /**
     * The data needed to update a schoolMaster.
     */
    data: XOR<schoolMasterUpdateInput, schoolMasterUncheckedUpdateInput>
    /**
     * Choose, which schoolMaster to update.
     */
    where: schoolMasterWhereUniqueInput
  }


  /**
   * schoolMaster updateMany
   */
  export type schoolMasterUpdateManyArgs = {
    /**
     * The data used to update schoolMasters.
     */
    data: XOR<schoolMasterUpdateManyMutationInput, schoolMasterUncheckedUpdateManyInput>
    /**
     * Filter which schoolMasters to update
     */
    where?: schoolMasterWhereInput
  }


  /**
   * schoolMaster upsert
   */
  export type schoolMasterUpsertArgs = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
    /**
     * The filter to search for the schoolMaster to update in case it exists.
     */
    where: schoolMasterWhereUniqueInput
    /**
     * In case the schoolMaster found by the `where` argument doesn't exist, create a new schoolMaster with this data.
     */
    create: XOR<schoolMasterCreateInput, schoolMasterUncheckedCreateInput>
    /**
     * In case the schoolMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<schoolMasterUpdateInput, schoolMasterUncheckedUpdateInput>
  }


  /**
   * schoolMaster delete
   */
  export type schoolMasterDeleteArgs = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
    /**
     * Filter which schoolMaster to delete.
     */
    where: schoolMasterWhereUniqueInput
  }


  /**
   * schoolMaster deleteMany
   */
  export type schoolMasterDeleteManyArgs = {
    /**
     * Filter which schoolMasters to delete
     */
    where?: schoolMasterWhereInput
  }


  /**
   * schoolMaster.SchoolMasterAddress
   */
  export type schoolMaster$SchoolMasterAddressArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    where?: SchoolMasterAddressWhereInput
    orderBy?: Enumerable<SchoolMasterAddressOrderByWithRelationInput>
    cursor?: SchoolMasterAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SchoolMasterAddressScalarFieldEnum>
  }


  /**
   * schoolMaster without action
   */
  export type schoolMasterArgs = {
    /**
     * Select specific fields to fetch from the schoolMaster
     */
    select?: schoolMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolMasterInclude | null
  }



  /**
   * Model SchoolMasterAddress
   */


  export type AggregateSchoolMasterAddress = {
    _count: SchoolMasterAddressCountAggregateOutputType | null
    _min: SchoolMasterAddressMinAggregateOutputType | null
    _max: SchoolMasterAddressMaxAggregateOutputType | null
  }

  export type SchoolMasterAddressMinAggregateOutputType = {
    id: string | null
    fkSchoolId: string | null
    fkCountryId: string | null
    fkStateId: string | null
    fkCityId: string | null
    Address: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMasterAddressMaxAggregateOutputType = {
    id: string | null
    fkSchoolId: string | null
    fkCountryId: string | null
    fkStateId: string | null
    fkCityId: string | null
    Address: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMasterAddressCountAggregateOutputType = {
    id: number
    fkSchoolId: number
    fkCountryId: number
    fkStateId: number
    fkCityId: number
    Address: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolMasterAddressMinAggregateInputType = {
    id?: true
    fkSchoolId?: true
    fkCountryId?: true
    fkStateId?: true
    fkCityId?: true
    Address?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SchoolMasterAddressMaxAggregateInputType = {
    id?: true
    fkSchoolId?: true
    fkCountryId?: true
    fkStateId?: true
    fkCityId?: true
    Address?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SchoolMasterAddressCountAggregateInputType = {
    id?: true
    fkSchoolId?: true
    fkCountryId?: true
    fkStateId?: true
    fkCityId?: true
    Address?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolMasterAddressAggregateArgs = {
    /**
     * Filter which SchoolMasterAddress to aggregate.
     */
    where?: SchoolMasterAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolMasterAddresses to fetch.
     */
    orderBy?: Enumerable<SchoolMasterAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolMasterAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolMasterAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolMasterAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolMasterAddresses
    **/
    _count?: true | SchoolMasterAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMasterAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMasterAddressMaxAggregateInputType
  }

  export type GetSchoolMasterAddressAggregateType<T extends SchoolMasterAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolMasterAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolMasterAddress[P]>
      : GetScalarType<T[P], AggregateSchoolMasterAddress[P]>
  }




  export type SchoolMasterAddressGroupByArgs = {
    where?: SchoolMasterAddressWhereInput
    orderBy?: Enumerable<SchoolMasterAddressOrderByWithAggregationInput>
    by: SchoolMasterAddressScalarFieldEnum[]
    having?: SchoolMasterAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolMasterAddressCountAggregateInputType | true
    _min?: SchoolMasterAddressMinAggregateInputType
    _max?: SchoolMasterAddressMaxAggregateInputType
  }


  export type SchoolMasterAddressGroupByOutputType = {
    id: string
    fkSchoolId: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: SchoolMasterAddressCountAggregateOutputType | null
    _min: SchoolMasterAddressMinAggregateOutputType | null
    _max: SchoolMasterAddressMaxAggregateOutputType | null
  }

  type GetSchoolMasterAddressGroupByPayload<T extends SchoolMasterAddressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SchoolMasterAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolMasterAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolMasterAddressGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolMasterAddressGroupByOutputType[P]>
        }
      >
    >


  export type SchoolMasterAddressSelect = {
    id?: boolean
    schoolId?: boolean | schoolMasterArgs
    fkSchoolId?: boolean
    Country?: boolean | CountryArgs
    fkCountryId?: boolean
    State?: boolean | StateArgs
    fkStateId?: boolean
    City?: boolean | CityArgs
    fkCityId?: boolean
    Address?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type SchoolMasterAddressInclude = {
    schoolId?: boolean | schoolMasterArgs
    Country?: boolean | CountryArgs
    State?: boolean | StateArgs
    City?: boolean | CityArgs
  }

  export type SchoolMasterAddressGetPayload<S extends boolean | null | undefined | SchoolMasterAddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SchoolMasterAddress :
    S extends undefined ? never :
    S extends { include: any } & (SchoolMasterAddressArgs | SchoolMasterAddressFindManyArgs)
    ? SchoolMasterAddress  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'schoolId' ? schoolMasterGetPayload<S['include'][P]> :
        P extends 'Country' ? CountryGetPayload<S['include'][P]> :
        P extends 'State' ? StateGetPayload<S['include'][P]> :
        P extends 'City' ? CityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SchoolMasterAddressArgs | SchoolMasterAddressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'schoolId' ? schoolMasterGetPayload<S['select'][P]> :
        P extends 'Country' ? CountryGetPayload<S['select'][P]> :
        P extends 'State' ? StateGetPayload<S['select'][P]> :
        P extends 'City' ? CityGetPayload<S['select'][P]> :  P extends keyof SchoolMasterAddress ? SchoolMasterAddress[P] : never
  } 
      : SchoolMasterAddress


  type SchoolMasterAddressCountArgs = 
    Omit<SchoolMasterAddressFindManyArgs, 'select' | 'include'> & {
      select?: SchoolMasterAddressCountAggregateInputType | true
    }

  export interface SchoolMasterAddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SchoolMasterAddress that matches the filter.
     * @param {SchoolMasterAddressFindUniqueArgs} args - Arguments to find a SchoolMasterAddress
     * @example
     * // Get one SchoolMasterAddress
     * const schoolMasterAddress = await prisma.schoolMasterAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SchoolMasterAddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SchoolMasterAddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SchoolMasterAddress'> extends True ? Prisma__SchoolMasterAddressClient<SchoolMasterAddressGetPayload<T>> : Prisma__SchoolMasterAddressClient<SchoolMasterAddressGetPayload<T> | null, null>

    /**
     * Find one SchoolMasterAddress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SchoolMasterAddressFindUniqueOrThrowArgs} args - Arguments to find a SchoolMasterAddress
     * @example
     * // Get one SchoolMasterAddress
     * const schoolMasterAddress = await prisma.schoolMasterAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SchoolMasterAddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SchoolMasterAddressFindUniqueOrThrowArgs>
    ): Prisma__SchoolMasterAddressClient<SchoolMasterAddressGetPayload<T>>

    /**
     * Find the first SchoolMasterAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolMasterAddressFindFirstArgs} args - Arguments to find a SchoolMasterAddress
     * @example
     * // Get one SchoolMasterAddress
     * const schoolMasterAddress = await prisma.schoolMasterAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SchoolMasterAddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SchoolMasterAddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SchoolMasterAddress'> extends True ? Prisma__SchoolMasterAddressClient<SchoolMasterAddressGetPayload<T>> : Prisma__SchoolMasterAddressClient<SchoolMasterAddressGetPayload<T> | null, null>

    /**
     * Find the first SchoolMasterAddress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolMasterAddressFindFirstOrThrowArgs} args - Arguments to find a SchoolMasterAddress
     * @example
     * // Get one SchoolMasterAddress
     * const schoolMasterAddress = await prisma.schoolMasterAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SchoolMasterAddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SchoolMasterAddressFindFirstOrThrowArgs>
    ): Prisma__SchoolMasterAddressClient<SchoolMasterAddressGetPayload<T>>

    /**
     * Find zero or more SchoolMasterAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolMasterAddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolMasterAddresses
     * const schoolMasterAddresses = await prisma.schoolMasterAddress.findMany()
     * 
     * // Get first 10 SchoolMasterAddresses
     * const schoolMasterAddresses = await prisma.schoolMasterAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolMasterAddressWithIdOnly = await prisma.schoolMasterAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SchoolMasterAddressFindManyArgs>(
      args?: SelectSubset<T, SchoolMasterAddressFindManyArgs>
    ): PrismaPromise<Array<SchoolMasterAddressGetPayload<T>>>

    /**
     * Create a SchoolMasterAddress.
     * @param {SchoolMasterAddressCreateArgs} args - Arguments to create a SchoolMasterAddress.
     * @example
     * // Create one SchoolMasterAddress
     * const SchoolMasterAddress = await prisma.schoolMasterAddress.create({
     *   data: {
     *     // ... data to create a SchoolMasterAddress
     *   }
     * })
     * 
    **/
    create<T extends SchoolMasterAddressCreateArgs>(
      args: SelectSubset<T, SchoolMasterAddressCreateArgs>
    ): Prisma__SchoolMasterAddressClient<SchoolMasterAddressGetPayload<T>>

    /**
     * Create many SchoolMasterAddresses.
     *     @param {SchoolMasterAddressCreateManyArgs} args - Arguments to create many SchoolMasterAddresses.
     *     @example
     *     // Create many SchoolMasterAddresses
     *     const schoolMasterAddress = await prisma.schoolMasterAddress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SchoolMasterAddressCreateManyArgs>(
      args?: SelectSubset<T, SchoolMasterAddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SchoolMasterAddress.
     * @param {SchoolMasterAddressDeleteArgs} args - Arguments to delete one SchoolMasterAddress.
     * @example
     * // Delete one SchoolMasterAddress
     * const SchoolMasterAddress = await prisma.schoolMasterAddress.delete({
     *   where: {
     *     // ... filter to delete one SchoolMasterAddress
     *   }
     * })
     * 
    **/
    delete<T extends SchoolMasterAddressDeleteArgs>(
      args: SelectSubset<T, SchoolMasterAddressDeleteArgs>
    ): Prisma__SchoolMasterAddressClient<SchoolMasterAddressGetPayload<T>>

    /**
     * Update one SchoolMasterAddress.
     * @param {SchoolMasterAddressUpdateArgs} args - Arguments to update one SchoolMasterAddress.
     * @example
     * // Update one SchoolMasterAddress
     * const schoolMasterAddress = await prisma.schoolMasterAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SchoolMasterAddressUpdateArgs>(
      args: SelectSubset<T, SchoolMasterAddressUpdateArgs>
    ): Prisma__SchoolMasterAddressClient<SchoolMasterAddressGetPayload<T>>

    /**
     * Delete zero or more SchoolMasterAddresses.
     * @param {SchoolMasterAddressDeleteManyArgs} args - Arguments to filter SchoolMasterAddresses to delete.
     * @example
     * // Delete a few SchoolMasterAddresses
     * const { count } = await prisma.schoolMasterAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SchoolMasterAddressDeleteManyArgs>(
      args?: SelectSubset<T, SchoolMasterAddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolMasterAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolMasterAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolMasterAddresses
     * const schoolMasterAddress = await prisma.schoolMasterAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SchoolMasterAddressUpdateManyArgs>(
      args: SelectSubset<T, SchoolMasterAddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolMasterAddress.
     * @param {SchoolMasterAddressUpsertArgs} args - Arguments to update or create a SchoolMasterAddress.
     * @example
     * // Update or create a SchoolMasterAddress
     * const schoolMasterAddress = await prisma.schoolMasterAddress.upsert({
     *   create: {
     *     // ... data to create a SchoolMasterAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolMasterAddress we want to update
     *   }
     * })
    **/
    upsert<T extends SchoolMasterAddressUpsertArgs>(
      args: SelectSubset<T, SchoolMasterAddressUpsertArgs>
    ): Prisma__SchoolMasterAddressClient<SchoolMasterAddressGetPayload<T>>

    /**
     * Count the number of SchoolMasterAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolMasterAddressCountArgs} args - Arguments to filter SchoolMasterAddresses to count.
     * @example
     * // Count the number of SchoolMasterAddresses
     * const count = await prisma.schoolMasterAddress.count({
     *   where: {
     *     // ... the filter for the SchoolMasterAddresses we want to count
     *   }
     * })
    **/
    count<T extends SchoolMasterAddressCountArgs>(
      args?: Subset<T, SchoolMasterAddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolMasterAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolMasterAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolMasterAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolMasterAddressAggregateArgs>(args: Subset<T, SchoolMasterAddressAggregateArgs>): PrismaPromise<GetSchoolMasterAddressAggregateType<T>>

    /**
     * Group by SchoolMasterAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolMasterAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolMasterAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolMasterAddressGroupByArgs['orderBy'] }
        : { orderBy?: SchoolMasterAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolMasterAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolMasterAddressGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolMasterAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SchoolMasterAddressClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    schoolId<T extends schoolMasterArgs= {}>(args?: Subset<T, schoolMasterArgs>): Prisma__schoolMasterClient<schoolMasterGetPayload<T> | Null>;

    Country<T extends CountryArgs= {}>(args?: Subset<T, CountryArgs>): Prisma__CountryClient<CountryGetPayload<T> | Null>;

    State<T extends StateArgs= {}>(args?: Subset<T, StateArgs>): Prisma__StateClient<StateGetPayload<T> | Null>;

    City<T extends CityArgs= {}>(args?: Subset<T, CityArgs>): Prisma__CityClient<CityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SchoolMasterAddress base type for findUnique actions
   */
  export type SchoolMasterAddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    /**
     * Filter, which SchoolMasterAddress to fetch.
     */
    where: SchoolMasterAddressWhereUniqueInput
  }

  /**
   * SchoolMasterAddress findUnique
   */
  export interface SchoolMasterAddressFindUniqueArgs extends SchoolMasterAddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SchoolMasterAddress findUniqueOrThrow
   */
  export type SchoolMasterAddressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    /**
     * Filter, which SchoolMasterAddress to fetch.
     */
    where: SchoolMasterAddressWhereUniqueInput
  }


  /**
   * SchoolMasterAddress base type for findFirst actions
   */
  export type SchoolMasterAddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    /**
     * Filter, which SchoolMasterAddress to fetch.
     */
    where?: SchoolMasterAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolMasterAddresses to fetch.
     */
    orderBy?: Enumerable<SchoolMasterAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolMasterAddresses.
     */
    cursor?: SchoolMasterAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolMasterAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolMasterAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolMasterAddresses.
     */
    distinct?: Enumerable<SchoolMasterAddressScalarFieldEnum>
  }

  /**
   * SchoolMasterAddress findFirst
   */
  export interface SchoolMasterAddressFindFirstArgs extends SchoolMasterAddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SchoolMasterAddress findFirstOrThrow
   */
  export type SchoolMasterAddressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    /**
     * Filter, which SchoolMasterAddress to fetch.
     */
    where?: SchoolMasterAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolMasterAddresses to fetch.
     */
    orderBy?: Enumerable<SchoolMasterAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolMasterAddresses.
     */
    cursor?: SchoolMasterAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolMasterAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolMasterAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolMasterAddresses.
     */
    distinct?: Enumerable<SchoolMasterAddressScalarFieldEnum>
  }


  /**
   * SchoolMasterAddress findMany
   */
  export type SchoolMasterAddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    /**
     * Filter, which SchoolMasterAddresses to fetch.
     */
    where?: SchoolMasterAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolMasterAddresses to fetch.
     */
    orderBy?: Enumerable<SchoolMasterAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolMasterAddresses.
     */
    cursor?: SchoolMasterAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolMasterAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolMasterAddresses.
     */
    skip?: number
    distinct?: Enumerable<SchoolMasterAddressScalarFieldEnum>
  }


  /**
   * SchoolMasterAddress create
   */
  export type SchoolMasterAddressCreateArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    /**
     * The data needed to create a SchoolMasterAddress.
     */
    data: XOR<SchoolMasterAddressCreateInput, SchoolMasterAddressUncheckedCreateInput>
  }


  /**
   * SchoolMasterAddress createMany
   */
  export type SchoolMasterAddressCreateManyArgs = {
    /**
     * The data used to create many SchoolMasterAddresses.
     */
    data: Enumerable<SchoolMasterAddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SchoolMasterAddress update
   */
  export type SchoolMasterAddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    /**
     * The data needed to update a SchoolMasterAddress.
     */
    data: XOR<SchoolMasterAddressUpdateInput, SchoolMasterAddressUncheckedUpdateInput>
    /**
     * Choose, which SchoolMasterAddress to update.
     */
    where: SchoolMasterAddressWhereUniqueInput
  }


  /**
   * SchoolMasterAddress updateMany
   */
  export type SchoolMasterAddressUpdateManyArgs = {
    /**
     * The data used to update SchoolMasterAddresses.
     */
    data: XOR<SchoolMasterAddressUpdateManyMutationInput, SchoolMasterAddressUncheckedUpdateManyInput>
    /**
     * Filter which SchoolMasterAddresses to update
     */
    where?: SchoolMasterAddressWhereInput
  }


  /**
   * SchoolMasterAddress upsert
   */
  export type SchoolMasterAddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    /**
     * The filter to search for the SchoolMasterAddress to update in case it exists.
     */
    where: SchoolMasterAddressWhereUniqueInput
    /**
     * In case the SchoolMasterAddress found by the `where` argument doesn't exist, create a new SchoolMasterAddress with this data.
     */
    create: XOR<SchoolMasterAddressCreateInput, SchoolMasterAddressUncheckedCreateInput>
    /**
     * In case the SchoolMasterAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolMasterAddressUpdateInput, SchoolMasterAddressUncheckedUpdateInput>
  }


  /**
   * SchoolMasterAddress delete
   */
  export type SchoolMasterAddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
    /**
     * Filter which SchoolMasterAddress to delete.
     */
    where: SchoolMasterAddressWhereUniqueInput
  }


  /**
   * SchoolMasterAddress deleteMany
   */
  export type SchoolMasterAddressDeleteManyArgs = {
    /**
     * Filter which SchoolMasterAddresses to delete
     */
    where?: SchoolMasterAddressWhereInput
  }


  /**
   * SchoolMasterAddress without action
   */
  export type SchoolMasterAddressArgs = {
    /**
     * Select specific fields to fetch from the SchoolMasterAddress
     */
    select?: SchoolMasterAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolMasterAddressInclude | null
  }



  /**
   * Model Classmaster
   */


  export type AggregateClassmaster = {
    _count: ClassmasterCountAggregateOutputType | null
    _min: ClassmasterMinAggregateOutputType | null
    _max: ClassmasterMaxAggregateOutputType | null
  }

  export type ClassmasterMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type ClassmasterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type ClassmasterCountAggregateOutputType = {
    id: number
    name: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type ClassmasterMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type ClassmasterMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type ClassmasterCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassmasterAggregateArgs = {
    /**
     * Filter which Classmaster to aggregate.
     */
    where?: ClassmasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classmasters to fetch.
     */
    orderBy?: Enumerable<ClassmasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassmasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classmasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classmasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classmasters
    **/
    _count?: true | ClassmasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassmasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassmasterMaxAggregateInputType
  }

  export type GetClassmasterAggregateType<T extends ClassmasterAggregateArgs> = {
        [P in keyof T & keyof AggregateClassmaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassmaster[P]>
      : GetScalarType<T[P], AggregateClassmaster[P]>
  }




  export type ClassmasterGroupByArgs = {
    where?: ClassmasterWhereInput
    orderBy?: Enumerable<ClassmasterOrderByWithAggregationInput>
    by: ClassmasterScalarFieldEnum[]
    having?: ClassmasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassmasterCountAggregateInputType | true
    _min?: ClassmasterMinAggregateInputType
    _max?: ClassmasterMaxAggregateInputType
  }


  export type ClassmasterGroupByOutputType = {
    id: string
    name: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: ClassmasterCountAggregateOutputType | null
    _min: ClassmasterMinAggregateOutputType | null
    _max: ClassmasterMaxAggregateOutputType | null
  }

  type GetClassmasterGroupByPayload<T extends ClassmasterGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClassmasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassmasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassmasterGroupByOutputType[P]>
            : GetScalarType<T[P], ClassmasterGroupByOutputType[P]>
        }
      >
    >


  export type ClassmasterSelect = {
    id?: boolean
    name?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type ClassmasterGetPayload<S extends boolean | null | undefined | ClassmasterArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Classmaster :
    S extends undefined ? never :
    S extends { include: any } & (ClassmasterArgs | ClassmasterFindManyArgs)
    ? Classmaster 
    : S extends { select: any } & (ClassmasterArgs | ClassmasterFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Classmaster ? Classmaster[P] : never
  } 
      : Classmaster


  type ClassmasterCountArgs = 
    Omit<ClassmasterFindManyArgs, 'select' | 'include'> & {
      select?: ClassmasterCountAggregateInputType | true
    }

  export interface ClassmasterDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Classmaster that matches the filter.
     * @param {ClassmasterFindUniqueArgs} args - Arguments to find a Classmaster
     * @example
     * // Get one Classmaster
     * const classmaster = await prisma.classmaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClassmasterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClassmasterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Classmaster'> extends True ? Prisma__ClassmasterClient<ClassmasterGetPayload<T>> : Prisma__ClassmasterClient<ClassmasterGetPayload<T> | null, null>

    /**
     * Find one Classmaster that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClassmasterFindUniqueOrThrowArgs} args - Arguments to find a Classmaster
     * @example
     * // Get one Classmaster
     * const classmaster = await prisma.classmaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClassmasterFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClassmasterFindUniqueOrThrowArgs>
    ): Prisma__ClassmasterClient<ClassmasterGetPayload<T>>

    /**
     * Find the first Classmaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassmasterFindFirstArgs} args - Arguments to find a Classmaster
     * @example
     * // Get one Classmaster
     * const classmaster = await prisma.classmaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClassmasterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClassmasterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Classmaster'> extends True ? Prisma__ClassmasterClient<ClassmasterGetPayload<T>> : Prisma__ClassmasterClient<ClassmasterGetPayload<T> | null, null>

    /**
     * Find the first Classmaster that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassmasterFindFirstOrThrowArgs} args - Arguments to find a Classmaster
     * @example
     * // Get one Classmaster
     * const classmaster = await prisma.classmaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClassmasterFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClassmasterFindFirstOrThrowArgs>
    ): Prisma__ClassmasterClient<ClassmasterGetPayload<T>>

    /**
     * Find zero or more Classmasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassmasterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classmasters
     * const classmasters = await prisma.classmaster.findMany()
     * 
     * // Get first 10 Classmasters
     * const classmasters = await prisma.classmaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classmasterWithIdOnly = await prisma.classmaster.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClassmasterFindManyArgs>(
      args?: SelectSubset<T, ClassmasterFindManyArgs>
    ): PrismaPromise<Array<ClassmasterGetPayload<T>>>

    /**
     * Create a Classmaster.
     * @param {ClassmasterCreateArgs} args - Arguments to create a Classmaster.
     * @example
     * // Create one Classmaster
     * const Classmaster = await prisma.classmaster.create({
     *   data: {
     *     // ... data to create a Classmaster
     *   }
     * })
     * 
    **/
    create<T extends ClassmasterCreateArgs>(
      args: SelectSubset<T, ClassmasterCreateArgs>
    ): Prisma__ClassmasterClient<ClassmasterGetPayload<T>>

    /**
     * Create many Classmasters.
     *     @param {ClassmasterCreateManyArgs} args - Arguments to create many Classmasters.
     *     @example
     *     // Create many Classmasters
     *     const classmaster = await prisma.classmaster.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClassmasterCreateManyArgs>(
      args?: SelectSubset<T, ClassmasterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Classmaster.
     * @param {ClassmasterDeleteArgs} args - Arguments to delete one Classmaster.
     * @example
     * // Delete one Classmaster
     * const Classmaster = await prisma.classmaster.delete({
     *   where: {
     *     // ... filter to delete one Classmaster
     *   }
     * })
     * 
    **/
    delete<T extends ClassmasterDeleteArgs>(
      args: SelectSubset<T, ClassmasterDeleteArgs>
    ): Prisma__ClassmasterClient<ClassmasterGetPayload<T>>

    /**
     * Update one Classmaster.
     * @param {ClassmasterUpdateArgs} args - Arguments to update one Classmaster.
     * @example
     * // Update one Classmaster
     * const classmaster = await prisma.classmaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClassmasterUpdateArgs>(
      args: SelectSubset<T, ClassmasterUpdateArgs>
    ): Prisma__ClassmasterClient<ClassmasterGetPayload<T>>

    /**
     * Delete zero or more Classmasters.
     * @param {ClassmasterDeleteManyArgs} args - Arguments to filter Classmasters to delete.
     * @example
     * // Delete a few Classmasters
     * const { count } = await prisma.classmaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClassmasterDeleteManyArgs>(
      args?: SelectSubset<T, ClassmasterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classmasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassmasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classmasters
     * const classmaster = await prisma.classmaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClassmasterUpdateManyArgs>(
      args: SelectSubset<T, ClassmasterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Classmaster.
     * @param {ClassmasterUpsertArgs} args - Arguments to update or create a Classmaster.
     * @example
     * // Update or create a Classmaster
     * const classmaster = await prisma.classmaster.upsert({
     *   create: {
     *     // ... data to create a Classmaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classmaster we want to update
     *   }
     * })
    **/
    upsert<T extends ClassmasterUpsertArgs>(
      args: SelectSubset<T, ClassmasterUpsertArgs>
    ): Prisma__ClassmasterClient<ClassmasterGetPayload<T>>

    /**
     * Count the number of Classmasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassmasterCountArgs} args - Arguments to filter Classmasters to count.
     * @example
     * // Count the number of Classmasters
     * const count = await prisma.classmaster.count({
     *   where: {
     *     // ... the filter for the Classmasters we want to count
     *   }
     * })
    **/
    count<T extends ClassmasterCountArgs>(
      args?: Subset<T, ClassmasterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassmasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classmaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassmasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassmasterAggregateArgs>(args: Subset<T, ClassmasterAggregateArgs>): PrismaPromise<GetClassmasterAggregateType<T>>

    /**
     * Group by Classmaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassmasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassmasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassmasterGroupByArgs['orderBy'] }
        : { orderBy?: ClassmasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassmasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassmasterGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Classmaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClassmasterClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Classmaster base type for findUnique actions
   */
  export type ClassmasterFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Classmaster
     */
    select?: ClassmasterSelect | null
    /**
     * Filter, which Classmaster to fetch.
     */
    where: ClassmasterWhereUniqueInput
  }

  /**
   * Classmaster findUnique
   */
  export interface ClassmasterFindUniqueArgs extends ClassmasterFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Classmaster findUniqueOrThrow
   */
  export type ClassmasterFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Classmaster
     */
    select?: ClassmasterSelect | null
    /**
     * Filter, which Classmaster to fetch.
     */
    where: ClassmasterWhereUniqueInput
  }


  /**
   * Classmaster base type for findFirst actions
   */
  export type ClassmasterFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Classmaster
     */
    select?: ClassmasterSelect | null
    /**
     * Filter, which Classmaster to fetch.
     */
    where?: ClassmasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classmasters to fetch.
     */
    orderBy?: Enumerable<ClassmasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classmasters.
     */
    cursor?: ClassmasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classmasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classmasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classmasters.
     */
    distinct?: Enumerable<ClassmasterScalarFieldEnum>
  }

  /**
   * Classmaster findFirst
   */
  export interface ClassmasterFindFirstArgs extends ClassmasterFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Classmaster findFirstOrThrow
   */
  export type ClassmasterFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Classmaster
     */
    select?: ClassmasterSelect | null
    /**
     * Filter, which Classmaster to fetch.
     */
    where?: ClassmasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classmasters to fetch.
     */
    orderBy?: Enumerable<ClassmasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classmasters.
     */
    cursor?: ClassmasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classmasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classmasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classmasters.
     */
    distinct?: Enumerable<ClassmasterScalarFieldEnum>
  }


  /**
   * Classmaster findMany
   */
  export type ClassmasterFindManyArgs = {
    /**
     * Select specific fields to fetch from the Classmaster
     */
    select?: ClassmasterSelect | null
    /**
     * Filter, which Classmasters to fetch.
     */
    where?: ClassmasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classmasters to fetch.
     */
    orderBy?: Enumerable<ClassmasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classmasters.
     */
    cursor?: ClassmasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classmasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classmasters.
     */
    skip?: number
    distinct?: Enumerable<ClassmasterScalarFieldEnum>
  }


  /**
   * Classmaster create
   */
  export type ClassmasterCreateArgs = {
    /**
     * Select specific fields to fetch from the Classmaster
     */
    select?: ClassmasterSelect | null
    /**
     * The data needed to create a Classmaster.
     */
    data: XOR<ClassmasterCreateInput, ClassmasterUncheckedCreateInput>
  }


  /**
   * Classmaster createMany
   */
  export type ClassmasterCreateManyArgs = {
    /**
     * The data used to create many Classmasters.
     */
    data: Enumerable<ClassmasterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Classmaster update
   */
  export type ClassmasterUpdateArgs = {
    /**
     * Select specific fields to fetch from the Classmaster
     */
    select?: ClassmasterSelect | null
    /**
     * The data needed to update a Classmaster.
     */
    data: XOR<ClassmasterUpdateInput, ClassmasterUncheckedUpdateInput>
    /**
     * Choose, which Classmaster to update.
     */
    where: ClassmasterWhereUniqueInput
  }


  /**
   * Classmaster updateMany
   */
  export type ClassmasterUpdateManyArgs = {
    /**
     * The data used to update Classmasters.
     */
    data: XOR<ClassmasterUpdateManyMutationInput, ClassmasterUncheckedUpdateManyInput>
    /**
     * Filter which Classmasters to update
     */
    where?: ClassmasterWhereInput
  }


  /**
   * Classmaster upsert
   */
  export type ClassmasterUpsertArgs = {
    /**
     * Select specific fields to fetch from the Classmaster
     */
    select?: ClassmasterSelect | null
    /**
     * The filter to search for the Classmaster to update in case it exists.
     */
    where: ClassmasterWhereUniqueInput
    /**
     * In case the Classmaster found by the `where` argument doesn't exist, create a new Classmaster with this data.
     */
    create: XOR<ClassmasterCreateInput, ClassmasterUncheckedCreateInput>
    /**
     * In case the Classmaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassmasterUpdateInput, ClassmasterUncheckedUpdateInput>
  }


  /**
   * Classmaster delete
   */
  export type ClassmasterDeleteArgs = {
    /**
     * Select specific fields to fetch from the Classmaster
     */
    select?: ClassmasterSelect | null
    /**
     * Filter which Classmaster to delete.
     */
    where: ClassmasterWhereUniqueInput
  }


  /**
   * Classmaster deleteMany
   */
  export type ClassmasterDeleteManyArgs = {
    /**
     * Filter which Classmasters to delete
     */
    where?: ClassmasterWhereInput
  }


  /**
   * Classmaster without action
   */
  export type ClassmasterArgs = {
    /**
     * Select specific fields to fetch from the Classmaster
     */
    select?: ClassmasterSelect | null
  }



  /**
   * Model Subjectmaster
   */


  export type AggregateSubjectmaster = {
    _count: SubjectmasterCountAggregateOutputType | null
    _min: SubjectmasterMinAggregateOutputType | null
    _max: SubjectmasterMaxAggregateOutputType | null
  }

  export type SubjectmasterMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectmasterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectmasterCountAggregateOutputType = {
    id: number
    name: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectmasterMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SubjectmasterMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type SubjectmasterCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectmasterAggregateArgs = {
    /**
     * Filter which Subjectmaster to aggregate.
     */
    where?: SubjectmasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjectmasters to fetch.
     */
    orderBy?: Enumerable<SubjectmasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectmasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjectmasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjectmasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjectmasters
    **/
    _count?: true | SubjectmasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectmasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectmasterMaxAggregateInputType
  }

  export type GetSubjectmasterAggregateType<T extends SubjectmasterAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjectmaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjectmaster[P]>
      : GetScalarType<T[P], AggregateSubjectmaster[P]>
  }




  export type SubjectmasterGroupByArgs = {
    where?: SubjectmasterWhereInput
    orderBy?: Enumerable<SubjectmasterOrderByWithAggregationInput>
    by: SubjectmasterScalarFieldEnum[]
    having?: SubjectmasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectmasterCountAggregateInputType | true
    _min?: SubjectmasterMinAggregateInputType
    _max?: SubjectmasterMaxAggregateInputType
  }


  export type SubjectmasterGroupByOutputType = {
    id: string
    name: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: SubjectmasterCountAggregateOutputType | null
    _min: SubjectmasterMinAggregateOutputType | null
    _max: SubjectmasterMaxAggregateOutputType | null
  }

  type GetSubjectmasterGroupByPayload<T extends SubjectmasterGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubjectmasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectmasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectmasterGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectmasterGroupByOutputType[P]>
        }
      >
    >


  export type SubjectmasterSelect = {
    id?: boolean
    name?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type SubjectmasterGetPayload<S extends boolean | null | undefined | SubjectmasterArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Subjectmaster :
    S extends undefined ? never :
    S extends { include: any } & (SubjectmasterArgs | SubjectmasterFindManyArgs)
    ? Subjectmaster 
    : S extends { select: any } & (SubjectmasterArgs | SubjectmasterFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Subjectmaster ? Subjectmaster[P] : never
  } 
      : Subjectmaster


  type SubjectmasterCountArgs = 
    Omit<SubjectmasterFindManyArgs, 'select' | 'include'> & {
      select?: SubjectmasterCountAggregateInputType | true
    }

  export interface SubjectmasterDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Subjectmaster that matches the filter.
     * @param {SubjectmasterFindUniqueArgs} args - Arguments to find a Subjectmaster
     * @example
     * // Get one Subjectmaster
     * const subjectmaster = await prisma.subjectmaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubjectmasterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubjectmasterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subjectmaster'> extends True ? Prisma__SubjectmasterClient<SubjectmasterGetPayload<T>> : Prisma__SubjectmasterClient<SubjectmasterGetPayload<T> | null, null>

    /**
     * Find one Subjectmaster that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubjectmasterFindUniqueOrThrowArgs} args - Arguments to find a Subjectmaster
     * @example
     * // Get one Subjectmaster
     * const subjectmaster = await prisma.subjectmaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubjectmasterFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubjectmasterFindUniqueOrThrowArgs>
    ): Prisma__SubjectmasterClient<SubjectmasterGetPayload<T>>

    /**
     * Find the first Subjectmaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectmasterFindFirstArgs} args - Arguments to find a Subjectmaster
     * @example
     * // Get one Subjectmaster
     * const subjectmaster = await prisma.subjectmaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubjectmasterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubjectmasterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subjectmaster'> extends True ? Prisma__SubjectmasterClient<SubjectmasterGetPayload<T>> : Prisma__SubjectmasterClient<SubjectmasterGetPayload<T> | null, null>

    /**
     * Find the first Subjectmaster that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectmasterFindFirstOrThrowArgs} args - Arguments to find a Subjectmaster
     * @example
     * // Get one Subjectmaster
     * const subjectmaster = await prisma.subjectmaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubjectmasterFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubjectmasterFindFirstOrThrowArgs>
    ): Prisma__SubjectmasterClient<SubjectmasterGetPayload<T>>

    /**
     * Find zero or more Subjectmasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectmasterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjectmasters
     * const subjectmasters = await prisma.subjectmaster.findMany()
     * 
     * // Get first 10 Subjectmasters
     * const subjectmasters = await prisma.subjectmaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectmasterWithIdOnly = await prisma.subjectmaster.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubjectmasterFindManyArgs>(
      args?: SelectSubset<T, SubjectmasterFindManyArgs>
    ): PrismaPromise<Array<SubjectmasterGetPayload<T>>>

    /**
     * Create a Subjectmaster.
     * @param {SubjectmasterCreateArgs} args - Arguments to create a Subjectmaster.
     * @example
     * // Create one Subjectmaster
     * const Subjectmaster = await prisma.subjectmaster.create({
     *   data: {
     *     // ... data to create a Subjectmaster
     *   }
     * })
     * 
    **/
    create<T extends SubjectmasterCreateArgs>(
      args: SelectSubset<T, SubjectmasterCreateArgs>
    ): Prisma__SubjectmasterClient<SubjectmasterGetPayload<T>>

    /**
     * Create many Subjectmasters.
     *     @param {SubjectmasterCreateManyArgs} args - Arguments to create many Subjectmasters.
     *     @example
     *     // Create many Subjectmasters
     *     const subjectmaster = await prisma.subjectmaster.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubjectmasterCreateManyArgs>(
      args?: SelectSubset<T, SubjectmasterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subjectmaster.
     * @param {SubjectmasterDeleteArgs} args - Arguments to delete one Subjectmaster.
     * @example
     * // Delete one Subjectmaster
     * const Subjectmaster = await prisma.subjectmaster.delete({
     *   where: {
     *     // ... filter to delete one Subjectmaster
     *   }
     * })
     * 
    **/
    delete<T extends SubjectmasterDeleteArgs>(
      args: SelectSubset<T, SubjectmasterDeleteArgs>
    ): Prisma__SubjectmasterClient<SubjectmasterGetPayload<T>>

    /**
     * Update one Subjectmaster.
     * @param {SubjectmasterUpdateArgs} args - Arguments to update one Subjectmaster.
     * @example
     * // Update one Subjectmaster
     * const subjectmaster = await prisma.subjectmaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubjectmasterUpdateArgs>(
      args: SelectSubset<T, SubjectmasterUpdateArgs>
    ): Prisma__SubjectmasterClient<SubjectmasterGetPayload<T>>

    /**
     * Delete zero or more Subjectmasters.
     * @param {SubjectmasterDeleteManyArgs} args - Arguments to filter Subjectmasters to delete.
     * @example
     * // Delete a few Subjectmasters
     * const { count } = await prisma.subjectmaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubjectmasterDeleteManyArgs>(
      args?: SelectSubset<T, SubjectmasterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjectmasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectmasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjectmasters
     * const subjectmaster = await prisma.subjectmaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubjectmasterUpdateManyArgs>(
      args: SelectSubset<T, SubjectmasterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subjectmaster.
     * @param {SubjectmasterUpsertArgs} args - Arguments to update or create a Subjectmaster.
     * @example
     * // Update or create a Subjectmaster
     * const subjectmaster = await prisma.subjectmaster.upsert({
     *   create: {
     *     // ... data to create a Subjectmaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subjectmaster we want to update
     *   }
     * })
    **/
    upsert<T extends SubjectmasterUpsertArgs>(
      args: SelectSubset<T, SubjectmasterUpsertArgs>
    ): Prisma__SubjectmasterClient<SubjectmasterGetPayload<T>>

    /**
     * Count the number of Subjectmasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectmasterCountArgs} args - Arguments to filter Subjectmasters to count.
     * @example
     * // Count the number of Subjectmasters
     * const count = await prisma.subjectmaster.count({
     *   where: {
     *     // ... the filter for the Subjectmasters we want to count
     *   }
     * })
    **/
    count<T extends SubjectmasterCountArgs>(
      args?: Subset<T, SubjectmasterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectmasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subjectmaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectmasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectmasterAggregateArgs>(args: Subset<T, SubjectmasterAggregateArgs>): PrismaPromise<GetSubjectmasterAggregateType<T>>

    /**
     * Group by Subjectmaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectmasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectmasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectmasterGroupByArgs['orderBy'] }
        : { orderBy?: SubjectmasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectmasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectmasterGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Subjectmaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubjectmasterClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Subjectmaster base type for findUnique actions
   */
  export type SubjectmasterFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Subjectmaster
     */
    select?: SubjectmasterSelect | null
    /**
     * Filter, which Subjectmaster to fetch.
     */
    where: SubjectmasterWhereUniqueInput
  }

  /**
   * Subjectmaster findUnique
   */
  export interface SubjectmasterFindUniqueArgs extends SubjectmasterFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subjectmaster findUniqueOrThrow
   */
  export type SubjectmasterFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Subjectmaster
     */
    select?: SubjectmasterSelect | null
    /**
     * Filter, which Subjectmaster to fetch.
     */
    where: SubjectmasterWhereUniqueInput
  }


  /**
   * Subjectmaster base type for findFirst actions
   */
  export type SubjectmasterFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Subjectmaster
     */
    select?: SubjectmasterSelect | null
    /**
     * Filter, which Subjectmaster to fetch.
     */
    where?: SubjectmasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjectmasters to fetch.
     */
    orderBy?: Enumerable<SubjectmasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjectmasters.
     */
    cursor?: SubjectmasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjectmasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjectmasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjectmasters.
     */
    distinct?: Enumerable<SubjectmasterScalarFieldEnum>
  }

  /**
   * Subjectmaster findFirst
   */
  export interface SubjectmasterFindFirstArgs extends SubjectmasterFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subjectmaster findFirstOrThrow
   */
  export type SubjectmasterFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Subjectmaster
     */
    select?: SubjectmasterSelect | null
    /**
     * Filter, which Subjectmaster to fetch.
     */
    where?: SubjectmasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjectmasters to fetch.
     */
    orderBy?: Enumerable<SubjectmasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjectmasters.
     */
    cursor?: SubjectmasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjectmasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjectmasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjectmasters.
     */
    distinct?: Enumerable<SubjectmasterScalarFieldEnum>
  }


  /**
   * Subjectmaster findMany
   */
  export type SubjectmasterFindManyArgs = {
    /**
     * Select specific fields to fetch from the Subjectmaster
     */
    select?: SubjectmasterSelect | null
    /**
     * Filter, which Subjectmasters to fetch.
     */
    where?: SubjectmasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjectmasters to fetch.
     */
    orderBy?: Enumerable<SubjectmasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjectmasters.
     */
    cursor?: SubjectmasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjectmasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjectmasters.
     */
    skip?: number
    distinct?: Enumerable<SubjectmasterScalarFieldEnum>
  }


  /**
   * Subjectmaster create
   */
  export type SubjectmasterCreateArgs = {
    /**
     * Select specific fields to fetch from the Subjectmaster
     */
    select?: SubjectmasterSelect | null
    /**
     * The data needed to create a Subjectmaster.
     */
    data: XOR<SubjectmasterCreateInput, SubjectmasterUncheckedCreateInput>
  }


  /**
   * Subjectmaster createMany
   */
  export type SubjectmasterCreateManyArgs = {
    /**
     * The data used to create many Subjectmasters.
     */
    data: Enumerable<SubjectmasterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Subjectmaster update
   */
  export type SubjectmasterUpdateArgs = {
    /**
     * Select specific fields to fetch from the Subjectmaster
     */
    select?: SubjectmasterSelect | null
    /**
     * The data needed to update a Subjectmaster.
     */
    data: XOR<SubjectmasterUpdateInput, SubjectmasterUncheckedUpdateInput>
    /**
     * Choose, which Subjectmaster to update.
     */
    where: SubjectmasterWhereUniqueInput
  }


  /**
   * Subjectmaster updateMany
   */
  export type SubjectmasterUpdateManyArgs = {
    /**
     * The data used to update Subjectmasters.
     */
    data: XOR<SubjectmasterUpdateManyMutationInput, SubjectmasterUncheckedUpdateManyInput>
    /**
     * Filter which Subjectmasters to update
     */
    where?: SubjectmasterWhereInput
  }


  /**
   * Subjectmaster upsert
   */
  export type SubjectmasterUpsertArgs = {
    /**
     * Select specific fields to fetch from the Subjectmaster
     */
    select?: SubjectmasterSelect | null
    /**
     * The filter to search for the Subjectmaster to update in case it exists.
     */
    where: SubjectmasterWhereUniqueInput
    /**
     * In case the Subjectmaster found by the `where` argument doesn't exist, create a new Subjectmaster with this data.
     */
    create: XOR<SubjectmasterCreateInput, SubjectmasterUncheckedCreateInput>
    /**
     * In case the Subjectmaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectmasterUpdateInput, SubjectmasterUncheckedUpdateInput>
  }


  /**
   * Subjectmaster delete
   */
  export type SubjectmasterDeleteArgs = {
    /**
     * Select specific fields to fetch from the Subjectmaster
     */
    select?: SubjectmasterSelect | null
    /**
     * Filter which Subjectmaster to delete.
     */
    where: SubjectmasterWhereUniqueInput
  }


  /**
   * Subjectmaster deleteMany
   */
  export type SubjectmasterDeleteManyArgs = {
    /**
     * Filter which Subjectmasters to delete
     */
    where?: SubjectmasterWhereInput
  }


  /**
   * Subjectmaster without action
   */
  export type SubjectmasterArgs = {
    /**
     * Select specific fields to fetch from the Subjectmaster
     */
    select?: SubjectmasterSelect | null
  }



  /**
   * Model StudentMaster
   */


  export type AggregateStudentMaster = {
    _count: StudentMasterCountAggregateOutputType | null
    _min: StudentMasterMinAggregateOutputType | null
    _max: StudentMasterMaxAggregateOutputType | null
  }

  export type StudentMasterMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    password: string | null
    dob: Date | null
    admissionId: string | null
    rollNo: string | null
    profileImg: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMasterMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    password: string | null
    dob: Date | null
    admissionId: string | null
    rollNo: string | null
    profileImg: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMasterCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    password: number
    dob: number
    admissionId: number
    rollNo: number
    profileImg: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type StudentMasterMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    password?: true
    dob?: true
    admissionId?: true
    rollNo?: true
    profileImg?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type StudentMasterMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    password?: true
    dob?: true
    admissionId?: true
    rollNo?: true
    profileImg?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type StudentMasterCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    password?: true
    dob?: true
    admissionId?: true
    rollNo?: true
    profileImg?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentMasterAggregateArgs = {
    /**
     * Filter which StudentMaster to aggregate.
     */
    where?: StudentMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentMasters to fetch.
     */
    orderBy?: Enumerable<StudentMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentMasters
    **/
    _count?: true | StudentMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMasterMaxAggregateInputType
  }

  export type GetStudentMasterAggregateType<T extends StudentMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentMaster[P]>
      : GetScalarType<T[P], AggregateStudentMaster[P]>
  }




  export type StudentMasterGroupByArgs = {
    where?: StudentMasterWhereInput
    orderBy?: Enumerable<StudentMasterOrderByWithAggregationInput>
    by: StudentMasterScalarFieldEnum[]
    having?: StudentMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentMasterCountAggregateInputType | true
    _min?: StudentMasterMinAggregateInputType
    _max?: StudentMasterMaxAggregateInputType
  }


  export type StudentMasterGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    dob: Date
    admissionId: string
    rollNo: string
    profileImg: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: StudentMasterCountAggregateOutputType | null
    _min: StudentMasterMinAggregateOutputType | null
    _max: StudentMasterMaxAggregateOutputType | null
  }

  type GetStudentMasterGroupByPayload<T extends StudentMasterGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StudentMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentMasterGroupByOutputType[P]>
            : GetScalarType<T[P], StudentMasterGroupByOutputType[P]>
        }
      >
    >


  export type StudentMasterSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    dob?: boolean
    admissionId?: boolean
    rollNo?: boolean
    profileImg?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
    StudentDetail?: boolean | StudentMaster$StudentDetailArgs
    StudentAddress?: boolean | StudentMaster$StudentAddressArgs
    StudentParents?: boolean | StudentMaster$StudentParentsArgs
    _count?: boolean | StudentMasterCountOutputTypeArgs
  }


  export type StudentMasterInclude = {
    StudentDetail?: boolean | StudentMaster$StudentDetailArgs
    StudentAddress?: boolean | StudentMaster$StudentAddressArgs
    StudentParents?: boolean | StudentMaster$StudentParentsArgs
    _count?: boolean | StudentMasterCountOutputTypeArgs
  }

  export type StudentMasterGetPayload<S extends boolean | null | undefined | StudentMasterArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StudentMaster :
    S extends undefined ? never :
    S extends { include: any } & (StudentMasterArgs | StudentMasterFindManyArgs)
    ? StudentMaster  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'StudentDetail' ? Array < StudentDocumentsGetPayload<S['include'][P]>>  :
        P extends 'StudentAddress' ? Array < StudentAddressGetPayload<S['include'][P]>>  :
        P extends 'StudentParents' ? Array < StudentParentsGetPayload<S['include'][P]>>  :
        P extends '_count' ? StudentMasterCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (StudentMasterArgs | StudentMasterFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'StudentDetail' ? Array < StudentDocumentsGetPayload<S['select'][P]>>  :
        P extends 'StudentAddress' ? Array < StudentAddressGetPayload<S['select'][P]>>  :
        P extends 'StudentParents' ? Array < StudentParentsGetPayload<S['select'][P]>>  :
        P extends '_count' ? StudentMasterCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof StudentMaster ? StudentMaster[P] : never
  } 
      : StudentMaster


  type StudentMasterCountArgs = 
    Omit<StudentMasterFindManyArgs, 'select' | 'include'> & {
      select?: StudentMasterCountAggregateInputType | true
    }

  export interface StudentMasterDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one StudentMaster that matches the filter.
     * @param {StudentMasterFindUniqueArgs} args - Arguments to find a StudentMaster
     * @example
     * // Get one StudentMaster
     * const studentMaster = await prisma.studentMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentMasterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentMasterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StudentMaster'> extends True ? Prisma__StudentMasterClient<StudentMasterGetPayload<T>> : Prisma__StudentMasterClient<StudentMasterGetPayload<T> | null, null>

    /**
     * Find one StudentMaster that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentMasterFindUniqueOrThrowArgs} args - Arguments to find a StudentMaster
     * @example
     * // Get one StudentMaster
     * const studentMaster = await prisma.studentMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentMasterFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StudentMasterFindUniqueOrThrowArgs>
    ): Prisma__StudentMasterClient<StudentMasterGetPayload<T>>

    /**
     * Find the first StudentMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMasterFindFirstArgs} args - Arguments to find a StudentMaster
     * @example
     * // Get one StudentMaster
     * const studentMaster = await prisma.studentMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentMasterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentMasterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StudentMaster'> extends True ? Prisma__StudentMasterClient<StudentMasterGetPayload<T>> : Prisma__StudentMasterClient<StudentMasterGetPayload<T> | null, null>

    /**
     * Find the first StudentMaster that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMasterFindFirstOrThrowArgs} args - Arguments to find a StudentMaster
     * @example
     * // Get one StudentMaster
     * const studentMaster = await prisma.studentMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentMasterFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StudentMasterFindFirstOrThrowArgs>
    ): Prisma__StudentMasterClient<StudentMasterGetPayload<T>>

    /**
     * Find zero or more StudentMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMasterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentMasters
     * const studentMasters = await prisma.studentMaster.findMany()
     * 
     * // Get first 10 StudentMasters
     * const studentMasters = await prisma.studentMaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentMasterWithIdOnly = await prisma.studentMaster.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentMasterFindManyArgs>(
      args?: SelectSubset<T, StudentMasterFindManyArgs>
    ): PrismaPromise<Array<StudentMasterGetPayload<T>>>

    /**
     * Create a StudentMaster.
     * @param {StudentMasterCreateArgs} args - Arguments to create a StudentMaster.
     * @example
     * // Create one StudentMaster
     * const StudentMaster = await prisma.studentMaster.create({
     *   data: {
     *     // ... data to create a StudentMaster
     *   }
     * })
     * 
    **/
    create<T extends StudentMasterCreateArgs>(
      args: SelectSubset<T, StudentMasterCreateArgs>
    ): Prisma__StudentMasterClient<StudentMasterGetPayload<T>>

    /**
     * Create many StudentMasters.
     *     @param {StudentMasterCreateManyArgs} args - Arguments to create many StudentMasters.
     *     @example
     *     // Create many StudentMasters
     *     const studentMaster = await prisma.studentMaster.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentMasterCreateManyArgs>(
      args?: SelectSubset<T, StudentMasterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StudentMaster.
     * @param {StudentMasterDeleteArgs} args - Arguments to delete one StudentMaster.
     * @example
     * // Delete one StudentMaster
     * const StudentMaster = await prisma.studentMaster.delete({
     *   where: {
     *     // ... filter to delete one StudentMaster
     *   }
     * })
     * 
    **/
    delete<T extends StudentMasterDeleteArgs>(
      args: SelectSubset<T, StudentMasterDeleteArgs>
    ): Prisma__StudentMasterClient<StudentMasterGetPayload<T>>

    /**
     * Update one StudentMaster.
     * @param {StudentMasterUpdateArgs} args - Arguments to update one StudentMaster.
     * @example
     * // Update one StudentMaster
     * const studentMaster = await prisma.studentMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentMasterUpdateArgs>(
      args: SelectSubset<T, StudentMasterUpdateArgs>
    ): Prisma__StudentMasterClient<StudentMasterGetPayload<T>>

    /**
     * Delete zero or more StudentMasters.
     * @param {StudentMasterDeleteManyArgs} args - Arguments to filter StudentMasters to delete.
     * @example
     * // Delete a few StudentMasters
     * const { count } = await prisma.studentMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentMasterDeleteManyArgs>(
      args?: SelectSubset<T, StudentMasterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentMasters
     * const studentMaster = await prisma.studentMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentMasterUpdateManyArgs>(
      args: SelectSubset<T, StudentMasterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentMaster.
     * @param {StudentMasterUpsertArgs} args - Arguments to update or create a StudentMaster.
     * @example
     * // Update or create a StudentMaster
     * const studentMaster = await prisma.studentMaster.upsert({
     *   create: {
     *     // ... data to create a StudentMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentMaster we want to update
     *   }
     * })
    **/
    upsert<T extends StudentMasterUpsertArgs>(
      args: SelectSubset<T, StudentMasterUpsertArgs>
    ): Prisma__StudentMasterClient<StudentMasterGetPayload<T>>

    /**
     * Count the number of StudentMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMasterCountArgs} args - Arguments to filter StudentMasters to count.
     * @example
     * // Count the number of StudentMasters
     * const count = await prisma.studentMaster.count({
     *   where: {
     *     // ... the filter for the StudentMasters we want to count
     *   }
     * })
    **/
    count<T extends StudentMasterCountArgs>(
      args?: Subset<T, StudentMasterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentMasterAggregateArgs>(args: Subset<T, StudentMasterAggregateArgs>): PrismaPromise<GetStudentMasterAggregateType<T>>

    /**
     * Group by StudentMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentMasterGroupByArgs['orderBy'] }
        : { orderBy?: StudentMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentMasterGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentMasterClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    StudentDetail<T extends StudentMaster$StudentDetailArgs= {}>(args?: Subset<T, StudentMaster$StudentDetailArgs>): PrismaPromise<Array<StudentDocumentsGetPayload<T>>| Null>;

    StudentAddress<T extends StudentMaster$StudentAddressArgs= {}>(args?: Subset<T, StudentMaster$StudentAddressArgs>): PrismaPromise<Array<StudentAddressGetPayload<T>>| Null>;

    StudentParents<T extends StudentMaster$StudentParentsArgs= {}>(args?: Subset<T, StudentMaster$StudentParentsArgs>): PrismaPromise<Array<StudentParentsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * StudentMaster base type for findUnique actions
   */
  export type StudentMasterFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the StudentMaster
     */
    select?: StudentMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentMasterInclude | null
    /**
     * Filter, which StudentMaster to fetch.
     */
    where: StudentMasterWhereUniqueInput
  }

  /**
   * StudentMaster findUnique
   */
  export interface StudentMasterFindUniqueArgs extends StudentMasterFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StudentMaster findUniqueOrThrow
   */
  export type StudentMasterFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the StudentMaster
     */
    select?: StudentMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentMasterInclude | null
    /**
     * Filter, which StudentMaster to fetch.
     */
    where: StudentMasterWhereUniqueInput
  }


  /**
   * StudentMaster base type for findFirst actions
   */
  export type StudentMasterFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the StudentMaster
     */
    select?: StudentMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentMasterInclude | null
    /**
     * Filter, which StudentMaster to fetch.
     */
    where?: StudentMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentMasters to fetch.
     */
    orderBy?: Enumerable<StudentMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentMasters.
     */
    cursor?: StudentMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentMasters.
     */
    distinct?: Enumerable<StudentMasterScalarFieldEnum>
  }

  /**
   * StudentMaster findFirst
   */
  export interface StudentMasterFindFirstArgs extends StudentMasterFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StudentMaster findFirstOrThrow
   */
  export type StudentMasterFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the StudentMaster
     */
    select?: StudentMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentMasterInclude | null
    /**
     * Filter, which StudentMaster to fetch.
     */
    where?: StudentMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentMasters to fetch.
     */
    orderBy?: Enumerable<StudentMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentMasters.
     */
    cursor?: StudentMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentMasters.
     */
    distinct?: Enumerable<StudentMasterScalarFieldEnum>
  }


  /**
   * StudentMaster findMany
   */
  export type StudentMasterFindManyArgs = {
    /**
     * Select specific fields to fetch from the StudentMaster
     */
    select?: StudentMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentMasterInclude | null
    /**
     * Filter, which StudentMasters to fetch.
     */
    where?: StudentMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentMasters to fetch.
     */
    orderBy?: Enumerable<StudentMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentMasters.
     */
    cursor?: StudentMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentMasters.
     */
    skip?: number
    distinct?: Enumerable<StudentMasterScalarFieldEnum>
  }


  /**
   * StudentMaster create
   */
  export type StudentMasterCreateArgs = {
    /**
     * Select specific fields to fetch from the StudentMaster
     */
    select?: StudentMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentMasterInclude | null
    /**
     * The data needed to create a StudentMaster.
     */
    data: XOR<StudentMasterCreateInput, StudentMasterUncheckedCreateInput>
  }


  /**
   * StudentMaster createMany
   */
  export type StudentMasterCreateManyArgs = {
    /**
     * The data used to create many StudentMasters.
     */
    data: Enumerable<StudentMasterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StudentMaster update
   */
  export type StudentMasterUpdateArgs = {
    /**
     * Select specific fields to fetch from the StudentMaster
     */
    select?: StudentMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentMasterInclude | null
    /**
     * The data needed to update a StudentMaster.
     */
    data: XOR<StudentMasterUpdateInput, StudentMasterUncheckedUpdateInput>
    /**
     * Choose, which StudentMaster to update.
     */
    where: StudentMasterWhereUniqueInput
  }


  /**
   * StudentMaster updateMany
   */
  export type StudentMasterUpdateManyArgs = {
    /**
     * The data used to update StudentMasters.
     */
    data: XOR<StudentMasterUpdateManyMutationInput, StudentMasterUncheckedUpdateManyInput>
    /**
     * Filter which StudentMasters to update
     */
    where?: StudentMasterWhereInput
  }


  /**
   * StudentMaster upsert
   */
  export type StudentMasterUpsertArgs = {
    /**
     * Select specific fields to fetch from the StudentMaster
     */
    select?: StudentMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentMasterInclude | null
    /**
     * The filter to search for the StudentMaster to update in case it exists.
     */
    where: StudentMasterWhereUniqueInput
    /**
     * In case the StudentMaster found by the `where` argument doesn't exist, create a new StudentMaster with this data.
     */
    create: XOR<StudentMasterCreateInput, StudentMasterUncheckedCreateInput>
    /**
     * In case the StudentMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentMasterUpdateInput, StudentMasterUncheckedUpdateInput>
  }


  /**
   * StudentMaster delete
   */
  export type StudentMasterDeleteArgs = {
    /**
     * Select specific fields to fetch from the StudentMaster
     */
    select?: StudentMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentMasterInclude | null
    /**
     * Filter which StudentMaster to delete.
     */
    where: StudentMasterWhereUniqueInput
  }


  /**
   * StudentMaster deleteMany
   */
  export type StudentMasterDeleteManyArgs = {
    /**
     * Filter which StudentMasters to delete
     */
    where?: StudentMasterWhereInput
  }


  /**
   * StudentMaster.StudentDetail
   */
  export type StudentMaster$StudentDetailArgs = {
    /**
     * Select specific fields to fetch from the StudentDocuments
     */
    select?: StudentDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentDocumentsInclude | null
    where?: StudentDocumentsWhereInput
    orderBy?: Enumerable<StudentDocumentsOrderByWithRelationInput>
    cursor?: StudentDocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentDocumentsScalarFieldEnum>
  }


  /**
   * StudentMaster.StudentAddress
   */
  export type StudentMaster$StudentAddressArgs = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    where?: StudentAddressWhereInput
    orderBy?: Enumerable<StudentAddressOrderByWithRelationInput>
    cursor?: StudentAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentAddressScalarFieldEnum>
  }


  /**
   * StudentMaster.StudentParents
   */
  export type StudentMaster$StudentParentsArgs = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentParentsInclude | null
    where?: StudentParentsWhereInput
    orderBy?: Enumerable<StudentParentsOrderByWithRelationInput>
    cursor?: StudentParentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentParentsScalarFieldEnum>
  }


  /**
   * StudentMaster without action
   */
  export type StudentMasterArgs = {
    /**
     * Select specific fields to fetch from the StudentMaster
     */
    select?: StudentMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentMasterInclude | null
  }



  /**
   * Model StudentParents
   */


  export type AggregateStudentParents = {
    _count: StudentParentsCountAggregateOutputType | null
    _min: StudentParentsMinAggregateOutputType | null
    _max: StudentParentsMaxAggregateOutputType | null
  }

  export type StudentParentsMinAggregateOutputType = {
    id: string | null
    fkStudentId: string | null
    name: string | null
    relation: string | null
    phone: string | null
    email: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type StudentParentsMaxAggregateOutputType = {
    id: string | null
    fkStudentId: string | null
    name: string | null
    relation: string | null
    phone: string | null
    email: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type StudentParentsCountAggregateOutputType = {
    id: number
    fkStudentId: number
    name: number
    relation: number
    phone: number
    email: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type StudentParentsMinAggregateInputType = {
    id?: true
    fkStudentId?: true
    name?: true
    relation?: true
    phone?: true
    email?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type StudentParentsMaxAggregateInputType = {
    id?: true
    fkStudentId?: true
    name?: true
    relation?: true
    phone?: true
    email?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type StudentParentsCountAggregateInputType = {
    id?: true
    fkStudentId?: true
    name?: true
    relation?: true
    phone?: true
    email?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentParentsAggregateArgs = {
    /**
     * Filter which StudentParents to aggregate.
     */
    where?: StudentParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: Enumerable<StudentParentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentParents
    **/
    _count?: true | StudentParentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentParentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentParentsMaxAggregateInputType
  }

  export type GetStudentParentsAggregateType<T extends StudentParentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentParents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentParents[P]>
      : GetScalarType<T[P], AggregateStudentParents[P]>
  }




  export type StudentParentsGroupByArgs = {
    where?: StudentParentsWhereInput
    orderBy?: Enumerable<StudentParentsOrderByWithAggregationInput>
    by: StudentParentsScalarFieldEnum[]
    having?: StudentParentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentParentsCountAggregateInputType | true
    _min?: StudentParentsMinAggregateInputType
    _max?: StudentParentsMaxAggregateInputType
  }


  export type StudentParentsGroupByOutputType = {
    id: string
    fkStudentId: string
    name: string
    relation: string
    phone: string
    email: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: StudentParentsCountAggregateOutputType | null
    _min: StudentParentsMinAggregateOutputType | null
    _max: StudentParentsMaxAggregateOutputType | null
  }

  type GetStudentParentsGroupByPayload<T extends StudentParentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StudentParentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentParentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentParentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentParentsGroupByOutputType[P]>
        }
      >
    >


  export type StudentParentsSelect = {
    id?: boolean
    StudentId?: boolean | StudentMasterArgs
    fkStudentId?: boolean
    name?: boolean
    relation?: boolean
    phone?: boolean
    email?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type StudentParentsInclude = {
    StudentId?: boolean | StudentMasterArgs
  }

  export type StudentParentsGetPayload<S extends boolean | null | undefined | StudentParentsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StudentParents :
    S extends undefined ? never :
    S extends { include: any } & (StudentParentsArgs | StudentParentsFindManyArgs)
    ? StudentParents  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'StudentId' ? StudentMasterGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (StudentParentsArgs | StudentParentsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'StudentId' ? StudentMasterGetPayload<S['select'][P]> :  P extends keyof StudentParents ? StudentParents[P] : never
  } 
      : StudentParents


  type StudentParentsCountArgs = 
    Omit<StudentParentsFindManyArgs, 'select' | 'include'> & {
      select?: StudentParentsCountAggregateInputType | true
    }

  export interface StudentParentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one StudentParents that matches the filter.
     * @param {StudentParentsFindUniqueArgs} args - Arguments to find a StudentParents
     * @example
     * // Get one StudentParents
     * const studentParents = await prisma.studentParents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentParentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentParentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StudentParents'> extends True ? Prisma__StudentParentsClient<StudentParentsGetPayload<T>> : Prisma__StudentParentsClient<StudentParentsGetPayload<T> | null, null>

    /**
     * Find one StudentParents that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentParentsFindUniqueOrThrowArgs} args - Arguments to find a StudentParents
     * @example
     * // Get one StudentParents
     * const studentParents = await prisma.studentParents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentParentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StudentParentsFindUniqueOrThrowArgs>
    ): Prisma__StudentParentsClient<StudentParentsGetPayload<T>>

    /**
     * Find the first StudentParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsFindFirstArgs} args - Arguments to find a StudentParents
     * @example
     * // Get one StudentParents
     * const studentParents = await prisma.studentParents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentParentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentParentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StudentParents'> extends True ? Prisma__StudentParentsClient<StudentParentsGetPayload<T>> : Prisma__StudentParentsClient<StudentParentsGetPayload<T> | null, null>

    /**
     * Find the first StudentParents that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsFindFirstOrThrowArgs} args - Arguments to find a StudentParents
     * @example
     * // Get one StudentParents
     * const studentParents = await prisma.studentParents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentParentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StudentParentsFindFirstOrThrowArgs>
    ): Prisma__StudentParentsClient<StudentParentsGetPayload<T>>

    /**
     * Find zero or more StudentParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentParents
     * const studentParents = await prisma.studentParents.findMany()
     * 
     * // Get first 10 StudentParents
     * const studentParents = await prisma.studentParents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentParentsWithIdOnly = await prisma.studentParents.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentParentsFindManyArgs>(
      args?: SelectSubset<T, StudentParentsFindManyArgs>
    ): PrismaPromise<Array<StudentParentsGetPayload<T>>>

    /**
     * Create a StudentParents.
     * @param {StudentParentsCreateArgs} args - Arguments to create a StudentParents.
     * @example
     * // Create one StudentParents
     * const StudentParents = await prisma.studentParents.create({
     *   data: {
     *     // ... data to create a StudentParents
     *   }
     * })
     * 
    **/
    create<T extends StudentParentsCreateArgs>(
      args: SelectSubset<T, StudentParentsCreateArgs>
    ): Prisma__StudentParentsClient<StudentParentsGetPayload<T>>

    /**
     * Create many StudentParents.
     *     @param {StudentParentsCreateManyArgs} args - Arguments to create many StudentParents.
     *     @example
     *     // Create many StudentParents
     *     const studentParents = await prisma.studentParents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentParentsCreateManyArgs>(
      args?: SelectSubset<T, StudentParentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StudentParents.
     * @param {StudentParentsDeleteArgs} args - Arguments to delete one StudentParents.
     * @example
     * // Delete one StudentParents
     * const StudentParents = await prisma.studentParents.delete({
     *   where: {
     *     // ... filter to delete one StudentParents
     *   }
     * })
     * 
    **/
    delete<T extends StudentParentsDeleteArgs>(
      args: SelectSubset<T, StudentParentsDeleteArgs>
    ): Prisma__StudentParentsClient<StudentParentsGetPayload<T>>

    /**
     * Update one StudentParents.
     * @param {StudentParentsUpdateArgs} args - Arguments to update one StudentParents.
     * @example
     * // Update one StudentParents
     * const studentParents = await prisma.studentParents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentParentsUpdateArgs>(
      args: SelectSubset<T, StudentParentsUpdateArgs>
    ): Prisma__StudentParentsClient<StudentParentsGetPayload<T>>

    /**
     * Delete zero or more StudentParents.
     * @param {StudentParentsDeleteManyArgs} args - Arguments to filter StudentParents to delete.
     * @example
     * // Delete a few StudentParents
     * const { count } = await prisma.studentParents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentParentsDeleteManyArgs>(
      args?: SelectSubset<T, StudentParentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentParents
     * const studentParents = await prisma.studentParents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentParentsUpdateManyArgs>(
      args: SelectSubset<T, StudentParentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentParents.
     * @param {StudentParentsUpsertArgs} args - Arguments to update or create a StudentParents.
     * @example
     * // Update or create a StudentParents
     * const studentParents = await prisma.studentParents.upsert({
     *   create: {
     *     // ... data to create a StudentParents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentParents we want to update
     *   }
     * })
    **/
    upsert<T extends StudentParentsUpsertArgs>(
      args: SelectSubset<T, StudentParentsUpsertArgs>
    ): Prisma__StudentParentsClient<StudentParentsGetPayload<T>>

    /**
     * Count the number of StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsCountArgs} args - Arguments to filter StudentParents to count.
     * @example
     * // Count the number of StudentParents
     * const count = await prisma.studentParents.count({
     *   where: {
     *     // ... the filter for the StudentParents we want to count
     *   }
     * })
    **/
    count<T extends StudentParentsCountArgs>(
      args?: Subset<T, StudentParentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentParentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentParentsAggregateArgs>(args: Subset<T, StudentParentsAggregateArgs>): PrismaPromise<GetStudentParentsAggregateType<T>>

    /**
     * Group by StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentParentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentParentsGroupByArgs['orderBy'] }
        : { orderBy?: StudentParentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentParentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentParentsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentParents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentParentsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    StudentId<T extends StudentMasterArgs= {}>(args?: Subset<T, StudentMasterArgs>): Prisma__StudentMasterClient<StudentMasterGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * StudentParents base type for findUnique actions
   */
  export type StudentParentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentParentsInclude | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where: StudentParentsWhereUniqueInput
  }

  /**
   * StudentParents findUnique
   */
  export interface StudentParentsFindUniqueArgs extends StudentParentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StudentParents findUniqueOrThrow
   */
  export type StudentParentsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentParentsInclude | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where: StudentParentsWhereUniqueInput
  }


  /**
   * StudentParents base type for findFirst actions
   */
  export type StudentParentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentParentsInclude | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: Enumerable<StudentParentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: Enumerable<StudentParentsScalarFieldEnum>
  }

  /**
   * StudentParents findFirst
   */
  export interface StudentParentsFindFirstArgs extends StudentParentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StudentParents findFirstOrThrow
   */
  export type StudentParentsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentParentsInclude | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: Enumerable<StudentParentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: Enumerable<StudentParentsScalarFieldEnum>
  }


  /**
   * StudentParents findMany
   */
  export type StudentParentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentParentsInclude | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: Enumerable<StudentParentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentParents.
     */
    cursor?: StudentParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    distinct?: Enumerable<StudentParentsScalarFieldEnum>
  }


  /**
   * StudentParents create
   */
  export type StudentParentsCreateArgs = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentParentsInclude | null
    /**
     * The data needed to create a StudentParents.
     */
    data: XOR<StudentParentsCreateInput, StudentParentsUncheckedCreateInput>
  }


  /**
   * StudentParents createMany
   */
  export type StudentParentsCreateManyArgs = {
    /**
     * The data used to create many StudentParents.
     */
    data: Enumerable<StudentParentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StudentParents update
   */
  export type StudentParentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentParentsInclude | null
    /**
     * The data needed to update a StudentParents.
     */
    data: XOR<StudentParentsUpdateInput, StudentParentsUncheckedUpdateInput>
    /**
     * Choose, which StudentParents to update.
     */
    where: StudentParentsWhereUniqueInput
  }


  /**
   * StudentParents updateMany
   */
  export type StudentParentsUpdateManyArgs = {
    /**
     * The data used to update StudentParents.
     */
    data: XOR<StudentParentsUpdateManyMutationInput, StudentParentsUncheckedUpdateManyInput>
    /**
     * Filter which StudentParents to update
     */
    where?: StudentParentsWhereInput
  }


  /**
   * StudentParents upsert
   */
  export type StudentParentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentParentsInclude | null
    /**
     * The filter to search for the StudentParents to update in case it exists.
     */
    where: StudentParentsWhereUniqueInput
    /**
     * In case the StudentParents found by the `where` argument doesn't exist, create a new StudentParents with this data.
     */
    create: XOR<StudentParentsCreateInput, StudentParentsUncheckedCreateInput>
    /**
     * In case the StudentParents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentParentsUpdateInput, StudentParentsUncheckedUpdateInput>
  }


  /**
   * StudentParents delete
   */
  export type StudentParentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentParentsInclude | null
    /**
     * Filter which StudentParents to delete.
     */
    where: StudentParentsWhereUniqueInput
  }


  /**
   * StudentParents deleteMany
   */
  export type StudentParentsDeleteManyArgs = {
    /**
     * Filter which StudentParents to delete
     */
    where?: StudentParentsWhereInput
  }


  /**
   * StudentParents without action
   */
  export type StudentParentsArgs = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentParentsInclude | null
  }



  /**
   * Model StudentDocuments
   */


  export type AggregateStudentDocuments = {
    _count: StudentDocumentsCountAggregateOutputType | null
    _min: StudentDocumentsMinAggregateOutputType | null
    _max: StudentDocumentsMaxAggregateOutputType | null
  }

  export type StudentDocumentsMinAggregateOutputType = {
    id: string | null
    fkStudentId: string | null
    category: string | null
    docUrl: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type StudentDocumentsMaxAggregateOutputType = {
    id: string | null
    fkStudentId: string | null
    category: string | null
    docUrl: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type StudentDocumentsCountAggregateOutputType = {
    id: number
    fkStudentId: number
    category: number
    docUrl: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type StudentDocumentsMinAggregateInputType = {
    id?: true
    fkStudentId?: true
    category?: true
    docUrl?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type StudentDocumentsMaxAggregateInputType = {
    id?: true
    fkStudentId?: true
    category?: true
    docUrl?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type StudentDocumentsCountAggregateInputType = {
    id?: true
    fkStudentId?: true
    category?: true
    docUrl?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentDocumentsAggregateArgs = {
    /**
     * Filter which StudentDocuments to aggregate.
     */
    where?: StudentDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: Enumerable<StudentDocumentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentDocuments
    **/
    _count?: true | StudentDocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentDocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentDocumentsMaxAggregateInputType
  }

  export type GetStudentDocumentsAggregateType<T extends StudentDocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentDocuments[P]>
      : GetScalarType<T[P], AggregateStudentDocuments[P]>
  }




  export type StudentDocumentsGroupByArgs = {
    where?: StudentDocumentsWhereInput
    orderBy?: Enumerable<StudentDocumentsOrderByWithAggregationInput>
    by: StudentDocumentsScalarFieldEnum[]
    having?: StudentDocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentDocumentsCountAggregateInputType | true
    _min?: StudentDocumentsMinAggregateInputType
    _max?: StudentDocumentsMaxAggregateInputType
  }


  export type StudentDocumentsGroupByOutputType = {
    id: string
    fkStudentId: string
    category: string
    docUrl: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: StudentDocumentsCountAggregateOutputType | null
    _min: StudentDocumentsMinAggregateOutputType | null
    _max: StudentDocumentsMaxAggregateOutputType | null
  }

  type GetStudentDocumentsGroupByPayload<T extends StudentDocumentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StudentDocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentDocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentDocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentDocumentsGroupByOutputType[P]>
        }
      >
    >


  export type StudentDocumentsSelect = {
    id?: boolean
    StudentId?: boolean | StudentMasterArgs
    fkStudentId?: boolean
    category?: boolean
    docUrl?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type StudentDocumentsInclude = {
    StudentId?: boolean | StudentMasterArgs
  }

  export type StudentDocumentsGetPayload<S extends boolean | null | undefined | StudentDocumentsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StudentDocuments :
    S extends undefined ? never :
    S extends { include: any } & (StudentDocumentsArgs | StudentDocumentsFindManyArgs)
    ? StudentDocuments  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'StudentId' ? StudentMasterGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (StudentDocumentsArgs | StudentDocumentsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'StudentId' ? StudentMasterGetPayload<S['select'][P]> :  P extends keyof StudentDocuments ? StudentDocuments[P] : never
  } 
      : StudentDocuments


  type StudentDocumentsCountArgs = 
    Omit<StudentDocumentsFindManyArgs, 'select' | 'include'> & {
      select?: StudentDocumentsCountAggregateInputType | true
    }

  export interface StudentDocumentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one StudentDocuments that matches the filter.
     * @param {StudentDocumentsFindUniqueArgs} args - Arguments to find a StudentDocuments
     * @example
     * // Get one StudentDocuments
     * const studentDocuments = await prisma.studentDocuments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentDocumentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentDocumentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StudentDocuments'> extends True ? Prisma__StudentDocumentsClient<StudentDocumentsGetPayload<T>> : Prisma__StudentDocumentsClient<StudentDocumentsGetPayload<T> | null, null>

    /**
     * Find one StudentDocuments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentDocumentsFindUniqueOrThrowArgs} args - Arguments to find a StudentDocuments
     * @example
     * // Get one StudentDocuments
     * const studentDocuments = await prisma.studentDocuments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentDocumentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StudentDocumentsFindUniqueOrThrowArgs>
    ): Prisma__StudentDocumentsClient<StudentDocumentsGetPayload<T>>

    /**
     * Find the first StudentDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentsFindFirstArgs} args - Arguments to find a StudentDocuments
     * @example
     * // Get one StudentDocuments
     * const studentDocuments = await prisma.studentDocuments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentDocumentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentDocumentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StudentDocuments'> extends True ? Prisma__StudentDocumentsClient<StudentDocumentsGetPayload<T>> : Prisma__StudentDocumentsClient<StudentDocumentsGetPayload<T> | null, null>

    /**
     * Find the first StudentDocuments that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentsFindFirstOrThrowArgs} args - Arguments to find a StudentDocuments
     * @example
     * // Get one StudentDocuments
     * const studentDocuments = await prisma.studentDocuments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentDocumentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StudentDocumentsFindFirstOrThrowArgs>
    ): Prisma__StudentDocumentsClient<StudentDocumentsGetPayload<T>>

    /**
     * Find zero or more StudentDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentDocuments
     * const studentDocuments = await prisma.studentDocuments.findMany()
     * 
     * // Get first 10 StudentDocuments
     * const studentDocuments = await prisma.studentDocuments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentDocumentsWithIdOnly = await prisma.studentDocuments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentDocumentsFindManyArgs>(
      args?: SelectSubset<T, StudentDocumentsFindManyArgs>
    ): PrismaPromise<Array<StudentDocumentsGetPayload<T>>>

    /**
     * Create a StudentDocuments.
     * @param {StudentDocumentsCreateArgs} args - Arguments to create a StudentDocuments.
     * @example
     * // Create one StudentDocuments
     * const StudentDocuments = await prisma.studentDocuments.create({
     *   data: {
     *     // ... data to create a StudentDocuments
     *   }
     * })
     * 
    **/
    create<T extends StudentDocumentsCreateArgs>(
      args: SelectSubset<T, StudentDocumentsCreateArgs>
    ): Prisma__StudentDocumentsClient<StudentDocumentsGetPayload<T>>

    /**
     * Create many StudentDocuments.
     *     @param {StudentDocumentsCreateManyArgs} args - Arguments to create many StudentDocuments.
     *     @example
     *     // Create many StudentDocuments
     *     const studentDocuments = await prisma.studentDocuments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentDocumentsCreateManyArgs>(
      args?: SelectSubset<T, StudentDocumentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StudentDocuments.
     * @param {StudentDocumentsDeleteArgs} args - Arguments to delete one StudentDocuments.
     * @example
     * // Delete one StudentDocuments
     * const StudentDocuments = await prisma.studentDocuments.delete({
     *   where: {
     *     // ... filter to delete one StudentDocuments
     *   }
     * })
     * 
    **/
    delete<T extends StudentDocumentsDeleteArgs>(
      args: SelectSubset<T, StudentDocumentsDeleteArgs>
    ): Prisma__StudentDocumentsClient<StudentDocumentsGetPayload<T>>

    /**
     * Update one StudentDocuments.
     * @param {StudentDocumentsUpdateArgs} args - Arguments to update one StudentDocuments.
     * @example
     * // Update one StudentDocuments
     * const studentDocuments = await prisma.studentDocuments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentDocumentsUpdateArgs>(
      args: SelectSubset<T, StudentDocumentsUpdateArgs>
    ): Prisma__StudentDocumentsClient<StudentDocumentsGetPayload<T>>

    /**
     * Delete zero or more StudentDocuments.
     * @param {StudentDocumentsDeleteManyArgs} args - Arguments to filter StudentDocuments to delete.
     * @example
     * // Delete a few StudentDocuments
     * const { count } = await prisma.studentDocuments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentDocumentsDeleteManyArgs>(
      args?: SelectSubset<T, StudentDocumentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentDocuments
     * const studentDocuments = await prisma.studentDocuments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentDocumentsUpdateManyArgs>(
      args: SelectSubset<T, StudentDocumentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentDocuments.
     * @param {StudentDocumentsUpsertArgs} args - Arguments to update or create a StudentDocuments.
     * @example
     * // Update or create a StudentDocuments
     * const studentDocuments = await prisma.studentDocuments.upsert({
     *   create: {
     *     // ... data to create a StudentDocuments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentDocuments we want to update
     *   }
     * })
    **/
    upsert<T extends StudentDocumentsUpsertArgs>(
      args: SelectSubset<T, StudentDocumentsUpsertArgs>
    ): Prisma__StudentDocumentsClient<StudentDocumentsGetPayload<T>>

    /**
     * Count the number of StudentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentsCountArgs} args - Arguments to filter StudentDocuments to count.
     * @example
     * // Count the number of StudentDocuments
     * const count = await prisma.studentDocuments.count({
     *   where: {
     *     // ... the filter for the StudentDocuments we want to count
     *   }
     * })
    **/
    count<T extends StudentDocumentsCountArgs>(
      args?: Subset<T, StudentDocumentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentDocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentDocumentsAggregateArgs>(args: Subset<T, StudentDocumentsAggregateArgs>): PrismaPromise<GetStudentDocumentsAggregateType<T>>

    /**
     * Group by StudentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentDocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentDocumentsGroupByArgs['orderBy'] }
        : { orderBy?: StudentDocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentDocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentDocumentsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentDocuments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentDocumentsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    StudentId<T extends StudentMasterArgs= {}>(args?: Subset<T, StudentMasterArgs>): Prisma__StudentMasterClient<StudentMasterGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * StudentDocuments base type for findUnique actions
   */
  export type StudentDocumentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the StudentDocuments
     */
    select?: StudentDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentDocumentsInclude | null
    /**
     * Filter, which StudentDocuments to fetch.
     */
    where: StudentDocumentsWhereUniqueInput
  }

  /**
   * StudentDocuments findUnique
   */
  export interface StudentDocumentsFindUniqueArgs extends StudentDocumentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StudentDocuments findUniqueOrThrow
   */
  export type StudentDocumentsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the StudentDocuments
     */
    select?: StudentDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentDocumentsInclude | null
    /**
     * Filter, which StudentDocuments to fetch.
     */
    where: StudentDocumentsWhereUniqueInput
  }


  /**
   * StudentDocuments base type for findFirst actions
   */
  export type StudentDocumentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the StudentDocuments
     */
    select?: StudentDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentDocumentsInclude | null
    /**
     * Filter, which StudentDocuments to fetch.
     */
    where?: StudentDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: Enumerable<StudentDocumentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentDocuments.
     */
    cursor?: StudentDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentDocuments.
     */
    distinct?: Enumerable<StudentDocumentsScalarFieldEnum>
  }

  /**
   * StudentDocuments findFirst
   */
  export interface StudentDocumentsFindFirstArgs extends StudentDocumentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StudentDocuments findFirstOrThrow
   */
  export type StudentDocumentsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the StudentDocuments
     */
    select?: StudentDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentDocumentsInclude | null
    /**
     * Filter, which StudentDocuments to fetch.
     */
    where?: StudentDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: Enumerable<StudentDocumentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentDocuments.
     */
    cursor?: StudentDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentDocuments.
     */
    distinct?: Enumerable<StudentDocumentsScalarFieldEnum>
  }


  /**
   * StudentDocuments findMany
   */
  export type StudentDocumentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the StudentDocuments
     */
    select?: StudentDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentDocumentsInclude | null
    /**
     * Filter, which StudentDocuments to fetch.
     */
    where?: StudentDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: Enumerable<StudentDocumentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentDocuments.
     */
    cursor?: StudentDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    distinct?: Enumerable<StudentDocumentsScalarFieldEnum>
  }


  /**
   * StudentDocuments create
   */
  export type StudentDocumentsCreateArgs = {
    /**
     * Select specific fields to fetch from the StudentDocuments
     */
    select?: StudentDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentDocumentsInclude | null
    /**
     * The data needed to create a StudentDocuments.
     */
    data: XOR<StudentDocumentsCreateInput, StudentDocumentsUncheckedCreateInput>
  }


  /**
   * StudentDocuments createMany
   */
  export type StudentDocumentsCreateManyArgs = {
    /**
     * The data used to create many StudentDocuments.
     */
    data: Enumerable<StudentDocumentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StudentDocuments update
   */
  export type StudentDocumentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the StudentDocuments
     */
    select?: StudentDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentDocumentsInclude | null
    /**
     * The data needed to update a StudentDocuments.
     */
    data: XOR<StudentDocumentsUpdateInput, StudentDocumentsUncheckedUpdateInput>
    /**
     * Choose, which StudentDocuments to update.
     */
    where: StudentDocumentsWhereUniqueInput
  }


  /**
   * StudentDocuments updateMany
   */
  export type StudentDocumentsUpdateManyArgs = {
    /**
     * The data used to update StudentDocuments.
     */
    data: XOR<StudentDocumentsUpdateManyMutationInput, StudentDocumentsUncheckedUpdateManyInput>
    /**
     * Filter which StudentDocuments to update
     */
    where?: StudentDocumentsWhereInput
  }


  /**
   * StudentDocuments upsert
   */
  export type StudentDocumentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the StudentDocuments
     */
    select?: StudentDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentDocumentsInclude | null
    /**
     * The filter to search for the StudentDocuments to update in case it exists.
     */
    where: StudentDocumentsWhereUniqueInput
    /**
     * In case the StudentDocuments found by the `where` argument doesn't exist, create a new StudentDocuments with this data.
     */
    create: XOR<StudentDocumentsCreateInput, StudentDocumentsUncheckedCreateInput>
    /**
     * In case the StudentDocuments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentDocumentsUpdateInput, StudentDocumentsUncheckedUpdateInput>
  }


  /**
   * StudentDocuments delete
   */
  export type StudentDocumentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the StudentDocuments
     */
    select?: StudentDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentDocumentsInclude | null
    /**
     * Filter which StudentDocuments to delete.
     */
    where: StudentDocumentsWhereUniqueInput
  }


  /**
   * StudentDocuments deleteMany
   */
  export type StudentDocumentsDeleteManyArgs = {
    /**
     * Filter which StudentDocuments to delete
     */
    where?: StudentDocumentsWhereInput
  }


  /**
   * StudentDocuments without action
   */
  export type StudentDocumentsArgs = {
    /**
     * Select specific fields to fetch from the StudentDocuments
     */
    select?: StudentDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentDocumentsInclude | null
  }



  /**
   * Model StudentAddress
   */


  export type AggregateStudentAddress = {
    _count: StudentAddressCountAggregateOutputType | null
    _min: StudentAddressMinAggregateOutputType | null
    _max: StudentAddressMaxAggregateOutputType | null
  }

  export type StudentAddressMinAggregateOutputType = {
    id: string | null
    fkStudentId: string | null
    fkCountryId: string | null
    fkStateId: string | null
    fkCityId: string | null
    Address: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAddressMaxAggregateOutputType = {
    id: string | null
    fkStudentId: string | null
    fkCountryId: string | null
    fkStateId: string | null
    fkCityId: string | null
    Address: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAddressCountAggregateOutputType = {
    id: number
    fkStudentId: number
    fkCountryId: number
    fkStateId: number
    fkCityId: number
    Address: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAddressMinAggregateInputType = {
    id?: true
    fkStudentId?: true
    fkCountryId?: true
    fkStateId?: true
    fkCityId?: true
    Address?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type StudentAddressMaxAggregateInputType = {
    id?: true
    fkStudentId?: true
    fkCountryId?: true
    fkStateId?: true
    fkCityId?: true
    Address?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type StudentAddressCountAggregateInputType = {
    id?: true
    fkStudentId?: true
    fkCountryId?: true
    fkStateId?: true
    fkCityId?: true
    Address?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAddressAggregateArgs = {
    /**
     * Filter which StudentAddress to aggregate.
     */
    where?: StudentAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAddresses to fetch.
     */
    orderBy?: Enumerable<StudentAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAddresses
    **/
    _count?: true | StudentAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAddressMaxAggregateInputType
  }

  export type GetStudentAddressAggregateType<T extends StudentAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAddress[P]>
      : GetScalarType<T[P], AggregateStudentAddress[P]>
  }




  export type StudentAddressGroupByArgs = {
    where?: StudentAddressWhereInput
    orderBy?: Enumerable<StudentAddressOrderByWithAggregationInput>
    by: StudentAddressScalarFieldEnum[]
    having?: StudentAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAddressCountAggregateInputType | true
    _min?: StudentAddressMinAggregateInputType
    _max?: StudentAddressMaxAggregateInputType
  }


  export type StudentAddressGroupByOutputType = {
    id: string
    fkStudentId: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: StudentAddressCountAggregateOutputType | null
    _min: StudentAddressMinAggregateOutputType | null
    _max: StudentAddressMaxAggregateOutputType | null
  }

  type GetStudentAddressGroupByPayload<T extends StudentAddressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StudentAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAddressGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAddressGroupByOutputType[P]>
        }
      >
    >


  export type StudentAddressSelect = {
    id?: boolean
    StudentId?: boolean | StudentMasterArgs
    fkStudentId?: boolean
    Country?: boolean | CountryArgs
    fkCountryId?: boolean
    State?: boolean | StateArgs
    fkStateId?: boolean
    City?: boolean | CityArgs
    fkCityId?: boolean
    Address?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type StudentAddressInclude = {
    StudentId?: boolean | StudentMasterArgs
    Country?: boolean | CountryArgs
    State?: boolean | StateArgs
    City?: boolean | CityArgs
  }

  export type StudentAddressGetPayload<S extends boolean | null | undefined | StudentAddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StudentAddress :
    S extends undefined ? never :
    S extends { include: any } & (StudentAddressArgs | StudentAddressFindManyArgs)
    ? StudentAddress  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'StudentId' ? StudentMasterGetPayload<S['include'][P]> :
        P extends 'Country' ? CountryGetPayload<S['include'][P]> :
        P extends 'State' ? StateGetPayload<S['include'][P]> :
        P extends 'City' ? CityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (StudentAddressArgs | StudentAddressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'StudentId' ? StudentMasterGetPayload<S['select'][P]> :
        P extends 'Country' ? CountryGetPayload<S['select'][P]> :
        P extends 'State' ? StateGetPayload<S['select'][P]> :
        P extends 'City' ? CityGetPayload<S['select'][P]> :  P extends keyof StudentAddress ? StudentAddress[P] : never
  } 
      : StudentAddress


  type StudentAddressCountArgs = 
    Omit<StudentAddressFindManyArgs, 'select' | 'include'> & {
      select?: StudentAddressCountAggregateInputType | true
    }

  export interface StudentAddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one StudentAddress that matches the filter.
     * @param {StudentAddressFindUniqueArgs} args - Arguments to find a StudentAddress
     * @example
     * // Get one StudentAddress
     * const studentAddress = await prisma.studentAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentAddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentAddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StudentAddress'> extends True ? Prisma__StudentAddressClient<StudentAddressGetPayload<T>> : Prisma__StudentAddressClient<StudentAddressGetPayload<T> | null, null>

    /**
     * Find one StudentAddress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentAddressFindUniqueOrThrowArgs} args - Arguments to find a StudentAddress
     * @example
     * // Get one StudentAddress
     * const studentAddress = await prisma.studentAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentAddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StudentAddressFindUniqueOrThrowArgs>
    ): Prisma__StudentAddressClient<StudentAddressGetPayload<T>>

    /**
     * Find the first StudentAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAddressFindFirstArgs} args - Arguments to find a StudentAddress
     * @example
     * // Get one StudentAddress
     * const studentAddress = await prisma.studentAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentAddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentAddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StudentAddress'> extends True ? Prisma__StudentAddressClient<StudentAddressGetPayload<T>> : Prisma__StudentAddressClient<StudentAddressGetPayload<T> | null, null>

    /**
     * Find the first StudentAddress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAddressFindFirstOrThrowArgs} args - Arguments to find a StudentAddress
     * @example
     * // Get one StudentAddress
     * const studentAddress = await prisma.studentAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentAddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StudentAddressFindFirstOrThrowArgs>
    ): Prisma__StudentAddressClient<StudentAddressGetPayload<T>>

    /**
     * Find zero or more StudentAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAddresses
     * const studentAddresses = await prisma.studentAddress.findMany()
     * 
     * // Get first 10 StudentAddresses
     * const studentAddresses = await prisma.studentAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentAddressWithIdOnly = await prisma.studentAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentAddressFindManyArgs>(
      args?: SelectSubset<T, StudentAddressFindManyArgs>
    ): PrismaPromise<Array<StudentAddressGetPayload<T>>>

    /**
     * Create a StudentAddress.
     * @param {StudentAddressCreateArgs} args - Arguments to create a StudentAddress.
     * @example
     * // Create one StudentAddress
     * const StudentAddress = await prisma.studentAddress.create({
     *   data: {
     *     // ... data to create a StudentAddress
     *   }
     * })
     * 
    **/
    create<T extends StudentAddressCreateArgs>(
      args: SelectSubset<T, StudentAddressCreateArgs>
    ): Prisma__StudentAddressClient<StudentAddressGetPayload<T>>

    /**
     * Create many StudentAddresses.
     *     @param {StudentAddressCreateManyArgs} args - Arguments to create many StudentAddresses.
     *     @example
     *     // Create many StudentAddresses
     *     const studentAddress = await prisma.studentAddress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentAddressCreateManyArgs>(
      args?: SelectSubset<T, StudentAddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StudentAddress.
     * @param {StudentAddressDeleteArgs} args - Arguments to delete one StudentAddress.
     * @example
     * // Delete one StudentAddress
     * const StudentAddress = await prisma.studentAddress.delete({
     *   where: {
     *     // ... filter to delete one StudentAddress
     *   }
     * })
     * 
    **/
    delete<T extends StudentAddressDeleteArgs>(
      args: SelectSubset<T, StudentAddressDeleteArgs>
    ): Prisma__StudentAddressClient<StudentAddressGetPayload<T>>

    /**
     * Update one StudentAddress.
     * @param {StudentAddressUpdateArgs} args - Arguments to update one StudentAddress.
     * @example
     * // Update one StudentAddress
     * const studentAddress = await prisma.studentAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentAddressUpdateArgs>(
      args: SelectSubset<T, StudentAddressUpdateArgs>
    ): Prisma__StudentAddressClient<StudentAddressGetPayload<T>>

    /**
     * Delete zero or more StudentAddresses.
     * @param {StudentAddressDeleteManyArgs} args - Arguments to filter StudentAddresses to delete.
     * @example
     * // Delete a few StudentAddresses
     * const { count } = await prisma.studentAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentAddressDeleteManyArgs>(
      args?: SelectSubset<T, StudentAddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAddresses
     * const studentAddress = await prisma.studentAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentAddressUpdateManyArgs>(
      args: SelectSubset<T, StudentAddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentAddress.
     * @param {StudentAddressUpsertArgs} args - Arguments to update or create a StudentAddress.
     * @example
     * // Update or create a StudentAddress
     * const studentAddress = await prisma.studentAddress.upsert({
     *   create: {
     *     // ... data to create a StudentAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAddress we want to update
     *   }
     * })
    **/
    upsert<T extends StudentAddressUpsertArgs>(
      args: SelectSubset<T, StudentAddressUpsertArgs>
    ): Prisma__StudentAddressClient<StudentAddressGetPayload<T>>

    /**
     * Count the number of StudentAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAddressCountArgs} args - Arguments to filter StudentAddresses to count.
     * @example
     * // Count the number of StudentAddresses
     * const count = await prisma.studentAddress.count({
     *   where: {
     *     // ... the filter for the StudentAddresses we want to count
     *   }
     * })
    **/
    count<T extends StudentAddressCountArgs>(
      args?: Subset<T, StudentAddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAddressAggregateArgs>(args: Subset<T, StudentAddressAggregateArgs>): PrismaPromise<GetStudentAddressAggregateType<T>>

    /**
     * Group by StudentAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAddressGroupByArgs['orderBy'] }
        : { orderBy?: StudentAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAddressGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentAddressClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    StudentId<T extends StudentMasterArgs= {}>(args?: Subset<T, StudentMasterArgs>): Prisma__StudentMasterClient<StudentMasterGetPayload<T> | Null>;

    Country<T extends CountryArgs= {}>(args?: Subset<T, CountryArgs>): Prisma__CountryClient<CountryGetPayload<T> | Null>;

    State<T extends StateArgs= {}>(args?: Subset<T, StateArgs>): Prisma__StateClient<StateGetPayload<T> | Null>;

    City<T extends CityArgs= {}>(args?: Subset<T, CityArgs>): Prisma__CityClient<CityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * StudentAddress base type for findUnique actions
   */
  export type StudentAddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    /**
     * Filter, which StudentAddress to fetch.
     */
    where: StudentAddressWhereUniqueInput
  }

  /**
   * StudentAddress findUnique
   */
  export interface StudentAddressFindUniqueArgs extends StudentAddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StudentAddress findUniqueOrThrow
   */
  export type StudentAddressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    /**
     * Filter, which StudentAddress to fetch.
     */
    where: StudentAddressWhereUniqueInput
  }


  /**
   * StudentAddress base type for findFirst actions
   */
  export type StudentAddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    /**
     * Filter, which StudentAddress to fetch.
     */
    where?: StudentAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAddresses to fetch.
     */
    orderBy?: Enumerable<StudentAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAddresses.
     */
    cursor?: StudentAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAddresses.
     */
    distinct?: Enumerable<StudentAddressScalarFieldEnum>
  }

  /**
   * StudentAddress findFirst
   */
  export interface StudentAddressFindFirstArgs extends StudentAddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StudentAddress findFirstOrThrow
   */
  export type StudentAddressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    /**
     * Filter, which StudentAddress to fetch.
     */
    where?: StudentAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAddresses to fetch.
     */
    orderBy?: Enumerable<StudentAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAddresses.
     */
    cursor?: StudentAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAddresses.
     */
    distinct?: Enumerable<StudentAddressScalarFieldEnum>
  }


  /**
   * StudentAddress findMany
   */
  export type StudentAddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    /**
     * Filter, which StudentAddresses to fetch.
     */
    where?: StudentAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAddresses to fetch.
     */
    orderBy?: Enumerable<StudentAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAddresses.
     */
    cursor?: StudentAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAddresses.
     */
    skip?: number
    distinct?: Enumerable<StudentAddressScalarFieldEnum>
  }


  /**
   * StudentAddress create
   */
  export type StudentAddressCreateArgs = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    /**
     * The data needed to create a StudentAddress.
     */
    data: XOR<StudentAddressCreateInput, StudentAddressUncheckedCreateInput>
  }


  /**
   * StudentAddress createMany
   */
  export type StudentAddressCreateManyArgs = {
    /**
     * The data used to create many StudentAddresses.
     */
    data: Enumerable<StudentAddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StudentAddress update
   */
  export type StudentAddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    /**
     * The data needed to update a StudentAddress.
     */
    data: XOR<StudentAddressUpdateInput, StudentAddressUncheckedUpdateInput>
    /**
     * Choose, which StudentAddress to update.
     */
    where: StudentAddressWhereUniqueInput
  }


  /**
   * StudentAddress updateMany
   */
  export type StudentAddressUpdateManyArgs = {
    /**
     * The data used to update StudentAddresses.
     */
    data: XOR<StudentAddressUpdateManyMutationInput, StudentAddressUncheckedUpdateManyInput>
    /**
     * Filter which StudentAddresses to update
     */
    where?: StudentAddressWhereInput
  }


  /**
   * StudentAddress upsert
   */
  export type StudentAddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    /**
     * The filter to search for the StudentAddress to update in case it exists.
     */
    where: StudentAddressWhereUniqueInput
    /**
     * In case the StudentAddress found by the `where` argument doesn't exist, create a new StudentAddress with this data.
     */
    create: XOR<StudentAddressCreateInput, StudentAddressUncheckedCreateInput>
    /**
     * In case the StudentAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAddressUpdateInput, StudentAddressUncheckedUpdateInput>
  }


  /**
   * StudentAddress delete
   */
  export type StudentAddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
    /**
     * Filter which StudentAddress to delete.
     */
    where: StudentAddressWhereUniqueInput
  }


  /**
   * StudentAddress deleteMany
   */
  export type StudentAddressDeleteManyArgs = {
    /**
     * Filter which StudentAddresses to delete
     */
    where?: StudentAddressWhereInput
  }


  /**
   * StudentAddress without action
   */
  export type StudentAddressArgs = {
    /**
     * Select specific fields to fetch from the StudentAddress
     */
    select?: StudentAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAddressInclude | null
  }



  /**
   * Model TeacherDepartment
   */


  export type AggregateTeacherDepartment = {
    _count: TeacherDepartmentCountAggregateOutputType | null
    _min: TeacherDepartmentMinAggregateOutputType | null
    _max: TeacherDepartmentMaxAggregateOutputType | null
  }

  export type TeacherDepartmentMinAggregateOutputType = {
    id: string | null
    department: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherDepartmentMaxAggregateOutputType = {
    id: string | null
    department: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherDepartmentCountAggregateOutputType = {
    id: number
    department: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherDepartmentMinAggregateInputType = {
    id?: true
    department?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type TeacherDepartmentMaxAggregateInputType = {
    id?: true
    department?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type TeacherDepartmentCountAggregateInputType = {
    id?: true
    department?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherDepartmentAggregateArgs = {
    /**
     * Filter which TeacherDepartment to aggregate.
     */
    where?: TeacherDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherDepartments to fetch.
     */
    orderBy?: Enumerable<TeacherDepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherDepartments
    **/
    _count?: true | TeacherDepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherDepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherDepartmentMaxAggregateInputType
  }

  export type GetTeacherDepartmentAggregateType<T extends TeacherDepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherDepartment[P]>
      : GetScalarType<T[P], AggregateTeacherDepartment[P]>
  }




  export type TeacherDepartmentGroupByArgs = {
    where?: TeacherDepartmentWhereInput
    orderBy?: Enumerable<TeacherDepartmentOrderByWithAggregationInput>
    by: TeacherDepartmentScalarFieldEnum[]
    having?: TeacherDepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherDepartmentCountAggregateInputType | true
    _min?: TeacherDepartmentMinAggregateInputType
    _max?: TeacherDepartmentMaxAggregateInputType
  }


  export type TeacherDepartmentGroupByOutputType = {
    id: string
    department: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: TeacherDepartmentCountAggregateOutputType | null
    _min: TeacherDepartmentMinAggregateOutputType | null
    _max: TeacherDepartmentMaxAggregateOutputType | null
  }

  type GetTeacherDepartmentGroupByPayload<T extends TeacherDepartmentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TeacherDepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherDepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherDepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherDepartmentGroupByOutputType[P]>
        }
      >
    >


  export type TeacherDepartmentSelect = {
    id?: boolean
    department?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
    TeacherMaster?: boolean | TeacherDepartment$TeacherMasterArgs
    _count?: boolean | TeacherDepartmentCountOutputTypeArgs
  }


  export type TeacherDepartmentInclude = {
    TeacherMaster?: boolean | TeacherDepartment$TeacherMasterArgs
    _count?: boolean | TeacherDepartmentCountOutputTypeArgs
  }

  export type TeacherDepartmentGetPayload<S extends boolean | null | undefined | TeacherDepartmentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TeacherDepartment :
    S extends undefined ? never :
    S extends { include: any } & (TeacherDepartmentArgs | TeacherDepartmentFindManyArgs)
    ? TeacherDepartment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'TeacherMaster' ? Array < TeacherMasterGetPayload<S['include'][P]>>  :
        P extends '_count' ? TeacherDepartmentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TeacherDepartmentArgs | TeacherDepartmentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'TeacherMaster' ? Array < TeacherMasterGetPayload<S['select'][P]>>  :
        P extends '_count' ? TeacherDepartmentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TeacherDepartment ? TeacherDepartment[P] : never
  } 
      : TeacherDepartment


  type TeacherDepartmentCountArgs = 
    Omit<TeacherDepartmentFindManyArgs, 'select' | 'include'> & {
      select?: TeacherDepartmentCountAggregateInputType | true
    }

  export interface TeacherDepartmentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TeacherDepartment that matches the filter.
     * @param {TeacherDepartmentFindUniqueArgs} args - Arguments to find a TeacherDepartment
     * @example
     * // Get one TeacherDepartment
     * const teacherDepartment = await prisma.teacherDepartment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeacherDepartmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeacherDepartmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TeacherDepartment'> extends True ? Prisma__TeacherDepartmentClient<TeacherDepartmentGetPayload<T>> : Prisma__TeacherDepartmentClient<TeacherDepartmentGetPayload<T> | null, null>

    /**
     * Find one TeacherDepartment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeacherDepartmentFindUniqueOrThrowArgs} args - Arguments to find a TeacherDepartment
     * @example
     * // Get one TeacherDepartment
     * const teacherDepartment = await prisma.teacherDepartment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeacherDepartmentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TeacherDepartmentFindUniqueOrThrowArgs>
    ): Prisma__TeacherDepartmentClient<TeacherDepartmentGetPayload<T>>

    /**
     * Find the first TeacherDepartment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDepartmentFindFirstArgs} args - Arguments to find a TeacherDepartment
     * @example
     * // Get one TeacherDepartment
     * const teacherDepartment = await prisma.teacherDepartment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeacherDepartmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeacherDepartmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TeacherDepartment'> extends True ? Prisma__TeacherDepartmentClient<TeacherDepartmentGetPayload<T>> : Prisma__TeacherDepartmentClient<TeacherDepartmentGetPayload<T> | null, null>

    /**
     * Find the first TeacherDepartment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDepartmentFindFirstOrThrowArgs} args - Arguments to find a TeacherDepartment
     * @example
     * // Get one TeacherDepartment
     * const teacherDepartment = await prisma.teacherDepartment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeacherDepartmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeacherDepartmentFindFirstOrThrowArgs>
    ): Prisma__TeacherDepartmentClient<TeacherDepartmentGetPayload<T>>

    /**
     * Find zero or more TeacherDepartments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDepartmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherDepartments
     * const teacherDepartments = await prisma.teacherDepartment.findMany()
     * 
     * // Get first 10 TeacherDepartments
     * const teacherDepartments = await prisma.teacherDepartment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherDepartmentWithIdOnly = await prisma.teacherDepartment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeacherDepartmentFindManyArgs>(
      args?: SelectSubset<T, TeacherDepartmentFindManyArgs>
    ): PrismaPromise<Array<TeacherDepartmentGetPayload<T>>>

    /**
     * Create a TeacherDepartment.
     * @param {TeacherDepartmentCreateArgs} args - Arguments to create a TeacherDepartment.
     * @example
     * // Create one TeacherDepartment
     * const TeacherDepartment = await prisma.teacherDepartment.create({
     *   data: {
     *     // ... data to create a TeacherDepartment
     *   }
     * })
     * 
    **/
    create<T extends TeacherDepartmentCreateArgs>(
      args: SelectSubset<T, TeacherDepartmentCreateArgs>
    ): Prisma__TeacherDepartmentClient<TeacherDepartmentGetPayload<T>>

    /**
     * Create many TeacherDepartments.
     *     @param {TeacherDepartmentCreateManyArgs} args - Arguments to create many TeacherDepartments.
     *     @example
     *     // Create many TeacherDepartments
     *     const teacherDepartment = await prisma.teacherDepartment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeacherDepartmentCreateManyArgs>(
      args?: SelectSubset<T, TeacherDepartmentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TeacherDepartment.
     * @param {TeacherDepartmentDeleteArgs} args - Arguments to delete one TeacherDepartment.
     * @example
     * // Delete one TeacherDepartment
     * const TeacherDepartment = await prisma.teacherDepartment.delete({
     *   where: {
     *     // ... filter to delete one TeacherDepartment
     *   }
     * })
     * 
    **/
    delete<T extends TeacherDepartmentDeleteArgs>(
      args: SelectSubset<T, TeacherDepartmentDeleteArgs>
    ): Prisma__TeacherDepartmentClient<TeacherDepartmentGetPayload<T>>

    /**
     * Update one TeacherDepartment.
     * @param {TeacherDepartmentUpdateArgs} args - Arguments to update one TeacherDepartment.
     * @example
     * // Update one TeacherDepartment
     * const teacherDepartment = await prisma.teacherDepartment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeacherDepartmentUpdateArgs>(
      args: SelectSubset<T, TeacherDepartmentUpdateArgs>
    ): Prisma__TeacherDepartmentClient<TeacherDepartmentGetPayload<T>>

    /**
     * Delete zero or more TeacherDepartments.
     * @param {TeacherDepartmentDeleteManyArgs} args - Arguments to filter TeacherDepartments to delete.
     * @example
     * // Delete a few TeacherDepartments
     * const { count } = await prisma.teacherDepartment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeacherDepartmentDeleteManyArgs>(
      args?: SelectSubset<T, TeacherDepartmentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherDepartments
     * const teacherDepartment = await prisma.teacherDepartment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeacherDepartmentUpdateManyArgs>(
      args: SelectSubset<T, TeacherDepartmentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherDepartment.
     * @param {TeacherDepartmentUpsertArgs} args - Arguments to update or create a TeacherDepartment.
     * @example
     * // Update or create a TeacherDepartment
     * const teacherDepartment = await prisma.teacherDepartment.upsert({
     *   create: {
     *     // ... data to create a TeacherDepartment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherDepartment we want to update
     *   }
     * })
    **/
    upsert<T extends TeacherDepartmentUpsertArgs>(
      args: SelectSubset<T, TeacherDepartmentUpsertArgs>
    ): Prisma__TeacherDepartmentClient<TeacherDepartmentGetPayload<T>>

    /**
     * Count the number of TeacherDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDepartmentCountArgs} args - Arguments to filter TeacherDepartments to count.
     * @example
     * // Count the number of TeacherDepartments
     * const count = await prisma.teacherDepartment.count({
     *   where: {
     *     // ... the filter for the TeacherDepartments we want to count
     *   }
     * })
    **/
    count<T extends TeacherDepartmentCountArgs>(
      args?: Subset<T, TeacherDepartmentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherDepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherDepartmentAggregateArgs>(args: Subset<T, TeacherDepartmentAggregateArgs>): PrismaPromise<GetTeacherDepartmentAggregateType<T>>

    /**
     * Group by TeacherDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherDepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherDepartmentGroupByArgs['orderBy'] }
        : { orderBy?: TeacherDepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherDepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherDepartmentGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherDepartment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeacherDepartmentClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    TeacherMaster<T extends TeacherDepartment$TeacherMasterArgs= {}>(args?: Subset<T, TeacherDepartment$TeacherMasterArgs>): PrismaPromise<Array<TeacherMasterGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TeacherDepartment base type for findUnique actions
   */
  export type TeacherDepartmentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TeacherDepartment
     */
    select?: TeacherDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDepartmentInclude | null
    /**
     * Filter, which TeacherDepartment to fetch.
     */
    where: TeacherDepartmentWhereUniqueInput
  }

  /**
   * TeacherDepartment findUnique
   */
  export interface TeacherDepartmentFindUniqueArgs extends TeacherDepartmentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeacherDepartment findUniqueOrThrow
   */
  export type TeacherDepartmentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TeacherDepartment
     */
    select?: TeacherDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDepartmentInclude | null
    /**
     * Filter, which TeacherDepartment to fetch.
     */
    where: TeacherDepartmentWhereUniqueInput
  }


  /**
   * TeacherDepartment base type for findFirst actions
   */
  export type TeacherDepartmentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TeacherDepartment
     */
    select?: TeacherDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDepartmentInclude | null
    /**
     * Filter, which TeacherDepartment to fetch.
     */
    where?: TeacherDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherDepartments to fetch.
     */
    orderBy?: Enumerable<TeacherDepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherDepartments.
     */
    cursor?: TeacherDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherDepartments.
     */
    distinct?: Enumerable<TeacherDepartmentScalarFieldEnum>
  }

  /**
   * TeacherDepartment findFirst
   */
  export interface TeacherDepartmentFindFirstArgs extends TeacherDepartmentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeacherDepartment findFirstOrThrow
   */
  export type TeacherDepartmentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TeacherDepartment
     */
    select?: TeacherDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDepartmentInclude | null
    /**
     * Filter, which TeacherDepartment to fetch.
     */
    where?: TeacherDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherDepartments to fetch.
     */
    orderBy?: Enumerable<TeacherDepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherDepartments.
     */
    cursor?: TeacherDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherDepartments.
     */
    distinct?: Enumerable<TeacherDepartmentScalarFieldEnum>
  }


  /**
   * TeacherDepartment findMany
   */
  export type TeacherDepartmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the TeacherDepartment
     */
    select?: TeacherDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDepartmentInclude | null
    /**
     * Filter, which TeacherDepartments to fetch.
     */
    where?: TeacherDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherDepartments to fetch.
     */
    orderBy?: Enumerable<TeacherDepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherDepartments.
     */
    cursor?: TeacherDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherDepartments.
     */
    skip?: number
    distinct?: Enumerable<TeacherDepartmentScalarFieldEnum>
  }


  /**
   * TeacherDepartment create
   */
  export type TeacherDepartmentCreateArgs = {
    /**
     * Select specific fields to fetch from the TeacherDepartment
     */
    select?: TeacherDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDepartmentInclude | null
    /**
     * The data needed to create a TeacherDepartment.
     */
    data: XOR<TeacherDepartmentCreateInput, TeacherDepartmentUncheckedCreateInput>
  }


  /**
   * TeacherDepartment createMany
   */
  export type TeacherDepartmentCreateManyArgs = {
    /**
     * The data used to create many TeacherDepartments.
     */
    data: Enumerable<TeacherDepartmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TeacherDepartment update
   */
  export type TeacherDepartmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the TeacherDepartment
     */
    select?: TeacherDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDepartmentInclude | null
    /**
     * The data needed to update a TeacherDepartment.
     */
    data: XOR<TeacherDepartmentUpdateInput, TeacherDepartmentUncheckedUpdateInput>
    /**
     * Choose, which TeacherDepartment to update.
     */
    where: TeacherDepartmentWhereUniqueInput
  }


  /**
   * TeacherDepartment updateMany
   */
  export type TeacherDepartmentUpdateManyArgs = {
    /**
     * The data used to update TeacherDepartments.
     */
    data: XOR<TeacherDepartmentUpdateManyMutationInput, TeacherDepartmentUncheckedUpdateManyInput>
    /**
     * Filter which TeacherDepartments to update
     */
    where?: TeacherDepartmentWhereInput
  }


  /**
   * TeacherDepartment upsert
   */
  export type TeacherDepartmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the TeacherDepartment
     */
    select?: TeacherDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDepartmentInclude | null
    /**
     * The filter to search for the TeacherDepartment to update in case it exists.
     */
    where: TeacherDepartmentWhereUniqueInput
    /**
     * In case the TeacherDepartment found by the `where` argument doesn't exist, create a new TeacherDepartment with this data.
     */
    create: XOR<TeacherDepartmentCreateInput, TeacherDepartmentUncheckedCreateInput>
    /**
     * In case the TeacherDepartment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherDepartmentUpdateInput, TeacherDepartmentUncheckedUpdateInput>
  }


  /**
   * TeacherDepartment delete
   */
  export type TeacherDepartmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the TeacherDepartment
     */
    select?: TeacherDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDepartmentInclude | null
    /**
     * Filter which TeacherDepartment to delete.
     */
    where: TeacherDepartmentWhereUniqueInput
  }


  /**
   * TeacherDepartment deleteMany
   */
  export type TeacherDepartmentDeleteManyArgs = {
    /**
     * Filter which TeacherDepartments to delete
     */
    where?: TeacherDepartmentWhereInput
  }


  /**
   * TeacherDepartment.TeacherMaster
   */
  export type TeacherDepartment$TeacherMasterArgs = {
    /**
     * Select specific fields to fetch from the TeacherMaster
     */
    select?: TeacherMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherMasterInclude | null
    where?: TeacherMasterWhereInput
    orderBy?: Enumerable<TeacherMasterOrderByWithRelationInput>
    cursor?: TeacherMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherMasterScalarFieldEnum>
  }


  /**
   * TeacherDepartment without action
   */
  export type TeacherDepartmentArgs = {
    /**
     * Select specific fields to fetch from the TeacherDepartment
     */
    select?: TeacherDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDepartmentInclude | null
  }



  /**
   * Model TeacherMaster
   */


  export type AggregateTeacherMaster = {
    _count: TeacherMasterCountAggregateOutputType | null
    _min: TeacherMasterMinAggregateOutputType | null
    _max: TeacherMasterMaxAggregateOutputType | null
  }

  export type TeacherMasterMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    password: string | null
    gender: string | null
    dob: Date | null
    teacherId: string | null
    fkTeacherDepartmentId: string | null
    profileImg: string | null
    joiningDate: Date | null
    fkDesignationId: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherMasterMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    password: string | null
    gender: string | null
    dob: Date | null
    teacherId: string | null
    fkTeacherDepartmentId: string | null
    profileImg: string | null
    joiningDate: Date | null
    fkDesignationId: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherMasterCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    password: number
    gender: number
    dob: number
    teacherId: number
    fkTeacherDepartmentId: number
    profileImg: number
    joiningDate: number
    fkDesignationId: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherMasterMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    password?: true
    gender?: true
    dob?: true
    teacherId?: true
    fkTeacherDepartmentId?: true
    profileImg?: true
    joiningDate?: true
    fkDesignationId?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type TeacherMasterMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    password?: true
    gender?: true
    dob?: true
    teacherId?: true
    fkTeacherDepartmentId?: true
    profileImg?: true
    joiningDate?: true
    fkDesignationId?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type TeacherMasterCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    password?: true
    gender?: true
    dob?: true
    teacherId?: true
    fkTeacherDepartmentId?: true
    profileImg?: true
    joiningDate?: true
    fkDesignationId?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherMasterAggregateArgs = {
    /**
     * Filter which TeacherMaster to aggregate.
     */
    where?: TeacherMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherMasters to fetch.
     */
    orderBy?: Enumerable<TeacherMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherMasters
    **/
    _count?: true | TeacherMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMasterMaxAggregateInputType
  }

  export type GetTeacherMasterAggregateType<T extends TeacherMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherMaster[P]>
      : GetScalarType<T[P], AggregateTeacherMaster[P]>
  }




  export type TeacherMasterGroupByArgs = {
    where?: TeacherMasterWhereInput
    orderBy?: Enumerable<TeacherMasterOrderByWithAggregationInput>
    by: TeacherMasterScalarFieldEnum[]
    having?: TeacherMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherMasterCountAggregateInputType | true
    _min?: TeacherMasterMinAggregateInputType
    _max?: TeacherMasterMaxAggregateInputType
  }


  export type TeacherMasterGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date
    teacherId: string
    fkTeacherDepartmentId: string
    profileImg: string
    joiningDate: Date
    fkDesignationId: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: TeacherMasterCountAggregateOutputType | null
    _min: TeacherMasterMinAggregateOutputType | null
    _max: TeacherMasterMaxAggregateOutputType | null
  }

  type GetTeacherMasterGroupByPayload<T extends TeacherMasterGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TeacherMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherMasterGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherMasterGroupByOutputType[P]>
        }
      >
    >


  export type TeacherMasterSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    gender?: boolean
    dob?: boolean
    teacherId?: boolean
    Teacherdepartment?: boolean | TeacherDepartmentArgs
    fkTeacherDepartmentId?: boolean
    profileImg?: boolean
    joiningDate?: boolean
    designation?: boolean | DesignationArgs
    fkDesignationId?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
    TeacherDocuments?: boolean | TeacherMaster$TeacherDocumentsArgs
    TeacherAddress?: boolean | TeacherMaster$TeacherAddressArgs
    TeacherExprience?: boolean | TeacherMaster$TeacherExprienceArgs
    _count?: boolean | TeacherMasterCountOutputTypeArgs
  }


  export type TeacherMasterInclude = {
    Teacherdepartment?: boolean | TeacherDepartmentArgs
    designation?: boolean | DesignationArgs
    TeacherDocuments?: boolean | TeacherMaster$TeacherDocumentsArgs
    TeacherAddress?: boolean | TeacherMaster$TeacherAddressArgs
    TeacherExprience?: boolean | TeacherMaster$TeacherExprienceArgs
    _count?: boolean | TeacherMasterCountOutputTypeArgs
  }

  export type TeacherMasterGetPayload<S extends boolean | null | undefined | TeacherMasterArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TeacherMaster :
    S extends undefined ? never :
    S extends { include: any } & (TeacherMasterArgs | TeacherMasterFindManyArgs)
    ? TeacherMaster  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Teacherdepartment' ? TeacherDepartmentGetPayload<S['include'][P]> :
        P extends 'designation' ? DesignationGetPayload<S['include'][P]> :
        P extends 'TeacherDocuments' ? Array < TeacherDocumentsGetPayload<S['include'][P]>>  :
        P extends 'TeacherAddress' ? Array < TeacherAddressGetPayload<S['include'][P]>>  :
        P extends 'TeacherExprience' ? Array < TeacherExprienceGetPayload<S['include'][P]>>  :
        P extends '_count' ? TeacherMasterCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TeacherMasterArgs | TeacherMasterFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Teacherdepartment' ? TeacherDepartmentGetPayload<S['select'][P]> :
        P extends 'designation' ? DesignationGetPayload<S['select'][P]> :
        P extends 'TeacherDocuments' ? Array < TeacherDocumentsGetPayload<S['select'][P]>>  :
        P extends 'TeacherAddress' ? Array < TeacherAddressGetPayload<S['select'][P]>>  :
        P extends 'TeacherExprience' ? Array < TeacherExprienceGetPayload<S['select'][P]>>  :
        P extends '_count' ? TeacherMasterCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TeacherMaster ? TeacherMaster[P] : never
  } 
      : TeacherMaster


  type TeacherMasterCountArgs = 
    Omit<TeacherMasterFindManyArgs, 'select' | 'include'> & {
      select?: TeacherMasterCountAggregateInputType | true
    }

  export interface TeacherMasterDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TeacherMaster that matches the filter.
     * @param {TeacherMasterFindUniqueArgs} args - Arguments to find a TeacherMaster
     * @example
     * // Get one TeacherMaster
     * const teacherMaster = await prisma.teacherMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeacherMasterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeacherMasterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TeacherMaster'> extends True ? Prisma__TeacherMasterClient<TeacherMasterGetPayload<T>> : Prisma__TeacherMasterClient<TeacherMasterGetPayload<T> | null, null>

    /**
     * Find one TeacherMaster that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeacherMasterFindUniqueOrThrowArgs} args - Arguments to find a TeacherMaster
     * @example
     * // Get one TeacherMaster
     * const teacherMaster = await prisma.teacherMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeacherMasterFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TeacherMasterFindUniqueOrThrowArgs>
    ): Prisma__TeacherMasterClient<TeacherMasterGetPayload<T>>

    /**
     * Find the first TeacherMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherMasterFindFirstArgs} args - Arguments to find a TeacherMaster
     * @example
     * // Get one TeacherMaster
     * const teacherMaster = await prisma.teacherMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeacherMasterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeacherMasterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TeacherMaster'> extends True ? Prisma__TeacherMasterClient<TeacherMasterGetPayload<T>> : Prisma__TeacherMasterClient<TeacherMasterGetPayload<T> | null, null>

    /**
     * Find the first TeacherMaster that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherMasterFindFirstOrThrowArgs} args - Arguments to find a TeacherMaster
     * @example
     * // Get one TeacherMaster
     * const teacherMaster = await prisma.teacherMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeacherMasterFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeacherMasterFindFirstOrThrowArgs>
    ): Prisma__TeacherMasterClient<TeacherMasterGetPayload<T>>

    /**
     * Find zero or more TeacherMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherMasterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherMasters
     * const teacherMasters = await prisma.teacherMaster.findMany()
     * 
     * // Get first 10 TeacherMasters
     * const teacherMasters = await prisma.teacherMaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherMasterWithIdOnly = await prisma.teacherMaster.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeacherMasterFindManyArgs>(
      args?: SelectSubset<T, TeacherMasterFindManyArgs>
    ): PrismaPromise<Array<TeacherMasterGetPayload<T>>>

    /**
     * Create a TeacherMaster.
     * @param {TeacherMasterCreateArgs} args - Arguments to create a TeacherMaster.
     * @example
     * // Create one TeacherMaster
     * const TeacherMaster = await prisma.teacherMaster.create({
     *   data: {
     *     // ... data to create a TeacherMaster
     *   }
     * })
     * 
    **/
    create<T extends TeacherMasterCreateArgs>(
      args: SelectSubset<T, TeacherMasterCreateArgs>
    ): Prisma__TeacherMasterClient<TeacherMasterGetPayload<T>>

    /**
     * Create many TeacherMasters.
     *     @param {TeacherMasterCreateManyArgs} args - Arguments to create many TeacherMasters.
     *     @example
     *     // Create many TeacherMasters
     *     const teacherMaster = await prisma.teacherMaster.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeacherMasterCreateManyArgs>(
      args?: SelectSubset<T, TeacherMasterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TeacherMaster.
     * @param {TeacherMasterDeleteArgs} args - Arguments to delete one TeacherMaster.
     * @example
     * // Delete one TeacherMaster
     * const TeacherMaster = await prisma.teacherMaster.delete({
     *   where: {
     *     // ... filter to delete one TeacherMaster
     *   }
     * })
     * 
    **/
    delete<T extends TeacherMasterDeleteArgs>(
      args: SelectSubset<T, TeacherMasterDeleteArgs>
    ): Prisma__TeacherMasterClient<TeacherMasterGetPayload<T>>

    /**
     * Update one TeacherMaster.
     * @param {TeacherMasterUpdateArgs} args - Arguments to update one TeacherMaster.
     * @example
     * // Update one TeacherMaster
     * const teacherMaster = await prisma.teacherMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeacherMasterUpdateArgs>(
      args: SelectSubset<T, TeacherMasterUpdateArgs>
    ): Prisma__TeacherMasterClient<TeacherMasterGetPayload<T>>

    /**
     * Delete zero or more TeacherMasters.
     * @param {TeacherMasterDeleteManyArgs} args - Arguments to filter TeacherMasters to delete.
     * @example
     * // Delete a few TeacherMasters
     * const { count } = await prisma.teacherMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeacherMasterDeleteManyArgs>(
      args?: SelectSubset<T, TeacherMasterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherMasters
     * const teacherMaster = await prisma.teacherMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeacherMasterUpdateManyArgs>(
      args: SelectSubset<T, TeacherMasterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherMaster.
     * @param {TeacherMasterUpsertArgs} args - Arguments to update or create a TeacherMaster.
     * @example
     * // Update or create a TeacherMaster
     * const teacherMaster = await prisma.teacherMaster.upsert({
     *   create: {
     *     // ... data to create a TeacherMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherMaster we want to update
     *   }
     * })
    **/
    upsert<T extends TeacherMasterUpsertArgs>(
      args: SelectSubset<T, TeacherMasterUpsertArgs>
    ): Prisma__TeacherMasterClient<TeacherMasterGetPayload<T>>

    /**
     * Count the number of TeacherMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherMasterCountArgs} args - Arguments to filter TeacherMasters to count.
     * @example
     * // Count the number of TeacherMasters
     * const count = await prisma.teacherMaster.count({
     *   where: {
     *     // ... the filter for the TeacherMasters we want to count
     *   }
     * })
    **/
    count<T extends TeacherMasterCountArgs>(
      args?: Subset<T, TeacherMasterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherMasterAggregateArgs>(args: Subset<T, TeacherMasterAggregateArgs>): PrismaPromise<GetTeacherMasterAggregateType<T>>

    /**
     * Group by TeacherMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherMasterGroupByArgs['orderBy'] }
        : { orderBy?: TeacherMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherMasterGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeacherMasterClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Teacherdepartment<T extends TeacherDepartmentArgs= {}>(args?: Subset<T, TeacherDepartmentArgs>): Prisma__TeacherDepartmentClient<TeacherDepartmentGetPayload<T> | Null>;

    designation<T extends DesignationArgs= {}>(args?: Subset<T, DesignationArgs>): Prisma__DesignationClient<DesignationGetPayload<T> | Null>;

    TeacherDocuments<T extends TeacherMaster$TeacherDocumentsArgs= {}>(args?: Subset<T, TeacherMaster$TeacherDocumentsArgs>): PrismaPromise<Array<TeacherDocumentsGetPayload<T>>| Null>;

    TeacherAddress<T extends TeacherMaster$TeacherAddressArgs= {}>(args?: Subset<T, TeacherMaster$TeacherAddressArgs>): PrismaPromise<Array<TeacherAddressGetPayload<T>>| Null>;

    TeacherExprience<T extends TeacherMaster$TeacherExprienceArgs= {}>(args?: Subset<T, TeacherMaster$TeacherExprienceArgs>): PrismaPromise<Array<TeacherExprienceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TeacherMaster base type for findUnique actions
   */
  export type TeacherMasterFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TeacherMaster
     */
    select?: TeacherMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherMasterInclude | null
    /**
     * Filter, which TeacherMaster to fetch.
     */
    where: TeacherMasterWhereUniqueInput
  }

  /**
   * TeacherMaster findUnique
   */
  export interface TeacherMasterFindUniqueArgs extends TeacherMasterFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeacherMaster findUniqueOrThrow
   */
  export type TeacherMasterFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TeacherMaster
     */
    select?: TeacherMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherMasterInclude | null
    /**
     * Filter, which TeacherMaster to fetch.
     */
    where: TeacherMasterWhereUniqueInput
  }


  /**
   * TeacherMaster base type for findFirst actions
   */
  export type TeacherMasterFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TeacherMaster
     */
    select?: TeacherMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherMasterInclude | null
    /**
     * Filter, which TeacherMaster to fetch.
     */
    where?: TeacherMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherMasters to fetch.
     */
    orderBy?: Enumerable<TeacherMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherMasters.
     */
    cursor?: TeacherMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherMasters.
     */
    distinct?: Enumerable<TeacherMasterScalarFieldEnum>
  }

  /**
   * TeacherMaster findFirst
   */
  export interface TeacherMasterFindFirstArgs extends TeacherMasterFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeacherMaster findFirstOrThrow
   */
  export type TeacherMasterFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TeacherMaster
     */
    select?: TeacherMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherMasterInclude | null
    /**
     * Filter, which TeacherMaster to fetch.
     */
    where?: TeacherMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherMasters to fetch.
     */
    orderBy?: Enumerable<TeacherMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherMasters.
     */
    cursor?: TeacherMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherMasters.
     */
    distinct?: Enumerable<TeacherMasterScalarFieldEnum>
  }


  /**
   * TeacherMaster findMany
   */
  export type TeacherMasterFindManyArgs = {
    /**
     * Select specific fields to fetch from the TeacherMaster
     */
    select?: TeacherMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherMasterInclude | null
    /**
     * Filter, which TeacherMasters to fetch.
     */
    where?: TeacherMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherMasters to fetch.
     */
    orderBy?: Enumerable<TeacherMasterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherMasters.
     */
    cursor?: TeacherMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherMasters.
     */
    skip?: number
    distinct?: Enumerable<TeacherMasterScalarFieldEnum>
  }


  /**
   * TeacherMaster create
   */
  export type TeacherMasterCreateArgs = {
    /**
     * Select specific fields to fetch from the TeacherMaster
     */
    select?: TeacherMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherMasterInclude | null
    /**
     * The data needed to create a TeacherMaster.
     */
    data: XOR<TeacherMasterCreateInput, TeacherMasterUncheckedCreateInput>
  }


  /**
   * TeacherMaster createMany
   */
  export type TeacherMasterCreateManyArgs = {
    /**
     * The data used to create many TeacherMasters.
     */
    data: Enumerable<TeacherMasterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TeacherMaster update
   */
  export type TeacherMasterUpdateArgs = {
    /**
     * Select specific fields to fetch from the TeacherMaster
     */
    select?: TeacherMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherMasterInclude | null
    /**
     * The data needed to update a TeacherMaster.
     */
    data: XOR<TeacherMasterUpdateInput, TeacherMasterUncheckedUpdateInput>
    /**
     * Choose, which TeacherMaster to update.
     */
    where: TeacherMasterWhereUniqueInput
  }


  /**
   * TeacherMaster updateMany
   */
  export type TeacherMasterUpdateManyArgs = {
    /**
     * The data used to update TeacherMasters.
     */
    data: XOR<TeacherMasterUpdateManyMutationInput, TeacherMasterUncheckedUpdateManyInput>
    /**
     * Filter which TeacherMasters to update
     */
    where?: TeacherMasterWhereInput
  }


  /**
   * TeacherMaster upsert
   */
  export type TeacherMasterUpsertArgs = {
    /**
     * Select specific fields to fetch from the TeacherMaster
     */
    select?: TeacherMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherMasterInclude | null
    /**
     * The filter to search for the TeacherMaster to update in case it exists.
     */
    where: TeacherMasterWhereUniqueInput
    /**
     * In case the TeacherMaster found by the `where` argument doesn't exist, create a new TeacherMaster with this data.
     */
    create: XOR<TeacherMasterCreateInput, TeacherMasterUncheckedCreateInput>
    /**
     * In case the TeacherMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherMasterUpdateInput, TeacherMasterUncheckedUpdateInput>
  }


  /**
   * TeacherMaster delete
   */
  export type TeacherMasterDeleteArgs = {
    /**
     * Select specific fields to fetch from the TeacherMaster
     */
    select?: TeacherMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherMasterInclude | null
    /**
     * Filter which TeacherMaster to delete.
     */
    where: TeacherMasterWhereUniqueInput
  }


  /**
   * TeacherMaster deleteMany
   */
  export type TeacherMasterDeleteManyArgs = {
    /**
     * Filter which TeacherMasters to delete
     */
    where?: TeacherMasterWhereInput
  }


  /**
   * TeacherMaster.TeacherDocuments
   */
  export type TeacherMaster$TeacherDocumentsArgs = {
    /**
     * Select specific fields to fetch from the TeacherDocuments
     */
    select?: TeacherDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDocumentsInclude | null
    where?: TeacherDocumentsWhereInput
    orderBy?: Enumerable<TeacherDocumentsOrderByWithRelationInput>
    cursor?: TeacherDocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherDocumentsScalarFieldEnum>
  }


  /**
   * TeacherMaster.TeacherAddress
   */
  export type TeacherMaster$TeacherAddressArgs = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    where?: TeacherAddressWhereInput
    orderBy?: Enumerable<TeacherAddressOrderByWithRelationInput>
    cursor?: TeacherAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherAddressScalarFieldEnum>
  }


  /**
   * TeacherMaster.TeacherExprience
   */
  export type TeacherMaster$TeacherExprienceArgs = {
    /**
     * Select specific fields to fetch from the TeacherExprience
     */
    select?: TeacherExprienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherExprienceInclude | null
    where?: TeacherExprienceWhereInput
    orderBy?: Enumerable<TeacherExprienceOrderByWithRelationInput>
    cursor?: TeacherExprienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherExprienceScalarFieldEnum>
  }


  /**
   * TeacherMaster without action
   */
  export type TeacherMasterArgs = {
    /**
     * Select specific fields to fetch from the TeacherMaster
     */
    select?: TeacherMasterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherMasterInclude | null
  }



  /**
   * Model TeacherExprience
   */


  export type AggregateTeacherExprience = {
    _count: TeacherExprienceCountAggregateOutputType | null
    _min: TeacherExprienceMinAggregateOutputType | null
    _max: TeacherExprienceMaxAggregateOutputType | null
  }

  export type TeacherExprienceMinAggregateOutputType = {
    id: string | null
    fkTeacherId: string | null
    experience: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherExprienceMaxAggregateOutputType = {
    id: string | null
    fkTeacherId: string | null
    experience: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherExprienceCountAggregateOutputType = {
    id: number
    fkTeacherId: number
    skills: number
    experience: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherExprienceMinAggregateInputType = {
    id?: true
    fkTeacherId?: true
    experience?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type TeacherExprienceMaxAggregateInputType = {
    id?: true
    fkTeacherId?: true
    experience?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type TeacherExprienceCountAggregateInputType = {
    id?: true
    fkTeacherId?: true
    skills?: true
    experience?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherExprienceAggregateArgs = {
    /**
     * Filter which TeacherExprience to aggregate.
     */
    where?: TeacherExprienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherExpriences to fetch.
     */
    orderBy?: Enumerable<TeacherExprienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherExprienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherExpriences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherExpriences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherExpriences
    **/
    _count?: true | TeacherExprienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherExprienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherExprienceMaxAggregateInputType
  }

  export type GetTeacherExprienceAggregateType<T extends TeacherExprienceAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherExprience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherExprience[P]>
      : GetScalarType<T[P], AggregateTeacherExprience[P]>
  }




  export type TeacherExprienceGroupByArgs = {
    where?: TeacherExprienceWhereInput
    orderBy?: Enumerable<TeacherExprienceOrderByWithAggregationInput>
    by: TeacherExprienceScalarFieldEnum[]
    having?: TeacherExprienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherExprienceCountAggregateInputType | true
    _min?: TeacherExprienceMinAggregateInputType
    _max?: TeacherExprienceMaxAggregateInputType
  }


  export type TeacherExprienceGroupByOutputType = {
    id: string
    fkTeacherId: string
    skills: JsonValue[]
    experience: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: TeacherExprienceCountAggregateOutputType | null
    _min: TeacherExprienceMinAggregateOutputType | null
    _max: TeacherExprienceMaxAggregateOutputType | null
  }

  type GetTeacherExprienceGroupByPayload<T extends TeacherExprienceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TeacherExprienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherExprienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherExprienceGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherExprienceGroupByOutputType[P]>
        }
      >
    >


  export type TeacherExprienceSelect = {
    id?: boolean
    TeacherId?: boolean | TeacherMasterArgs
    fkTeacherId?: boolean
    skills?: boolean
    experience?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type TeacherExprienceInclude = {
    TeacherId?: boolean | TeacherMasterArgs
  }

  export type TeacherExprienceGetPayload<S extends boolean | null | undefined | TeacherExprienceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TeacherExprience :
    S extends undefined ? never :
    S extends { include: any } & (TeacherExprienceArgs | TeacherExprienceFindManyArgs)
    ? TeacherExprience  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'TeacherId' ? TeacherMasterGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TeacherExprienceArgs | TeacherExprienceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'TeacherId' ? TeacherMasterGetPayload<S['select'][P]> :  P extends keyof TeacherExprience ? TeacherExprience[P] : never
  } 
      : TeacherExprience


  type TeacherExprienceCountArgs = 
    Omit<TeacherExprienceFindManyArgs, 'select' | 'include'> & {
      select?: TeacherExprienceCountAggregateInputType | true
    }

  export interface TeacherExprienceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TeacherExprience that matches the filter.
     * @param {TeacherExprienceFindUniqueArgs} args - Arguments to find a TeacherExprience
     * @example
     * // Get one TeacherExprience
     * const teacherExprience = await prisma.teacherExprience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeacherExprienceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeacherExprienceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TeacherExprience'> extends True ? Prisma__TeacherExprienceClient<TeacherExprienceGetPayload<T>> : Prisma__TeacherExprienceClient<TeacherExprienceGetPayload<T> | null, null>

    /**
     * Find one TeacherExprience that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeacherExprienceFindUniqueOrThrowArgs} args - Arguments to find a TeacherExprience
     * @example
     * // Get one TeacherExprience
     * const teacherExprience = await prisma.teacherExprience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeacherExprienceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TeacherExprienceFindUniqueOrThrowArgs>
    ): Prisma__TeacherExprienceClient<TeacherExprienceGetPayload<T>>

    /**
     * Find the first TeacherExprience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherExprienceFindFirstArgs} args - Arguments to find a TeacherExprience
     * @example
     * // Get one TeacherExprience
     * const teacherExprience = await prisma.teacherExprience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeacherExprienceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeacherExprienceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TeacherExprience'> extends True ? Prisma__TeacherExprienceClient<TeacherExprienceGetPayload<T>> : Prisma__TeacherExprienceClient<TeacherExprienceGetPayload<T> | null, null>

    /**
     * Find the first TeacherExprience that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherExprienceFindFirstOrThrowArgs} args - Arguments to find a TeacherExprience
     * @example
     * // Get one TeacherExprience
     * const teacherExprience = await prisma.teacherExprience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeacherExprienceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeacherExprienceFindFirstOrThrowArgs>
    ): Prisma__TeacherExprienceClient<TeacherExprienceGetPayload<T>>

    /**
     * Find zero or more TeacherExpriences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherExprienceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherExpriences
     * const teacherExpriences = await prisma.teacherExprience.findMany()
     * 
     * // Get first 10 TeacherExpriences
     * const teacherExpriences = await prisma.teacherExprience.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherExprienceWithIdOnly = await prisma.teacherExprience.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeacherExprienceFindManyArgs>(
      args?: SelectSubset<T, TeacherExprienceFindManyArgs>
    ): PrismaPromise<Array<TeacherExprienceGetPayload<T>>>

    /**
     * Create a TeacherExprience.
     * @param {TeacherExprienceCreateArgs} args - Arguments to create a TeacherExprience.
     * @example
     * // Create one TeacherExprience
     * const TeacherExprience = await prisma.teacherExprience.create({
     *   data: {
     *     // ... data to create a TeacherExprience
     *   }
     * })
     * 
    **/
    create<T extends TeacherExprienceCreateArgs>(
      args: SelectSubset<T, TeacherExprienceCreateArgs>
    ): Prisma__TeacherExprienceClient<TeacherExprienceGetPayload<T>>

    /**
     * Create many TeacherExpriences.
     *     @param {TeacherExprienceCreateManyArgs} args - Arguments to create many TeacherExpriences.
     *     @example
     *     // Create many TeacherExpriences
     *     const teacherExprience = await prisma.teacherExprience.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeacherExprienceCreateManyArgs>(
      args?: SelectSubset<T, TeacherExprienceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TeacherExprience.
     * @param {TeacherExprienceDeleteArgs} args - Arguments to delete one TeacherExprience.
     * @example
     * // Delete one TeacherExprience
     * const TeacherExprience = await prisma.teacherExprience.delete({
     *   where: {
     *     // ... filter to delete one TeacherExprience
     *   }
     * })
     * 
    **/
    delete<T extends TeacherExprienceDeleteArgs>(
      args: SelectSubset<T, TeacherExprienceDeleteArgs>
    ): Prisma__TeacherExprienceClient<TeacherExprienceGetPayload<T>>

    /**
     * Update one TeacherExprience.
     * @param {TeacherExprienceUpdateArgs} args - Arguments to update one TeacherExprience.
     * @example
     * // Update one TeacherExprience
     * const teacherExprience = await prisma.teacherExprience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeacherExprienceUpdateArgs>(
      args: SelectSubset<T, TeacherExprienceUpdateArgs>
    ): Prisma__TeacherExprienceClient<TeacherExprienceGetPayload<T>>

    /**
     * Delete zero or more TeacherExpriences.
     * @param {TeacherExprienceDeleteManyArgs} args - Arguments to filter TeacherExpriences to delete.
     * @example
     * // Delete a few TeacherExpriences
     * const { count } = await prisma.teacherExprience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeacherExprienceDeleteManyArgs>(
      args?: SelectSubset<T, TeacherExprienceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherExpriences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherExprienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherExpriences
     * const teacherExprience = await prisma.teacherExprience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeacherExprienceUpdateManyArgs>(
      args: SelectSubset<T, TeacherExprienceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherExprience.
     * @param {TeacherExprienceUpsertArgs} args - Arguments to update or create a TeacherExprience.
     * @example
     * // Update or create a TeacherExprience
     * const teacherExprience = await prisma.teacherExprience.upsert({
     *   create: {
     *     // ... data to create a TeacherExprience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherExprience we want to update
     *   }
     * })
    **/
    upsert<T extends TeacherExprienceUpsertArgs>(
      args: SelectSubset<T, TeacherExprienceUpsertArgs>
    ): Prisma__TeacherExprienceClient<TeacherExprienceGetPayload<T>>

    /**
     * Count the number of TeacherExpriences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherExprienceCountArgs} args - Arguments to filter TeacherExpriences to count.
     * @example
     * // Count the number of TeacherExpriences
     * const count = await prisma.teacherExprience.count({
     *   where: {
     *     // ... the filter for the TeacherExpriences we want to count
     *   }
     * })
    **/
    count<T extends TeacherExprienceCountArgs>(
      args?: Subset<T, TeacherExprienceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherExprienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherExprience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherExprienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherExprienceAggregateArgs>(args: Subset<T, TeacherExprienceAggregateArgs>): PrismaPromise<GetTeacherExprienceAggregateType<T>>

    /**
     * Group by TeacherExprience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherExprienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherExprienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherExprienceGroupByArgs['orderBy'] }
        : { orderBy?: TeacherExprienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherExprienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherExprienceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherExprience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeacherExprienceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    TeacherId<T extends TeacherMasterArgs= {}>(args?: Subset<T, TeacherMasterArgs>): Prisma__TeacherMasterClient<TeacherMasterGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TeacherExprience base type for findUnique actions
   */
  export type TeacherExprienceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TeacherExprience
     */
    select?: TeacherExprienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherExprienceInclude | null
    /**
     * Filter, which TeacherExprience to fetch.
     */
    where: TeacherExprienceWhereUniqueInput
  }

  /**
   * TeacherExprience findUnique
   */
  export interface TeacherExprienceFindUniqueArgs extends TeacherExprienceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeacherExprience findUniqueOrThrow
   */
  export type TeacherExprienceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TeacherExprience
     */
    select?: TeacherExprienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherExprienceInclude | null
    /**
     * Filter, which TeacherExprience to fetch.
     */
    where: TeacherExprienceWhereUniqueInput
  }


  /**
   * TeacherExprience base type for findFirst actions
   */
  export type TeacherExprienceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TeacherExprience
     */
    select?: TeacherExprienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherExprienceInclude | null
    /**
     * Filter, which TeacherExprience to fetch.
     */
    where?: TeacherExprienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherExpriences to fetch.
     */
    orderBy?: Enumerable<TeacherExprienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherExpriences.
     */
    cursor?: TeacherExprienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherExpriences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherExpriences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherExpriences.
     */
    distinct?: Enumerable<TeacherExprienceScalarFieldEnum>
  }

  /**
   * TeacherExprience findFirst
   */
  export interface TeacherExprienceFindFirstArgs extends TeacherExprienceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeacherExprience findFirstOrThrow
   */
  export type TeacherExprienceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TeacherExprience
     */
    select?: TeacherExprienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherExprienceInclude | null
    /**
     * Filter, which TeacherExprience to fetch.
     */
    where?: TeacherExprienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherExpriences to fetch.
     */
    orderBy?: Enumerable<TeacherExprienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherExpriences.
     */
    cursor?: TeacherExprienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherExpriences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherExpriences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherExpriences.
     */
    distinct?: Enumerable<TeacherExprienceScalarFieldEnum>
  }


  /**
   * TeacherExprience findMany
   */
  export type TeacherExprienceFindManyArgs = {
    /**
     * Select specific fields to fetch from the TeacherExprience
     */
    select?: TeacherExprienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherExprienceInclude | null
    /**
     * Filter, which TeacherExpriences to fetch.
     */
    where?: TeacherExprienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherExpriences to fetch.
     */
    orderBy?: Enumerable<TeacherExprienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherExpriences.
     */
    cursor?: TeacherExprienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherExpriences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherExpriences.
     */
    skip?: number
    distinct?: Enumerable<TeacherExprienceScalarFieldEnum>
  }


  /**
   * TeacherExprience create
   */
  export type TeacherExprienceCreateArgs = {
    /**
     * Select specific fields to fetch from the TeacherExprience
     */
    select?: TeacherExprienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherExprienceInclude | null
    /**
     * The data needed to create a TeacherExprience.
     */
    data: XOR<TeacherExprienceCreateInput, TeacherExprienceUncheckedCreateInput>
  }


  /**
   * TeacherExprience createMany
   */
  export type TeacherExprienceCreateManyArgs = {
    /**
     * The data used to create many TeacherExpriences.
     */
    data: Enumerable<TeacherExprienceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TeacherExprience update
   */
  export type TeacherExprienceUpdateArgs = {
    /**
     * Select specific fields to fetch from the TeacherExprience
     */
    select?: TeacherExprienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherExprienceInclude | null
    /**
     * The data needed to update a TeacherExprience.
     */
    data: XOR<TeacherExprienceUpdateInput, TeacherExprienceUncheckedUpdateInput>
    /**
     * Choose, which TeacherExprience to update.
     */
    where: TeacherExprienceWhereUniqueInput
  }


  /**
   * TeacherExprience updateMany
   */
  export type TeacherExprienceUpdateManyArgs = {
    /**
     * The data used to update TeacherExpriences.
     */
    data: XOR<TeacherExprienceUpdateManyMutationInput, TeacherExprienceUncheckedUpdateManyInput>
    /**
     * Filter which TeacherExpriences to update
     */
    where?: TeacherExprienceWhereInput
  }


  /**
   * TeacherExprience upsert
   */
  export type TeacherExprienceUpsertArgs = {
    /**
     * Select specific fields to fetch from the TeacherExprience
     */
    select?: TeacherExprienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherExprienceInclude | null
    /**
     * The filter to search for the TeacherExprience to update in case it exists.
     */
    where: TeacherExprienceWhereUniqueInput
    /**
     * In case the TeacherExprience found by the `where` argument doesn't exist, create a new TeacherExprience with this data.
     */
    create: XOR<TeacherExprienceCreateInput, TeacherExprienceUncheckedCreateInput>
    /**
     * In case the TeacherExprience was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherExprienceUpdateInput, TeacherExprienceUncheckedUpdateInput>
  }


  /**
   * TeacherExprience delete
   */
  export type TeacherExprienceDeleteArgs = {
    /**
     * Select specific fields to fetch from the TeacherExprience
     */
    select?: TeacherExprienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherExprienceInclude | null
    /**
     * Filter which TeacherExprience to delete.
     */
    where: TeacherExprienceWhereUniqueInput
  }


  /**
   * TeacherExprience deleteMany
   */
  export type TeacherExprienceDeleteManyArgs = {
    /**
     * Filter which TeacherExpriences to delete
     */
    where?: TeacherExprienceWhereInput
  }


  /**
   * TeacherExprience without action
   */
  export type TeacherExprienceArgs = {
    /**
     * Select specific fields to fetch from the TeacherExprience
     */
    select?: TeacherExprienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherExprienceInclude | null
  }



  /**
   * Model TeacherDocuments
   */


  export type AggregateTeacherDocuments = {
    _count: TeacherDocumentsCountAggregateOutputType | null
    _min: TeacherDocumentsMinAggregateOutputType | null
    _max: TeacherDocumentsMaxAggregateOutputType | null
  }

  export type TeacherDocumentsMinAggregateOutputType = {
    id: string | null
    fkTeacherId: string | null
    category: string | null
    docUrl: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherDocumentsMaxAggregateOutputType = {
    id: string | null
    fkTeacherId: string | null
    category: string | null
    docUrl: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherDocumentsCountAggregateOutputType = {
    id: number
    fkTeacherId: number
    category: number
    docUrl: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherDocumentsMinAggregateInputType = {
    id?: true
    fkTeacherId?: true
    category?: true
    docUrl?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type TeacherDocumentsMaxAggregateInputType = {
    id?: true
    fkTeacherId?: true
    category?: true
    docUrl?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type TeacherDocumentsCountAggregateInputType = {
    id?: true
    fkTeacherId?: true
    category?: true
    docUrl?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherDocumentsAggregateArgs = {
    /**
     * Filter which TeacherDocuments to aggregate.
     */
    where?: TeacherDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherDocuments to fetch.
     */
    orderBy?: Enumerable<TeacherDocumentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherDocuments
    **/
    _count?: true | TeacherDocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherDocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherDocumentsMaxAggregateInputType
  }

  export type GetTeacherDocumentsAggregateType<T extends TeacherDocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherDocuments[P]>
      : GetScalarType<T[P], AggregateTeacherDocuments[P]>
  }




  export type TeacherDocumentsGroupByArgs = {
    where?: TeacherDocumentsWhereInput
    orderBy?: Enumerable<TeacherDocumentsOrderByWithAggregationInput>
    by: TeacherDocumentsScalarFieldEnum[]
    having?: TeacherDocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherDocumentsCountAggregateInputType | true
    _min?: TeacherDocumentsMinAggregateInputType
    _max?: TeacherDocumentsMaxAggregateInputType
  }


  export type TeacherDocumentsGroupByOutputType = {
    id: string
    fkTeacherId: string
    category: string
    docUrl: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: TeacherDocumentsCountAggregateOutputType | null
    _min: TeacherDocumentsMinAggregateOutputType | null
    _max: TeacherDocumentsMaxAggregateOutputType | null
  }

  type GetTeacherDocumentsGroupByPayload<T extends TeacherDocumentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TeacherDocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherDocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherDocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherDocumentsGroupByOutputType[P]>
        }
      >
    >


  export type TeacherDocumentsSelect = {
    id?: boolean
    TeacherId?: boolean | TeacherMasterArgs
    fkTeacherId?: boolean
    category?: boolean
    docUrl?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type TeacherDocumentsInclude = {
    TeacherId?: boolean | TeacherMasterArgs
  }

  export type TeacherDocumentsGetPayload<S extends boolean | null | undefined | TeacherDocumentsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TeacherDocuments :
    S extends undefined ? never :
    S extends { include: any } & (TeacherDocumentsArgs | TeacherDocumentsFindManyArgs)
    ? TeacherDocuments  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'TeacherId' ? TeacherMasterGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TeacherDocumentsArgs | TeacherDocumentsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'TeacherId' ? TeacherMasterGetPayload<S['select'][P]> :  P extends keyof TeacherDocuments ? TeacherDocuments[P] : never
  } 
      : TeacherDocuments


  type TeacherDocumentsCountArgs = 
    Omit<TeacherDocumentsFindManyArgs, 'select' | 'include'> & {
      select?: TeacherDocumentsCountAggregateInputType | true
    }

  export interface TeacherDocumentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TeacherDocuments that matches the filter.
     * @param {TeacherDocumentsFindUniqueArgs} args - Arguments to find a TeacherDocuments
     * @example
     * // Get one TeacherDocuments
     * const teacherDocuments = await prisma.teacherDocuments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeacherDocumentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeacherDocumentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TeacherDocuments'> extends True ? Prisma__TeacherDocumentsClient<TeacherDocumentsGetPayload<T>> : Prisma__TeacherDocumentsClient<TeacherDocumentsGetPayload<T> | null, null>

    /**
     * Find one TeacherDocuments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeacherDocumentsFindUniqueOrThrowArgs} args - Arguments to find a TeacherDocuments
     * @example
     * // Get one TeacherDocuments
     * const teacherDocuments = await prisma.teacherDocuments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeacherDocumentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TeacherDocumentsFindUniqueOrThrowArgs>
    ): Prisma__TeacherDocumentsClient<TeacherDocumentsGetPayload<T>>

    /**
     * Find the first TeacherDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDocumentsFindFirstArgs} args - Arguments to find a TeacherDocuments
     * @example
     * // Get one TeacherDocuments
     * const teacherDocuments = await prisma.teacherDocuments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeacherDocumentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeacherDocumentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TeacherDocuments'> extends True ? Prisma__TeacherDocumentsClient<TeacherDocumentsGetPayload<T>> : Prisma__TeacherDocumentsClient<TeacherDocumentsGetPayload<T> | null, null>

    /**
     * Find the first TeacherDocuments that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDocumentsFindFirstOrThrowArgs} args - Arguments to find a TeacherDocuments
     * @example
     * // Get one TeacherDocuments
     * const teacherDocuments = await prisma.teacherDocuments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeacherDocumentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeacherDocumentsFindFirstOrThrowArgs>
    ): Prisma__TeacherDocumentsClient<TeacherDocumentsGetPayload<T>>

    /**
     * Find zero or more TeacherDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDocumentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherDocuments
     * const teacherDocuments = await prisma.teacherDocuments.findMany()
     * 
     * // Get first 10 TeacherDocuments
     * const teacherDocuments = await prisma.teacherDocuments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherDocumentsWithIdOnly = await prisma.teacherDocuments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeacherDocumentsFindManyArgs>(
      args?: SelectSubset<T, TeacherDocumentsFindManyArgs>
    ): PrismaPromise<Array<TeacherDocumentsGetPayload<T>>>

    /**
     * Create a TeacherDocuments.
     * @param {TeacherDocumentsCreateArgs} args - Arguments to create a TeacherDocuments.
     * @example
     * // Create one TeacherDocuments
     * const TeacherDocuments = await prisma.teacherDocuments.create({
     *   data: {
     *     // ... data to create a TeacherDocuments
     *   }
     * })
     * 
    **/
    create<T extends TeacherDocumentsCreateArgs>(
      args: SelectSubset<T, TeacherDocumentsCreateArgs>
    ): Prisma__TeacherDocumentsClient<TeacherDocumentsGetPayload<T>>

    /**
     * Create many TeacherDocuments.
     *     @param {TeacherDocumentsCreateManyArgs} args - Arguments to create many TeacherDocuments.
     *     @example
     *     // Create many TeacherDocuments
     *     const teacherDocuments = await prisma.teacherDocuments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeacherDocumentsCreateManyArgs>(
      args?: SelectSubset<T, TeacherDocumentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TeacherDocuments.
     * @param {TeacherDocumentsDeleteArgs} args - Arguments to delete one TeacherDocuments.
     * @example
     * // Delete one TeacherDocuments
     * const TeacherDocuments = await prisma.teacherDocuments.delete({
     *   where: {
     *     // ... filter to delete one TeacherDocuments
     *   }
     * })
     * 
    **/
    delete<T extends TeacherDocumentsDeleteArgs>(
      args: SelectSubset<T, TeacherDocumentsDeleteArgs>
    ): Prisma__TeacherDocumentsClient<TeacherDocumentsGetPayload<T>>

    /**
     * Update one TeacherDocuments.
     * @param {TeacherDocumentsUpdateArgs} args - Arguments to update one TeacherDocuments.
     * @example
     * // Update one TeacherDocuments
     * const teacherDocuments = await prisma.teacherDocuments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeacherDocumentsUpdateArgs>(
      args: SelectSubset<T, TeacherDocumentsUpdateArgs>
    ): Prisma__TeacherDocumentsClient<TeacherDocumentsGetPayload<T>>

    /**
     * Delete zero or more TeacherDocuments.
     * @param {TeacherDocumentsDeleteManyArgs} args - Arguments to filter TeacherDocuments to delete.
     * @example
     * // Delete a few TeacherDocuments
     * const { count } = await prisma.teacherDocuments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeacherDocumentsDeleteManyArgs>(
      args?: SelectSubset<T, TeacherDocumentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherDocuments
     * const teacherDocuments = await prisma.teacherDocuments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeacherDocumentsUpdateManyArgs>(
      args: SelectSubset<T, TeacherDocumentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherDocuments.
     * @param {TeacherDocumentsUpsertArgs} args - Arguments to update or create a TeacherDocuments.
     * @example
     * // Update or create a TeacherDocuments
     * const teacherDocuments = await prisma.teacherDocuments.upsert({
     *   create: {
     *     // ... data to create a TeacherDocuments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherDocuments we want to update
     *   }
     * })
    **/
    upsert<T extends TeacherDocumentsUpsertArgs>(
      args: SelectSubset<T, TeacherDocumentsUpsertArgs>
    ): Prisma__TeacherDocumentsClient<TeacherDocumentsGetPayload<T>>

    /**
     * Count the number of TeacherDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDocumentsCountArgs} args - Arguments to filter TeacherDocuments to count.
     * @example
     * // Count the number of TeacherDocuments
     * const count = await prisma.teacherDocuments.count({
     *   where: {
     *     // ... the filter for the TeacherDocuments we want to count
     *   }
     * })
    **/
    count<T extends TeacherDocumentsCountArgs>(
      args?: Subset<T, TeacherDocumentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherDocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherDocumentsAggregateArgs>(args: Subset<T, TeacherDocumentsAggregateArgs>): PrismaPromise<GetTeacherDocumentsAggregateType<T>>

    /**
     * Group by TeacherDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherDocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherDocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherDocumentsGroupByArgs['orderBy'] }
        : { orderBy?: TeacherDocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherDocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherDocumentsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherDocuments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeacherDocumentsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    TeacherId<T extends TeacherMasterArgs= {}>(args?: Subset<T, TeacherMasterArgs>): Prisma__TeacherMasterClient<TeacherMasterGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TeacherDocuments base type for findUnique actions
   */
  export type TeacherDocumentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TeacherDocuments
     */
    select?: TeacherDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDocumentsInclude | null
    /**
     * Filter, which TeacherDocuments to fetch.
     */
    where: TeacherDocumentsWhereUniqueInput
  }

  /**
   * TeacherDocuments findUnique
   */
  export interface TeacherDocumentsFindUniqueArgs extends TeacherDocumentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeacherDocuments findUniqueOrThrow
   */
  export type TeacherDocumentsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TeacherDocuments
     */
    select?: TeacherDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDocumentsInclude | null
    /**
     * Filter, which TeacherDocuments to fetch.
     */
    where: TeacherDocumentsWhereUniqueInput
  }


  /**
   * TeacherDocuments base type for findFirst actions
   */
  export type TeacherDocumentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TeacherDocuments
     */
    select?: TeacherDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDocumentsInclude | null
    /**
     * Filter, which TeacherDocuments to fetch.
     */
    where?: TeacherDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherDocuments to fetch.
     */
    orderBy?: Enumerable<TeacherDocumentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherDocuments.
     */
    cursor?: TeacherDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherDocuments.
     */
    distinct?: Enumerable<TeacherDocumentsScalarFieldEnum>
  }

  /**
   * TeacherDocuments findFirst
   */
  export interface TeacherDocumentsFindFirstArgs extends TeacherDocumentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeacherDocuments findFirstOrThrow
   */
  export type TeacherDocumentsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TeacherDocuments
     */
    select?: TeacherDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDocumentsInclude | null
    /**
     * Filter, which TeacherDocuments to fetch.
     */
    where?: TeacherDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherDocuments to fetch.
     */
    orderBy?: Enumerable<TeacherDocumentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherDocuments.
     */
    cursor?: TeacherDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherDocuments.
     */
    distinct?: Enumerable<TeacherDocumentsScalarFieldEnum>
  }


  /**
   * TeacherDocuments findMany
   */
  export type TeacherDocumentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the TeacherDocuments
     */
    select?: TeacherDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDocumentsInclude | null
    /**
     * Filter, which TeacherDocuments to fetch.
     */
    where?: TeacherDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherDocuments to fetch.
     */
    orderBy?: Enumerable<TeacherDocumentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherDocuments.
     */
    cursor?: TeacherDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherDocuments.
     */
    skip?: number
    distinct?: Enumerable<TeacherDocumentsScalarFieldEnum>
  }


  /**
   * TeacherDocuments create
   */
  export type TeacherDocumentsCreateArgs = {
    /**
     * Select specific fields to fetch from the TeacherDocuments
     */
    select?: TeacherDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDocumentsInclude | null
    /**
     * The data needed to create a TeacherDocuments.
     */
    data: XOR<TeacherDocumentsCreateInput, TeacherDocumentsUncheckedCreateInput>
  }


  /**
   * TeacherDocuments createMany
   */
  export type TeacherDocumentsCreateManyArgs = {
    /**
     * The data used to create many TeacherDocuments.
     */
    data: Enumerable<TeacherDocumentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TeacherDocuments update
   */
  export type TeacherDocumentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the TeacherDocuments
     */
    select?: TeacherDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDocumentsInclude | null
    /**
     * The data needed to update a TeacherDocuments.
     */
    data: XOR<TeacherDocumentsUpdateInput, TeacherDocumentsUncheckedUpdateInput>
    /**
     * Choose, which TeacherDocuments to update.
     */
    where: TeacherDocumentsWhereUniqueInput
  }


  /**
   * TeacherDocuments updateMany
   */
  export type TeacherDocumentsUpdateManyArgs = {
    /**
     * The data used to update TeacherDocuments.
     */
    data: XOR<TeacherDocumentsUpdateManyMutationInput, TeacherDocumentsUncheckedUpdateManyInput>
    /**
     * Filter which TeacherDocuments to update
     */
    where?: TeacherDocumentsWhereInput
  }


  /**
   * TeacherDocuments upsert
   */
  export type TeacherDocumentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the TeacherDocuments
     */
    select?: TeacherDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDocumentsInclude | null
    /**
     * The filter to search for the TeacherDocuments to update in case it exists.
     */
    where: TeacherDocumentsWhereUniqueInput
    /**
     * In case the TeacherDocuments found by the `where` argument doesn't exist, create a new TeacherDocuments with this data.
     */
    create: XOR<TeacherDocumentsCreateInput, TeacherDocumentsUncheckedCreateInput>
    /**
     * In case the TeacherDocuments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherDocumentsUpdateInput, TeacherDocumentsUncheckedUpdateInput>
  }


  /**
   * TeacherDocuments delete
   */
  export type TeacherDocumentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the TeacherDocuments
     */
    select?: TeacherDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDocumentsInclude | null
    /**
     * Filter which TeacherDocuments to delete.
     */
    where: TeacherDocumentsWhereUniqueInput
  }


  /**
   * TeacherDocuments deleteMany
   */
  export type TeacherDocumentsDeleteManyArgs = {
    /**
     * Filter which TeacherDocuments to delete
     */
    where?: TeacherDocumentsWhereInput
  }


  /**
   * TeacherDocuments without action
   */
  export type TeacherDocumentsArgs = {
    /**
     * Select specific fields to fetch from the TeacherDocuments
     */
    select?: TeacherDocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherDocumentsInclude | null
  }



  /**
   * Model TeacherAddress
   */


  export type AggregateTeacherAddress = {
    _count: TeacherAddressCountAggregateOutputType | null
    _min: TeacherAddressMinAggregateOutputType | null
    _max: TeacherAddressMaxAggregateOutputType | null
  }

  export type TeacherAddressMinAggregateOutputType = {
    id: string | null
    fkTeacherId: string | null
    fkCountryId: string | null
    fkStateId: string | null
    fkCityId: string | null
    Address: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherAddressMaxAggregateOutputType = {
    id: string | null
    fkTeacherId: string | null
    fkCountryId: string | null
    fkStateId: string | null
    fkCityId: string | null
    Address: string | null
    status: boolean | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherAddressCountAggregateOutputType = {
    id: number
    fkTeacherId: number
    fkCountryId: number
    fkStateId: number
    fkCityId: number
    Address: number
    status: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherAddressMinAggregateInputType = {
    id?: true
    fkTeacherId?: true
    fkCountryId?: true
    fkStateId?: true
    fkCityId?: true
    Address?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type TeacherAddressMaxAggregateInputType = {
    id?: true
    fkTeacherId?: true
    fkCountryId?: true
    fkStateId?: true
    fkCityId?: true
    Address?: true
    status?: true
    createAt?: true
    updatedAt?: true
  }

  export type TeacherAddressCountAggregateInputType = {
    id?: true
    fkTeacherId?: true
    fkCountryId?: true
    fkStateId?: true
    fkCityId?: true
    Address?: true
    status?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherAddressAggregateArgs = {
    /**
     * Filter which TeacherAddress to aggregate.
     */
    where?: TeacherAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherAddresses to fetch.
     */
    orderBy?: Enumerable<TeacherAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherAddresses
    **/
    _count?: true | TeacherAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherAddressMaxAggregateInputType
  }

  export type GetTeacherAddressAggregateType<T extends TeacherAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherAddress[P]>
      : GetScalarType<T[P], AggregateTeacherAddress[P]>
  }




  export type TeacherAddressGroupByArgs = {
    where?: TeacherAddressWhereInput
    orderBy?: Enumerable<TeacherAddressOrderByWithAggregationInput>
    by: TeacherAddressScalarFieldEnum[]
    having?: TeacherAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherAddressCountAggregateInputType | true
    _min?: TeacherAddressMinAggregateInputType
    _max?: TeacherAddressMaxAggregateInputType
  }


  export type TeacherAddressGroupByOutputType = {
    id: string
    fkTeacherId: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt: Date
    updatedAt: Date
    _count: TeacherAddressCountAggregateOutputType | null
    _min: TeacherAddressMinAggregateOutputType | null
    _max: TeacherAddressMaxAggregateOutputType | null
  }

  type GetTeacherAddressGroupByPayload<T extends TeacherAddressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TeacherAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherAddressGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherAddressGroupByOutputType[P]>
        }
      >
    >


  export type TeacherAddressSelect = {
    id?: boolean
    TeacherId?: boolean | TeacherMasterArgs
    fkTeacherId?: boolean
    Country?: boolean | CountryArgs
    fkCountryId?: boolean
    State?: boolean | StateArgs
    fkStateId?: boolean
    City?: boolean | CityArgs
    fkCityId?: boolean
    Address?: boolean
    status?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type TeacherAddressInclude = {
    TeacherId?: boolean | TeacherMasterArgs
    Country?: boolean | CountryArgs
    State?: boolean | StateArgs
    City?: boolean | CityArgs
  }

  export type TeacherAddressGetPayload<S extends boolean | null | undefined | TeacherAddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TeacherAddress :
    S extends undefined ? never :
    S extends { include: any } & (TeacherAddressArgs | TeacherAddressFindManyArgs)
    ? TeacherAddress  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'TeacherId' ? TeacherMasterGetPayload<S['include'][P]> :
        P extends 'Country' ? CountryGetPayload<S['include'][P]> :
        P extends 'State' ? StateGetPayload<S['include'][P]> :
        P extends 'City' ? CityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TeacherAddressArgs | TeacherAddressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'TeacherId' ? TeacherMasterGetPayload<S['select'][P]> :
        P extends 'Country' ? CountryGetPayload<S['select'][P]> :
        P extends 'State' ? StateGetPayload<S['select'][P]> :
        P extends 'City' ? CityGetPayload<S['select'][P]> :  P extends keyof TeacherAddress ? TeacherAddress[P] : never
  } 
      : TeacherAddress


  type TeacherAddressCountArgs = 
    Omit<TeacherAddressFindManyArgs, 'select' | 'include'> & {
      select?: TeacherAddressCountAggregateInputType | true
    }

  export interface TeacherAddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TeacherAddress that matches the filter.
     * @param {TeacherAddressFindUniqueArgs} args - Arguments to find a TeacherAddress
     * @example
     * // Get one TeacherAddress
     * const teacherAddress = await prisma.teacherAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeacherAddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeacherAddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TeacherAddress'> extends True ? Prisma__TeacherAddressClient<TeacherAddressGetPayload<T>> : Prisma__TeacherAddressClient<TeacherAddressGetPayload<T> | null, null>

    /**
     * Find one TeacherAddress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeacherAddressFindUniqueOrThrowArgs} args - Arguments to find a TeacherAddress
     * @example
     * // Get one TeacherAddress
     * const teacherAddress = await prisma.teacherAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeacherAddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TeacherAddressFindUniqueOrThrowArgs>
    ): Prisma__TeacherAddressClient<TeacherAddressGetPayload<T>>

    /**
     * Find the first TeacherAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAddressFindFirstArgs} args - Arguments to find a TeacherAddress
     * @example
     * // Get one TeacherAddress
     * const teacherAddress = await prisma.teacherAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeacherAddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeacherAddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TeacherAddress'> extends True ? Prisma__TeacherAddressClient<TeacherAddressGetPayload<T>> : Prisma__TeacherAddressClient<TeacherAddressGetPayload<T> | null, null>

    /**
     * Find the first TeacherAddress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAddressFindFirstOrThrowArgs} args - Arguments to find a TeacherAddress
     * @example
     * // Get one TeacherAddress
     * const teacherAddress = await prisma.teacherAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeacherAddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeacherAddressFindFirstOrThrowArgs>
    ): Prisma__TeacherAddressClient<TeacherAddressGetPayload<T>>

    /**
     * Find zero or more TeacherAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherAddresses
     * const teacherAddresses = await prisma.teacherAddress.findMany()
     * 
     * // Get first 10 TeacherAddresses
     * const teacherAddresses = await prisma.teacherAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherAddressWithIdOnly = await prisma.teacherAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeacherAddressFindManyArgs>(
      args?: SelectSubset<T, TeacherAddressFindManyArgs>
    ): PrismaPromise<Array<TeacherAddressGetPayload<T>>>

    /**
     * Create a TeacherAddress.
     * @param {TeacherAddressCreateArgs} args - Arguments to create a TeacherAddress.
     * @example
     * // Create one TeacherAddress
     * const TeacherAddress = await prisma.teacherAddress.create({
     *   data: {
     *     // ... data to create a TeacherAddress
     *   }
     * })
     * 
    **/
    create<T extends TeacherAddressCreateArgs>(
      args: SelectSubset<T, TeacherAddressCreateArgs>
    ): Prisma__TeacherAddressClient<TeacherAddressGetPayload<T>>

    /**
     * Create many TeacherAddresses.
     *     @param {TeacherAddressCreateManyArgs} args - Arguments to create many TeacherAddresses.
     *     @example
     *     // Create many TeacherAddresses
     *     const teacherAddress = await prisma.teacherAddress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeacherAddressCreateManyArgs>(
      args?: SelectSubset<T, TeacherAddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TeacherAddress.
     * @param {TeacherAddressDeleteArgs} args - Arguments to delete one TeacherAddress.
     * @example
     * // Delete one TeacherAddress
     * const TeacherAddress = await prisma.teacherAddress.delete({
     *   where: {
     *     // ... filter to delete one TeacherAddress
     *   }
     * })
     * 
    **/
    delete<T extends TeacherAddressDeleteArgs>(
      args: SelectSubset<T, TeacherAddressDeleteArgs>
    ): Prisma__TeacherAddressClient<TeacherAddressGetPayload<T>>

    /**
     * Update one TeacherAddress.
     * @param {TeacherAddressUpdateArgs} args - Arguments to update one TeacherAddress.
     * @example
     * // Update one TeacherAddress
     * const teacherAddress = await prisma.teacherAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeacherAddressUpdateArgs>(
      args: SelectSubset<T, TeacherAddressUpdateArgs>
    ): Prisma__TeacherAddressClient<TeacherAddressGetPayload<T>>

    /**
     * Delete zero or more TeacherAddresses.
     * @param {TeacherAddressDeleteManyArgs} args - Arguments to filter TeacherAddresses to delete.
     * @example
     * // Delete a few TeacherAddresses
     * const { count } = await prisma.teacherAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeacherAddressDeleteManyArgs>(
      args?: SelectSubset<T, TeacherAddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherAddresses
     * const teacherAddress = await prisma.teacherAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeacherAddressUpdateManyArgs>(
      args: SelectSubset<T, TeacherAddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherAddress.
     * @param {TeacherAddressUpsertArgs} args - Arguments to update or create a TeacherAddress.
     * @example
     * // Update or create a TeacherAddress
     * const teacherAddress = await prisma.teacherAddress.upsert({
     *   create: {
     *     // ... data to create a TeacherAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherAddress we want to update
     *   }
     * })
    **/
    upsert<T extends TeacherAddressUpsertArgs>(
      args: SelectSubset<T, TeacherAddressUpsertArgs>
    ): Prisma__TeacherAddressClient<TeacherAddressGetPayload<T>>

    /**
     * Count the number of TeacherAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAddressCountArgs} args - Arguments to filter TeacherAddresses to count.
     * @example
     * // Count the number of TeacherAddresses
     * const count = await prisma.teacherAddress.count({
     *   where: {
     *     // ... the filter for the TeacherAddresses we want to count
     *   }
     * })
    **/
    count<T extends TeacherAddressCountArgs>(
      args?: Subset<T, TeacherAddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAddressAggregateArgs>(args: Subset<T, TeacherAddressAggregateArgs>): PrismaPromise<GetTeacherAddressAggregateType<T>>

    /**
     * Group by TeacherAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherAddressGroupByArgs['orderBy'] }
        : { orderBy?: TeacherAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherAddressGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeacherAddressClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    TeacherId<T extends TeacherMasterArgs= {}>(args?: Subset<T, TeacherMasterArgs>): Prisma__TeacherMasterClient<TeacherMasterGetPayload<T> | Null>;

    Country<T extends CountryArgs= {}>(args?: Subset<T, CountryArgs>): Prisma__CountryClient<CountryGetPayload<T> | Null>;

    State<T extends StateArgs= {}>(args?: Subset<T, StateArgs>): Prisma__StateClient<StateGetPayload<T> | Null>;

    City<T extends CityArgs= {}>(args?: Subset<T, CityArgs>): Prisma__CityClient<CityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TeacherAddress base type for findUnique actions
   */
  export type TeacherAddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    /**
     * Filter, which TeacherAddress to fetch.
     */
    where: TeacherAddressWhereUniqueInput
  }

  /**
   * TeacherAddress findUnique
   */
  export interface TeacherAddressFindUniqueArgs extends TeacherAddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeacherAddress findUniqueOrThrow
   */
  export type TeacherAddressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    /**
     * Filter, which TeacherAddress to fetch.
     */
    where: TeacherAddressWhereUniqueInput
  }


  /**
   * TeacherAddress base type for findFirst actions
   */
  export type TeacherAddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    /**
     * Filter, which TeacherAddress to fetch.
     */
    where?: TeacherAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherAddresses to fetch.
     */
    orderBy?: Enumerable<TeacherAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherAddresses.
     */
    cursor?: TeacherAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherAddresses.
     */
    distinct?: Enumerable<TeacherAddressScalarFieldEnum>
  }

  /**
   * TeacherAddress findFirst
   */
  export interface TeacherAddressFindFirstArgs extends TeacherAddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeacherAddress findFirstOrThrow
   */
  export type TeacherAddressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    /**
     * Filter, which TeacherAddress to fetch.
     */
    where?: TeacherAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherAddresses to fetch.
     */
    orderBy?: Enumerable<TeacherAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherAddresses.
     */
    cursor?: TeacherAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherAddresses.
     */
    distinct?: Enumerable<TeacherAddressScalarFieldEnum>
  }


  /**
   * TeacherAddress findMany
   */
  export type TeacherAddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    /**
     * Filter, which TeacherAddresses to fetch.
     */
    where?: TeacherAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherAddresses to fetch.
     */
    orderBy?: Enumerable<TeacherAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherAddresses.
     */
    cursor?: TeacherAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherAddresses.
     */
    skip?: number
    distinct?: Enumerable<TeacherAddressScalarFieldEnum>
  }


  /**
   * TeacherAddress create
   */
  export type TeacherAddressCreateArgs = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    /**
     * The data needed to create a TeacherAddress.
     */
    data: XOR<TeacherAddressCreateInput, TeacherAddressUncheckedCreateInput>
  }


  /**
   * TeacherAddress createMany
   */
  export type TeacherAddressCreateManyArgs = {
    /**
     * The data used to create many TeacherAddresses.
     */
    data: Enumerable<TeacherAddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TeacherAddress update
   */
  export type TeacherAddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    /**
     * The data needed to update a TeacherAddress.
     */
    data: XOR<TeacherAddressUpdateInput, TeacherAddressUncheckedUpdateInput>
    /**
     * Choose, which TeacherAddress to update.
     */
    where: TeacherAddressWhereUniqueInput
  }


  /**
   * TeacherAddress updateMany
   */
  export type TeacherAddressUpdateManyArgs = {
    /**
     * The data used to update TeacherAddresses.
     */
    data: XOR<TeacherAddressUpdateManyMutationInput, TeacherAddressUncheckedUpdateManyInput>
    /**
     * Filter which TeacherAddresses to update
     */
    where?: TeacherAddressWhereInput
  }


  /**
   * TeacherAddress upsert
   */
  export type TeacherAddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    /**
     * The filter to search for the TeacherAddress to update in case it exists.
     */
    where: TeacherAddressWhereUniqueInput
    /**
     * In case the TeacherAddress found by the `where` argument doesn't exist, create a new TeacherAddress with this data.
     */
    create: XOR<TeacherAddressCreateInput, TeacherAddressUncheckedCreateInput>
    /**
     * In case the TeacherAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherAddressUpdateInput, TeacherAddressUncheckedUpdateInput>
  }


  /**
   * TeacherAddress delete
   */
  export type TeacherAddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
    /**
     * Filter which TeacherAddress to delete.
     */
    where: TeacherAddressWhereUniqueInput
  }


  /**
   * TeacherAddress deleteMany
   */
  export type TeacherAddressDeleteManyArgs = {
    /**
     * Filter which TeacherAddresses to delete
     */
    where?: TeacherAddressWhereInput
  }


  /**
   * TeacherAddress without action
   */
  export type TeacherAddressArgs = {
    /**
     * Select specific fields to fetch from the TeacherAddress
     */
    select?: TeacherAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherAddressInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AdminScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    CityName: 'CityName',
    fkStateId: 'fkStateId',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const ClassmasterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type ClassmasterScalarFieldEnum = (typeof ClassmasterScalarFieldEnum)[keyof typeof ClassmasterScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    CounrtyName: 'CounrtyName',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const DesignationScalarFieldEnum: {
    id: 'id',
    roles: 'roles',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type DesignationScalarFieldEnum = (typeof DesignationScalarFieldEnum)[keyof typeof DesignationScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SalesTeamAddressScalarFieldEnum: {
    id: 'id',
    fkSalesTeamId: 'fkSalesTeamId',
    fkCountryId: 'fkCountryId',
    fkStateId: 'fkStateId',
    fkCityId: 'fkCityId',
    Address: 'Address',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type SalesTeamAddressScalarFieldEnum = (typeof SalesTeamAddressScalarFieldEnum)[keyof typeof SalesTeamAddressScalarFieldEnum]


  export const SalesTeamDocumentsScalarFieldEnum: {
    id: 'id',
    fkSalesTeamId: 'fkSalesTeamId',
    category: 'category',
    comment: 'comment',
    url: 'url',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type SalesTeamDocumentsScalarFieldEnum = (typeof SalesTeamDocumentsScalarFieldEnum)[keyof typeof SalesTeamDocumentsScalarFieldEnum]


  export const SalesTeamScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    password: 'password',
    dob: 'dob',
    fkDesignationId: 'fkDesignationId',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type SalesTeamScalarFieldEnum = (typeof SalesTeamScalarFieldEnum)[keyof typeof SalesTeamScalarFieldEnum]


  export const SchoolBoardScalarFieldEnum: {
    id: 'id',
    boardname: 'boardname',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolBoardScalarFieldEnum = (typeof SchoolBoardScalarFieldEnum)[keyof typeof SchoolBoardScalarFieldEnum]


  export const SchoolMasterAddressScalarFieldEnum: {
    id: 'id',
    fkSchoolId: 'fkSchoolId',
    fkCountryId: 'fkCountryId',
    fkStateId: 'fkStateId',
    fkCityId: 'fkCityId',
    Address: 'Address',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolMasterAddressScalarFieldEnum = (typeof SchoolMasterAddressScalarFieldEnum)[keyof typeof SchoolMasterAddressScalarFieldEnum]


  export const SchoolMasterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    afflicationCode: 'afflicationCode',
    fkSchoolType: 'fkSchoolType',
    fkSchoolBoard: 'fkSchoolBoard',
    fkSalesTeamId: 'fkSalesTeamId',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolMasterScalarFieldEnum = (typeof SchoolMasterScalarFieldEnum)[keyof typeof SchoolMasterScalarFieldEnum]


  export const SchoolTypeScalarFieldEnum: {
    id: 'id',
    schoolType: 'schoolType',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolTypeScalarFieldEnum = (typeof SchoolTypeScalarFieldEnum)[keyof typeof SchoolTypeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StateScalarFieldEnum: {
    id: 'id',
    StateName: 'StateName',
    fkCountryId: 'fkCountryId',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


  export const StudentAddressScalarFieldEnum: {
    id: 'id',
    fkStudentId: 'fkStudentId',
    fkCountryId: 'fkCountryId',
    fkStateId: 'fkStateId',
    fkCityId: 'fkCityId',
    Address: 'Address',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type StudentAddressScalarFieldEnum = (typeof StudentAddressScalarFieldEnum)[keyof typeof StudentAddressScalarFieldEnum]


  export const StudentDocumentsScalarFieldEnum: {
    id: 'id',
    fkStudentId: 'fkStudentId',
    category: 'category',
    docUrl: 'docUrl',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type StudentDocumentsScalarFieldEnum = (typeof StudentDocumentsScalarFieldEnum)[keyof typeof StudentDocumentsScalarFieldEnum]


  export const StudentMasterScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    password: 'password',
    dob: 'dob',
    admissionId: 'admissionId',
    rollNo: 'rollNo',
    profileImg: 'profileImg',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type StudentMasterScalarFieldEnum = (typeof StudentMasterScalarFieldEnum)[keyof typeof StudentMasterScalarFieldEnum]


  export const StudentParentsScalarFieldEnum: {
    id: 'id',
    fkStudentId: 'fkStudentId',
    name: 'name',
    relation: 'relation',
    phone: 'phone',
    email: 'email',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type StudentParentsScalarFieldEnum = (typeof StudentParentsScalarFieldEnum)[keyof typeof StudentParentsScalarFieldEnum]


  export const SubjectmasterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectmasterScalarFieldEnum = (typeof SubjectmasterScalarFieldEnum)[keyof typeof SubjectmasterScalarFieldEnum]


  export const TeacherAddressScalarFieldEnum: {
    id: 'id',
    fkTeacherId: 'fkTeacherId',
    fkCountryId: 'fkCountryId',
    fkStateId: 'fkStateId',
    fkCityId: 'fkCityId',
    Address: 'Address',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherAddressScalarFieldEnum = (typeof TeacherAddressScalarFieldEnum)[keyof typeof TeacherAddressScalarFieldEnum]


  export const TeacherDepartmentScalarFieldEnum: {
    id: 'id',
    department: 'department',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherDepartmentScalarFieldEnum = (typeof TeacherDepartmentScalarFieldEnum)[keyof typeof TeacherDepartmentScalarFieldEnum]


  export const TeacherDocumentsScalarFieldEnum: {
    id: 'id',
    fkTeacherId: 'fkTeacherId',
    category: 'category',
    docUrl: 'docUrl',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherDocumentsScalarFieldEnum = (typeof TeacherDocumentsScalarFieldEnum)[keyof typeof TeacherDocumentsScalarFieldEnum]


  export const TeacherExprienceScalarFieldEnum: {
    id: 'id',
    fkTeacherId: 'fkTeacherId',
    skills: 'skills',
    experience: 'experience',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherExprienceScalarFieldEnum = (typeof TeacherExprienceScalarFieldEnum)[keyof typeof TeacherExprienceScalarFieldEnum]


  export const TeacherMasterScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    password: 'password',
    gender: 'gender',
    dob: 'dob',
    teacherId: 'teacherId',
    fkTeacherDepartmentId: 'fkTeacherDepartmentId',
    profileImg: 'profileImg',
    joiningDate: 'joiningDate',
    fkDesignationId: 'fkDesignationId',
    status: 'status',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherMasterScalarFieldEnum = (typeof TeacherMasterScalarFieldEnum)[keyof typeof TeacherMasterScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  /**
   * Deep Input Types
   */


  export type DesignationWhereInput = {
    AND?: Enumerable<DesignationWhereInput>
    OR?: Enumerable<DesignationWhereInput>
    NOT?: Enumerable<DesignationWhereInput>
    id?: UuidFilter | string
    roles?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    SalesTeam?: SalesTeamListRelationFilter
    TeacherMaster?: TeacherMasterListRelationFilter
  }

  export type DesignationOrderByWithRelationInput = {
    id?: SortOrder
    roles?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    SalesTeam?: SalesTeamOrderByRelationAggregateInput
    TeacherMaster?: TeacherMasterOrderByRelationAggregateInput
  }

  export type DesignationWhereUniqueInput = {
    id?: string
    roles?: string
  }

  export type DesignationOrderByWithAggregationInput = {
    id?: SortOrder
    roles?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DesignationCountOrderByAggregateInput
    _max?: DesignationMaxOrderByAggregateInput
    _min?: DesignationMinOrderByAggregateInput
  }

  export type DesignationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DesignationScalarWhereWithAggregatesInput>
    OR?: Enumerable<DesignationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DesignationScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    roles?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CountryWhereInput = {
    AND?: Enumerable<CountryWhereInput>
    OR?: Enumerable<CountryWhereInput>
    NOT?: Enumerable<CountryWhereInput>
    id?: UuidFilter | string
    CounrtyName?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    State?: StateListRelationFilter
    StudentAddress?: StudentAddressListRelationFilter
    TeacherAddress?: TeacherAddressListRelationFilter
    SalesTeamAddress?: SalesTeamAddressListRelationFilter
    SchoolMasterAddress?: SchoolMasterAddressListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    CounrtyName?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    State?: StateOrderByRelationAggregateInput
    StudentAddress?: StudentAddressOrderByRelationAggregateInput
    TeacherAddress?: TeacherAddressOrderByRelationAggregateInput
    SalesTeamAddress?: SalesTeamAddressOrderByRelationAggregateInput
    SchoolMasterAddress?: SchoolMasterAddressOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = {
    id?: string
    CounrtyName?: string
  }

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    CounrtyName?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CountryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CountryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CountryScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    CounrtyName?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StateWhereInput = {
    AND?: Enumerable<StateWhereInput>
    OR?: Enumerable<StateWhereInput>
    NOT?: Enumerable<StateWhereInput>
    id?: UuidFilter | string
    StateName?: StringFilter | string
    Country?: XOR<CountryRelationFilter, CountryWhereInput>
    fkCountryId?: UuidFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    City?: CityListRelationFilter
    StudentAddress?: StudentAddressListRelationFilter
    TeacherAddress?: TeacherAddressListRelationFilter
    SalesTeamAddress?: SalesTeamAddressListRelationFilter
    SchoolMasterAddress?: SchoolMasterAddressListRelationFilter
  }

  export type StateOrderByWithRelationInput = {
    id?: SortOrder
    StateName?: SortOrder
    Country?: CountryOrderByWithRelationInput
    fkCountryId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    City?: CityOrderByRelationAggregateInput
    StudentAddress?: StudentAddressOrderByRelationAggregateInput
    TeacherAddress?: TeacherAddressOrderByRelationAggregateInput
    SalesTeamAddress?: SalesTeamAddressOrderByRelationAggregateInput
    SchoolMasterAddress?: SchoolMasterAddressOrderByRelationAggregateInput
  }

  export type StateWhereUniqueInput = {
    id?: string
    StateName?: string
  }

  export type StateOrderByWithAggregationInput = {
    id?: SortOrder
    StateName?: SortOrder
    fkCountryId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StateCountOrderByAggregateInput
    _max?: StateMaxOrderByAggregateInput
    _min?: StateMinOrderByAggregateInput
  }

  export type StateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StateScalarWhereWithAggregatesInput>
    OR?: Enumerable<StateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StateScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    StateName?: StringWithAggregatesFilter | string
    fkCountryId?: UuidWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CityWhereInput = {
    AND?: Enumerable<CityWhereInput>
    OR?: Enumerable<CityWhereInput>
    NOT?: Enumerable<CityWhereInput>
    id?: UuidFilter | string
    CityName?: StringFilter | string
    State?: XOR<StateRelationFilter, StateWhereInput>
    fkStateId?: UuidFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    StudentAddress?: StudentAddressListRelationFilter
    TeacherAddress?: TeacherAddressListRelationFilter
    SalesTeamAddress?: SalesTeamAddressListRelationFilter
    SchoolMasterAddress?: SchoolMasterAddressListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    CityName?: SortOrder
    State?: StateOrderByWithRelationInput
    fkStateId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    StudentAddress?: StudentAddressOrderByRelationAggregateInput
    TeacherAddress?: TeacherAddressOrderByRelationAggregateInput
    SalesTeamAddress?: SalesTeamAddressOrderByRelationAggregateInput
    SchoolMasterAddress?: SchoolMasterAddressOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = {
    id?: string
  }

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    CityName?: SortOrder
    fkStateId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CityScalarWhereWithAggregatesInput>
    OR?: Enumerable<CityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CityScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    CityName?: StringWithAggregatesFilter | string
    fkStateId?: UuidWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AdminWhereInput = {
    AND?: Enumerable<AdminWhereInput>
    OR?: Enumerable<AdminWhereInput>
    NOT?: Enumerable<AdminWhereInput>
    id?: UuidFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AdminScalarWhereWithAggregatesInput>
    OR?: Enumerable<AdminScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AdminScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SalesTeamWhereInput = {
    AND?: Enumerable<SalesTeamWhereInput>
    OR?: Enumerable<SalesTeamWhereInput>
    NOT?: Enumerable<SalesTeamWhereInput>
    id?: UuidFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    password?: StringFilter | string
    dob?: DateTimeFilter | Date | string
    designation?: XOR<DesignationRelationFilter, DesignationWhereInput>
    fkDesignationId?: UuidFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    SalesTeamDocuments?: SalesTeamDocumentsListRelationFilter
    SalesTeamAddress?: SalesTeamAddressListRelationFilter
    schoolMaster?: SchoolMasterListRelationFilter
  }

  export type SalesTeamOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    designation?: DesignationOrderByWithRelationInput
    fkDesignationId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    SalesTeamDocuments?: SalesTeamDocumentsOrderByRelationAggregateInput
    SalesTeamAddress?: SalesTeamAddressOrderByRelationAggregateInput
    schoolMaster?: schoolMasterOrderByRelationAggregateInput
  }

  export type SalesTeamWhereUniqueInput = {
    id?: string
    email?: string
    phone?: string
  }

  export type SalesTeamOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    fkDesignationId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesTeamCountOrderByAggregateInput
    _max?: SalesTeamMaxOrderByAggregateInput
    _min?: SalesTeamMinOrderByAggregateInput
  }

  export type SalesTeamScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SalesTeamScalarWhereWithAggregatesInput>
    OR?: Enumerable<SalesTeamScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SalesTeamScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    dob?: DateTimeWithAggregatesFilter | Date | string
    fkDesignationId?: UuidWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SalesTeamDocumentsWhereInput = {
    AND?: Enumerable<SalesTeamDocumentsWhereInput>
    OR?: Enumerable<SalesTeamDocumentsWhereInput>
    NOT?: Enumerable<SalesTeamDocumentsWhereInput>
    id?: UuidFilter | string
    salesTeam?: XOR<SalesTeamRelationFilter, SalesTeamWhereInput>
    fkSalesTeamId?: UuidFilter | string
    category?: StringFilter | string
    comment?: StringFilter | string
    url?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SalesTeamDocumentsOrderByWithRelationInput = {
    id?: SortOrder
    salesTeam?: SalesTeamOrderByWithRelationInput
    fkSalesTeamId?: SortOrder
    category?: SortOrder
    comment?: SortOrder
    url?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamDocumentsWhereUniqueInput = {
    id?: string
  }

  export type SalesTeamDocumentsOrderByWithAggregationInput = {
    id?: SortOrder
    fkSalesTeamId?: SortOrder
    category?: SortOrder
    comment?: SortOrder
    url?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesTeamDocumentsCountOrderByAggregateInput
    _max?: SalesTeamDocumentsMaxOrderByAggregateInput
    _min?: SalesTeamDocumentsMinOrderByAggregateInput
  }

  export type SalesTeamDocumentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SalesTeamDocumentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<SalesTeamDocumentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SalesTeamDocumentsScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    fkSalesTeamId?: UuidWithAggregatesFilter | string
    category?: StringWithAggregatesFilter | string
    comment?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SalesTeamAddressWhereInput = {
    AND?: Enumerable<SalesTeamAddressWhereInput>
    OR?: Enumerable<SalesTeamAddressWhereInput>
    NOT?: Enumerable<SalesTeamAddressWhereInput>
    id?: UuidFilter | string
    salesTeam?: XOR<SalesTeamRelationFilter, SalesTeamWhereInput>
    fkSalesTeamId?: UuidFilter | string
    Country?: XOR<CountryRelationFilter, CountryWhereInput>
    fkCountryId?: UuidFilter | string
    State?: XOR<StateRelationFilter, StateWhereInput>
    fkStateId?: UuidFilter | string
    City?: XOR<CityRelationFilter, CityWhereInput>
    fkCityId?: UuidFilter | string
    Address?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SalesTeamAddressOrderByWithRelationInput = {
    id?: SortOrder
    salesTeam?: SalesTeamOrderByWithRelationInput
    fkSalesTeamId?: SortOrder
    Country?: CountryOrderByWithRelationInput
    fkCountryId?: SortOrder
    State?: StateOrderByWithRelationInput
    fkStateId?: SortOrder
    City?: CityOrderByWithRelationInput
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamAddressWhereUniqueInput = {
    id?: string
  }

  export type SalesTeamAddressOrderByWithAggregationInput = {
    id?: SortOrder
    fkSalesTeamId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesTeamAddressCountOrderByAggregateInput
    _max?: SalesTeamAddressMaxOrderByAggregateInput
    _min?: SalesTeamAddressMinOrderByAggregateInput
  }

  export type SalesTeamAddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SalesTeamAddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<SalesTeamAddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SalesTeamAddressScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    fkSalesTeamId?: UuidWithAggregatesFilter | string
    fkCountryId?: UuidWithAggregatesFilter | string
    fkStateId?: UuidWithAggregatesFilter | string
    fkCityId?: UuidWithAggregatesFilter | string
    Address?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SchoolBoardWhereInput = {
    AND?: Enumerable<SchoolBoardWhereInput>
    OR?: Enumerable<SchoolBoardWhereInput>
    NOT?: Enumerable<SchoolBoardWhereInput>
    id?: UuidFilter | string
    boardname?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    schoolMaster?: SchoolMasterListRelationFilter
  }

  export type SchoolBoardOrderByWithRelationInput = {
    id?: SortOrder
    boardname?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    schoolMaster?: schoolMasterOrderByRelationAggregateInput
  }

  export type SchoolBoardWhereUniqueInput = {
    id?: string
    boardname?: string
  }

  export type SchoolBoardOrderByWithAggregationInput = {
    id?: SortOrder
    boardname?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolBoardCountOrderByAggregateInput
    _max?: SchoolBoardMaxOrderByAggregateInput
    _min?: SchoolBoardMinOrderByAggregateInput
  }

  export type SchoolBoardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SchoolBoardScalarWhereWithAggregatesInput>
    OR?: Enumerable<SchoolBoardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SchoolBoardScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    boardname?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type schoolTypeWhereInput = {
    AND?: Enumerable<schoolTypeWhereInput>
    OR?: Enumerable<schoolTypeWhereInput>
    NOT?: Enumerable<schoolTypeWhereInput>
    id?: UuidFilter | string
    schoolType?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    schoolMaster?: SchoolMasterListRelationFilter
  }

  export type schoolTypeOrderByWithRelationInput = {
    id?: SortOrder
    schoolType?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    schoolMaster?: schoolMasterOrderByRelationAggregateInput
  }

  export type schoolTypeWhereUniqueInput = {
    id?: string
    schoolType?: string
  }

  export type schoolTypeOrderByWithAggregationInput = {
    id?: SortOrder
    schoolType?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: schoolTypeCountOrderByAggregateInput
    _max?: schoolTypeMaxOrderByAggregateInput
    _min?: schoolTypeMinOrderByAggregateInput
  }

  export type schoolTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<schoolTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<schoolTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<schoolTypeScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    schoolType?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type schoolMasterWhereInput = {
    AND?: Enumerable<schoolMasterWhereInput>
    OR?: Enumerable<schoolMasterWhereInput>
    NOT?: Enumerable<schoolMasterWhereInput>
    id?: UuidFilter | string
    name?: StringFilter | string
    afflicationCode?: StringFilter | string
    schoolType?: XOR<SchoolTypeRelationFilter, schoolTypeWhereInput>
    fkSchoolType?: UuidFilter | string
    schoolBoard?: XOR<SchoolBoardRelationFilter, SchoolBoardWhereInput>
    fkSchoolBoard?: UuidFilter | string
    salesTeam?: XOR<SalesTeamRelationFilter, SalesTeamWhereInput>
    fkSalesTeamId?: UuidFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    SchoolMasterAddress?: SchoolMasterAddressListRelationFilter
  }

  export type schoolMasterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    afflicationCode?: SortOrder
    schoolType?: schoolTypeOrderByWithRelationInput
    fkSchoolType?: SortOrder
    schoolBoard?: SchoolBoardOrderByWithRelationInput
    fkSchoolBoard?: SortOrder
    salesTeam?: SalesTeamOrderByWithRelationInput
    fkSalesTeamId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    SchoolMasterAddress?: SchoolMasterAddressOrderByRelationAggregateInput
  }

  export type schoolMasterWhereUniqueInput = {
    id?: string
  }

  export type schoolMasterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    afflicationCode?: SortOrder
    fkSchoolType?: SortOrder
    fkSchoolBoard?: SortOrder
    fkSalesTeamId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: schoolMasterCountOrderByAggregateInput
    _max?: schoolMasterMaxOrderByAggregateInput
    _min?: schoolMasterMinOrderByAggregateInput
  }

  export type schoolMasterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<schoolMasterScalarWhereWithAggregatesInput>
    OR?: Enumerable<schoolMasterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<schoolMasterScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    afflicationCode?: StringWithAggregatesFilter | string
    fkSchoolType?: UuidWithAggregatesFilter | string
    fkSchoolBoard?: UuidWithAggregatesFilter | string
    fkSalesTeamId?: UuidWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SchoolMasterAddressWhereInput = {
    AND?: Enumerable<SchoolMasterAddressWhereInput>
    OR?: Enumerable<SchoolMasterAddressWhereInput>
    NOT?: Enumerable<SchoolMasterAddressWhereInput>
    id?: UuidFilter | string
    schoolId?: XOR<SchoolMasterRelationFilter, schoolMasterWhereInput>
    fkSchoolId?: UuidFilter | string
    Country?: XOR<CountryRelationFilter, CountryWhereInput>
    fkCountryId?: UuidFilter | string
    State?: XOR<StateRelationFilter, StateWhereInput>
    fkStateId?: UuidFilter | string
    City?: XOR<CityRelationFilter, CityWhereInput>
    fkCityId?: UuidFilter | string
    Address?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SchoolMasterAddressOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: schoolMasterOrderByWithRelationInput
    fkSchoolId?: SortOrder
    Country?: CountryOrderByWithRelationInput
    fkCountryId?: SortOrder
    State?: StateOrderByWithRelationInput
    fkStateId?: SortOrder
    City?: CityOrderByWithRelationInput
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMasterAddressWhereUniqueInput = {
    id?: string
  }

  export type SchoolMasterAddressOrderByWithAggregationInput = {
    id?: SortOrder
    fkSchoolId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolMasterAddressCountOrderByAggregateInput
    _max?: SchoolMasterAddressMaxOrderByAggregateInput
    _min?: SchoolMasterAddressMinOrderByAggregateInput
  }

  export type SchoolMasterAddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SchoolMasterAddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<SchoolMasterAddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SchoolMasterAddressScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    fkSchoolId?: UuidWithAggregatesFilter | string
    fkCountryId?: UuidWithAggregatesFilter | string
    fkStateId?: UuidWithAggregatesFilter | string
    fkCityId?: UuidWithAggregatesFilter | string
    Address?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ClassmasterWhereInput = {
    AND?: Enumerable<ClassmasterWhereInput>
    OR?: Enumerable<ClassmasterWhereInput>
    NOT?: Enumerable<ClassmasterWhereInput>
    id?: UuidFilter | string
    name?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ClassmasterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassmasterWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type ClassmasterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassmasterCountOrderByAggregateInput
    _max?: ClassmasterMaxOrderByAggregateInput
    _min?: ClassmasterMinOrderByAggregateInput
  }

  export type ClassmasterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClassmasterScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClassmasterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClassmasterScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubjectmasterWhereInput = {
    AND?: Enumerable<SubjectmasterWhereInput>
    OR?: Enumerable<SubjectmasterWhereInput>
    NOT?: Enumerable<SubjectmasterWhereInput>
    id?: UuidFilter | string
    name?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SubjectmasterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectmasterWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type SubjectmasterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubjectmasterCountOrderByAggregateInput
    _max?: SubjectmasterMaxOrderByAggregateInput
    _min?: SubjectmasterMinOrderByAggregateInput
  }

  export type SubjectmasterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubjectmasterScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubjectmasterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubjectmasterScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StudentMasterWhereInput = {
    AND?: Enumerable<StudentMasterWhereInput>
    OR?: Enumerable<StudentMasterWhereInput>
    NOT?: Enumerable<StudentMasterWhereInput>
    id?: UuidFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    password?: StringFilter | string
    dob?: DateTimeFilter | Date | string
    admissionId?: StringFilter | string
    rollNo?: StringFilter | string
    profileImg?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    StudentDetail?: StudentDocumentsListRelationFilter
    StudentAddress?: StudentAddressListRelationFilter
    StudentParents?: StudentParentsListRelationFilter
  }

  export type StudentMasterOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    admissionId?: SortOrder
    rollNo?: SortOrder
    profileImg?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    StudentDetail?: StudentDocumentsOrderByRelationAggregateInput
    StudentAddress?: StudentAddressOrderByRelationAggregateInput
    StudentParents?: StudentParentsOrderByRelationAggregateInput
  }

  export type StudentMasterWhereUniqueInput = {
    id?: string
    email?: string
    admissionId?: string
  }

  export type StudentMasterOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    admissionId?: SortOrder
    rollNo?: SortOrder
    profileImg?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentMasterCountOrderByAggregateInput
    _max?: StudentMasterMaxOrderByAggregateInput
    _min?: StudentMasterMinOrderByAggregateInput
  }

  export type StudentMasterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentMasterScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentMasterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentMasterScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    dob?: DateTimeWithAggregatesFilter | Date | string
    admissionId?: StringWithAggregatesFilter | string
    rollNo?: StringWithAggregatesFilter | string
    profileImg?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StudentParentsWhereInput = {
    AND?: Enumerable<StudentParentsWhereInput>
    OR?: Enumerable<StudentParentsWhereInput>
    NOT?: Enumerable<StudentParentsWhereInput>
    id?: UuidFilter | string
    StudentId?: XOR<StudentMasterRelationFilter, StudentMasterWhereInput>
    fkStudentId?: UuidFilter | string
    name?: StringFilter | string
    relation?: StringFilter | string
    phone?: StringFilter | string
    email?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StudentParentsOrderByWithRelationInput = {
    id?: SortOrder
    StudentId?: StudentMasterOrderByWithRelationInput
    fkStudentId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentParentsWhereUniqueInput = {
    id?: string
    phone?: string
    email?: string
  }

  export type StudentParentsOrderByWithAggregationInput = {
    id?: SortOrder
    fkStudentId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentParentsCountOrderByAggregateInput
    _max?: StudentParentsMaxOrderByAggregateInput
    _min?: StudentParentsMinOrderByAggregateInput
  }

  export type StudentParentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentParentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentParentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentParentsScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    fkStudentId?: UuidWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    relation?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StudentDocumentsWhereInput = {
    AND?: Enumerable<StudentDocumentsWhereInput>
    OR?: Enumerable<StudentDocumentsWhereInput>
    NOT?: Enumerable<StudentDocumentsWhereInput>
    id?: UuidFilter | string
    StudentId?: XOR<StudentMasterRelationFilter, StudentMasterWhereInput>
    fkStudentId?: UuidFilter | string
    category?: StringFilter | string
    docUrl?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StudentDocumentsOrderByWithRelationInput = {
    id?: SortOrder
    StudentId?: StudentMasterOrderByWithRelationInput
    fkStudentId?: SortOrder
    category?: SortOrder
    docUrl?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentDocumentsWhereUniqueInput = {
    id?: string
  }

  export type StudentDocumentsOrderByWithAggregationInput = {
    id?: SortOrder
    fkStudentId?: SortOrder
    category?: SortOrder
    docUrl?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentDocumentsCountOrderByAggregateInput
    _max?: StudentDocumentsMaxOrderByAggregateInput
    _min?: StudentDocumentsMinOrderByAggregateInput
  }

  export type StudentDocumentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentDocumentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentDocumentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentDocumentsScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    fkStudentId?: UuidWithAggregatesFilter | string
    category?: StringWithAggregatesFilter | string
    docUrl?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StudentAddressWhereInput = {
    AND?: Enumerable<StudentAddressWhereInput>
    OR?: Enumerable<StudentAddressWhereInput>
    NOT?: Enumerable<StudentAddressWhereInput>
    id?: UuidFilter | string
    StudentId?: XOR<StudentMasterRelationFilter, StudentMasterWhereInput>
    fkStudentId?: UuidFilter | string
    Country?: XOR<CountryRelationFilter, CountryWhereInput>
    fkCountryId?: UuidFilter | string
    State?: XOR<StateRelationFilter, StateWhereInput>
    fkStateId?: UuidFilter | string
    City?: XOR<CityRelationFilter, CityWhereInput>
    fkCityId?: UuidFilter | string
    Address?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StudentAddressOrderByWithRelationInput = {
    id?: SortOrder
    StudentId?: StudentMasterOrderByWithRelationInput
    fkStudentId?: SortOrder
    Country?: CountryOrderByWithRelationInput
    fkCountryId?: SortOrder
    State?: StateOrderByWithRelationInput
    fkStateId?: SortOrder
    City?: CityOrderByWithRelationInput
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAddressWhereUniqueInput = {
    id?: string
  }

  export type StudentAddressOrderByWithAggregationInput = {
    id?: SortOrder
    fkStudentId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentAddressCountOrderByAggregateInput
    _max?: StudentAddressMaxOrderByAggregateInput
    _min?: StudentAddressMinOrderByAggregateInput
  }

  export type StudentAddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentAddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentAddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentAddressScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    fkStudentId?: UuidWithAggregatesFilter | string
    fkCountryId?: UuidWithAggregatesFilter | string
    fkStateId?: UuidWithAggregatesFilter | string
    fkCityId?: UuidWithAggregatesFilter | string
    Address?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TeacherDepartmentWhereInput = {
    AND?: Enumerable<TeacherDepartmentWhereInput>
    OR?: Enumerable<TeacherDepartmentWhereInput>
    NOT?: Enumerable<TeacherDepartmentWhereInput>
    id?: UuidFilter | string
    department?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    TeacherMaster?: TeacherMasterListRelationFilter
  }

  export type TeacherDepartmentOrderByWithRelationInput = {
    id?: SortOrder
    department?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    TeacherMaster?: TeacherMasterOrderByRelationAggregateInput
  }

  export type TeacherDepartmentWhereUniqueInput = {
    id?: string
    department?: string
  }

  export type TeacherDepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    department?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherDepartmentCountOrderByAggregateInput
    _max?: TeacherDepartmentMaxOrderByAggregateInput
    _min?: TeacherDepartmentMinOrderByAggregateInput
  }

  export type TeacherDepartmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeacherDepartmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeacherDepartmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeacherDepartmentScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    department?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TeacherMasterWhereInput = {
    AND?: Enumerable<TeacherMasterWhereInput>
    OR?: Enumerable<TeacherMasterWhereInput>
    NOT?: Enumerable<TeacherMasterWhereInput>
    id?: UuidFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    password?: StringFilter | string
    gender?: StringFilter | string
    dob?: DateTimeFilter | Date | string
    teacherId?: StringFilter | string
    Teacherdepartment?: XOR<TeacherDepartmentRelationFilter, TeacherDepartmentWhereInput>
    fkTeacherDepartmentId?: UuidFilter | string
    profileImg?: StringFilter | string
    joiningDate?: DateTimeFilter | Date | string
    designation?: XOR<DesignationRelationFilter, DesignationWhereInput>
    fkDesignationId?: UuidFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    TeacherDocuments?: TeacherDocumentsListRelationFilter
    TeacherAddress?: TeacherAddressListRelationFilter
    TeacherExprience?: TeacherExprienceListRelationFilter
  }

  export type TeacherMasterOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    teacherId?: SortOrder
    Teacherdepartment?: TeacherDepartmentOrderByWithRelationInput
    fkTeacherDepartmentId?: SortOrder
    profileImg?: SortOrder
    joiningDate?: SortOrder
    designation?: DesignationOrderByWithRelationInput
    fkDesignationId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    TeacherDocuments?: TeacherDocumentsOrderByRelationAggregateInput
    TeacherAddress?: TeacherAddressOrderByRelationAggregateInput
    TeacherExprience?: TeacherExprienceOrderByRelationAggregateInput
  }

  export type TeacherMasterWhereUniqueInput = {
    id?: string
    email?: string
    phone?: string
    teacherId?: string
  }

  export type TeacherMasterOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    teacherId?: SortOrder
    fkTeacherDepartmentId?: SortOrder
    profileImg?: SortOrder
    joiningDate?: SortOrder
    fkDesignationId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherMasterCountOrderByAggregateInput
    _max?: TeacherMasterMaxOrderByAggregateInput
    _min?: TeacherMasterMinOrderByAggregateInput
  }

  export type TeacherMasterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeacherMasterScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeacherMasterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeacherMasterScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    gender?: StringWithAggregatesFilter | string
    dob?: DateTimeWithAggregatesFilter | Date | string
    teacherId?: StringWithAggregatesFilter | string
    fkTeacherDepartmentId?: UuidWithAggregatesFilter | string
    profileImg?: StringWithAggregatesFilter | string
    joiningDate?: DateTimeWithAggregatesFilter | Date | string
    fkDesignationId?: UuidWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TeacherExprienceWhereInput = {
    AND?: Enumerable<TeacherExprienceWhereInput>
    OR?: Enumerable<TeacherExprienceWhereInput>
    NOT?: Enumerable<TeacherExprienceWhereInput>
    id?: UuidFilter | string
    TeacherId?: XOR<TeacherMasterRelationFilter, TeacherMasterWhereInput>
    fkTeacherId?: UuidFilter | string
    skills?: JsonNullableListFilter
    experience?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TeacherExprienceOrderByWithRelationInput = {
    id?: SortOrder
    TeacherId?: TeacherMasterOrderByWithRelationInput
    fkTeacherId?: SortOrder
    skills?: SortOrder
    experience?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherExprienceWhereUniqueInput = {
    id?: string
  }

  export type TeacherExprienceOrderByWithAggregationInput = {
    id?: SortOrder
    fkTeacherId?: SortOrder
    skills?: SortOrder
    experience?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherExprienceCountOrderByAggregateInput
    _max?: TeacherExprienceMaxOrderByAggregateInput
    _min?: TeacherExprienceMinOrderByAggregateInput
  }

  export type TeacherExprienceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeacherExprienceScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeacherExprienceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeacherExprienceScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    fkTeacherId?: UuidWithAggregatesFilter | string
    skills?: JsonNullableListFilter
    experience?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TeacherDocumentsWhereInput = {
    AND?: Enumerable<TeacherDocumentsWhereInput>
    OR?: Enumerable<TeacherDocumentsWhereInput>
    NOT?: Enumerable<TeacherDocumentsWhereInput>
    id?: UuidFilter | string
    TeacherId?: XOR<TeacherMasterRelationFilter, TeacherMasterWhereInput>
    fkTeacherId?: UuidFilter | string
    category?: StringFilter | string
    docUrl?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TeacherDocumentsOrderByWithRelationInput = {
    id?: SortOrder
    TeacherId?: TeacherMasterOrderByWithRelationInput
    fkTeacherId?: SortOrder
    category?: SortOrder
    docUrl?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherDocumentsWhereUniqueInput = {
    id?: string
  }

  export type TeacherDocumentsOrderByWithAggregationInput = {
    id?: SortOrder
    fkTeacherId?: SortOrder
    category?: SortOrder
    docUrl?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherDocumentsCountOrderByAggregateInput
    _max?: TeacherDocumentsMaxOrderByAggregateInput
    _min?: TeacherDocumentsMinOrderByAggregateInput
  }

  export type TeacherDocumentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeacherDocumentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeacherDocumentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeacherDocumentsScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    fkTeacherId?: UuidWithAggregatesFilter | string
    category?: StringWithAggregatesFilter | string
    docUrl?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TeacherAddressWhereInput = {
    AND?: Enumerable<TeacherAddressWhereInput>
    OR?: Enumerable<TeacherAddressWhereInput>
    NOT?: Enumerable<TeacherAddressWhereInput>
    id?: UuidFilter | string
    TeacherId?: XOR<TeacherMasterRelationFilter, TeacherMasterWhereInput>
    fkTeacherId?: UuidFilter | string
    Country?: XOR<CountryRelationFilter, CountryWhereInput>
    fkCountryId?: UuidFilter | string
    State?: XOR<StateRelationFilter, StateWhereInput>
    fkStateId?: UuidFilter | string
    City?: XOR<CityRelationFilter, CityWhereInput>
    fkCityId?: UuidFilter | string
    Address?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TeacherAddressOrderByWithRelationInput = {
    id?: SortOrder
    TeacherId?: TeacherMasterOrderByWithRelationInput
    fkTeacherId?: SortOrder
    Country?: CountryOrderByWithRelationInput
    fkCountryId?: SortOrder
    State?: StateOrderByWithRelationInput
    fkStateId?: SortOrder
    City?: CityOrderByWithRelationInput
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherAddressWhereUniqueInput = {
    id?: string
  }

  export type TeacherAddressOrderByWithAggregationInput = {
    id?: SortOrder
    fkTeacherId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherAddressCountOrderByAggregateInput
    _max?: TeacherAddressMaxOrderByAggregateInput
    _min?: TeacherAddressMinOrderByAggregateInput
  }

  export type TeacherAddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeacherAddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeacherAddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeacherAddressScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    fkTeacherId?: UuidWithAggregatesFilter | string
    fkCountryId?: UuidWithAggregatesFilter | string
    fkStateId?: UuidWithAggregatesFilter | string
    fkCityId?: UuidWithAggregatesFilter | string
    Address?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DesignationCreateInput = {
    id?: string
    roles: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeam?: SalesTeamCreateNestedManyWithoutDesignationInput
    TeacherMaster?: TeacherMasterCreateNestedManyWithoutDesignationInput
  }

  export type DesignationUncheckedCreateInput = {
    id?: string
    roles: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeam?: SalesTeamUncheckedCreateNestedManyWithoutDesignationInput
    TeacherMaster?: TeacherMasterUncheckedCreateNestedManyWithoutDesignationInput
  }

  export type DesignationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeam?: SalesTeamUpdateManyWithoutDesignationNestedInput
    TeacherMaster?: TeacherMasterUpdateManyWithoutDesignationNestedInput
  }

  export type DesignationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeam?: SalesTeamUncheckedUpdateManyWithoutDesignationNestedInput
    TeacherMaster?: TeacherMasterUncheckedUpdateManyWithoutDesignationNestedInput
  }

  export type DesignationCreateManyInput = {
    id?: string
    roles: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    State?: StateCreateNestedManyWithoutCountryInput
    StudentAddress?: StudentAddressCreateNestedManyWithoutCountryInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutCountryInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutCountryInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    State?: StateUncheckedCreateNestedManyWithoutCountryInput
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutCountryInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutCountryInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutCountryInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    State?: StateUpdateManyWithoutCountryNestedInput
    StudentAddress?: StudentAddressUpdateManyWithoutCountryNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutCountryNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutCountryNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    State?: StateUncheckedUpdateManyWithoutCountryNestedInput
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutCountryNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutCountryNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutCountryNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateCreateInput = {
    id?: string
    StateName: string
    Country: CountryCreateNestedOneWithoutStateInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    City?: CityCreateNestedManyWithoutStateInput
    StudentAddress?: StudentAddressCreateNestedManyWithoutStateInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutStateInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutStateInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateInput = {
    id?: string
    StateName: string
    fkCountryId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    City?: CityUncheckedCreateNestedManyWithoutStateInput
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutStateInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutStateInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutStateInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    Country?: CountryUpdateOneRequiredWithoutStateNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUpdateManyWithoutStateNestedInput
    StudentAddress?: StudentAddressUpdateManyWithoutStateNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutStateNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutStateNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUncheckedUpdateManyWithoutStateNestedInput
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutStateNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutStateNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutStateNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutStateNestedInput
  }

  export type StateCreateManyInput = {
    id?: string
    StateName: string
    fkCountryId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id?: string
    CityName: string
    State: StateCreateNestedOneWithoutCityInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressCreateNestedManyWithoutCityInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutCityInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutCityInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    CityName: string
    fkStateId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutCityInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutCityInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutCityInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    State?: StateUpdateOneRequiredWithoutCityNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUpdateManyWithoutCityNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutCityNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutCityNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutCityNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutCityNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutCityNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    CityName: string
    fkStateId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    email: string
    password: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: string
    email: string
    password: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamCreateInput = {
    id?: string
    email: string
    phone: string
    password: string
    dob: Date | string
    designation: DesignationCreateNestedOneWithoutSalesTeamInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeamDocuments?: SalesTeamDocumentsCreateNestedManyWithoutSalesTeamInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutSalesTeamInput
    schoolMaster?: schoolMasterCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamUncheckedCreateInput = {
    id?: string
    email: string
    phone: string
    password: string
    dob: Date | string
    fkDesignationId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeamDocuments?: SalesTeamDocumentsUncheckedCreateNestedManyWithoutSalesTeamInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutSalesTeamInput
    schoolMaster?: schoolMasterUncheckedCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    designation?: DesignationUpdateOneRequiredWithoutSalesTeamNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeamDocuments?: SalesTeamDocumentsUpdateManyWithoutSalesTeamNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutSalesTeamNestedInput
    schoolMaster?: schoolMasterUpdateManyWithoutSalesTeamNestedInput
  }

  export type SalesTeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    fkDesignationId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeamDocuments?: SalesTeamDocumentsUncheckedUpdateManyWithoutSalesTeamNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutSalesTeamNestedInput
    schoolMaster?: schoolMasterUncheckedUpdateManyWithoutSalesTeamNestedInput
  }

  export type SalesTeamCreateManyInput = {
    id?: string
    email: string
    phone: string
    password: string
    dob: Date | string
    fkDesignationId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    fkDesignationId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamDocumentsCreateInput = {
    id?: string
    salesTeam: SalesTeamCreateNestedOneWithoutSalesTeamDocumentsInput
    category: string
    comment: string
    url: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamDocumentsUncheckedCreateInput = {
    id?: string
    fkSalesTeamId: string
    category: string
    comment: string
    url: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamDocumentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesTeam?: SalesTeamUpdateOneRequiredWithoutSalesTeamDocumentsNestedInput
    category?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamDocumentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamDocumentsCreateManyInput = {
    id?: string
    fkSalesTeamId: string
    category: string
    comment: string
    url: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamDocumentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamDocumentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressCreateInput = {
    id?: string
    salesTeam: SalesTeamCreateNestedOneWithoutSalesTeamAddressInput
    Country: CountryCreateNestedOneWithoutSalesTeamAddressInput
    State: StateCreateNestedOneWithoutSalesTeamAddressInput
    City: CityCreateNestedOneWithoutSalesTeamAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressUncheckedCreateInput = {
    id?: string
    fkSalesTeamId: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesTeam?: SalesTeamUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    Country?: CountryUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    State?: StateUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    City?: CityUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressCreateManyInput = {
    id?: string
    fkSalesTeamId: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolBoardCreateInput = {
    id?: string
    boardname: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    schoolMaster?: schoolMasterCreateNestedManyWithoutSchoolBoardInput
  }

  export type SchoolBoardUncheckedCreateInput = {
    id?: string
    boardname: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    schoolMaster?: schoolMasterUncheckedCreateNestedManyWithoutSchoolBoardInput
  }

  export type SchoolBoardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardname?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolMaster?: schoolMasterUpdateManyWithoutSchoolBoardNestedInput
  }

  export type SchoolBoardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardname?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolMaster?: schoolMasterUncheckedUpdateManyWithoutSchoolBoardNestedInput
  }

  export type SchoolBoardCreateManyInput = {
    id?: string
    boardname: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolBoardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardname?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolBoardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardname?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type schoolTypeCreateInput = {
    id?: string
    schoolType: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    schoolMaster?: schoolMasterCreateNestedManyWithoutSchoolTypeInput
  }

  export type schoolTypeUncheckedCreateInput = {
    id?: string
    schoolType: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    schoolMaster?: schoolMasterUncheckedCreateNestedManyWithoutSchoolTypeInput
  }

  export type schoolTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolType?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolMaster?: schoolMasterUpdateManyWithoutSchoolTypeNestedInput
  }

  export type schoolTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolType?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolMaster?: schoolMasterUncheckedUpdateManyWithoutSchoolTypeNestedInput
  }

  export type schoolTypeCreateManyInput = {
    id?: string
    schoolType: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type schoolTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolType?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type schoolTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolType?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type schoolMasterCreateInput = {
    id?: string
    name: string
    afflicationCode: string
    schoolType: schoolTypeCreateNestedOneWithoutSchoolMasterInput
    schoolBoard: SchoolBoardCreateNestedOneWithoutSchoolMasterInput
    salesTeam: SalesTeamCreateNestedOneWithoutSchoolMasterInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutSchoolIdInput
  }

  export type schoolMasterUncheckedCreateInput = {
    id?: string
    name: string
    afflicationCode: string
    fkSchoolType: string
    fkSchoolBoard: string
    fkSalesTeamId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutSchoolIdInput
  }

  export type schoolMasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    schoolType?: schoolTypeUpdateOneRequiredWithoutSchoolMasterNestedInput
    schoolBoard?: SchoolBoardUpdateOneRequiredWithoutSchoolMasterNestedInput
    salesTeam?: SalesTeamUpdateOneRequiredWithoutSchoolMasterNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutSchoolIdNestedInput
  }

  export type schoolMasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    fkSchoolType?: StringFieldUpdateOperationsInput | string
    fkSchoolBoard?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutSchoolIdNestedInput
  }

  export type schoolMasterCreateManyInput = {
    id?: string
    name: string
    afflicationCode: string
    fkSchoolType: string
    fkSchoolBoard: string
    fkSalesTeamId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type schoolMasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type schoolMasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    fkSchoolType?: StringFieldUpdateOperationsInput | string
    fkSchoolBoard?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolMasterAddressCreateInput = {
    id?: string
    schoolId: schoolMasterCreateNestedOneWithoutSchoolMasterAddressInput
    Country: CountryCreateNestedOneWithoutSchoolMasterAddressInput
    State: StateCreateNestedOneWithoutSchoolMasterAddressInput
    City: CityCreateNestedOneWithoutSchoolMasterAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressUncheckedCreateInput = {
    id?: string
    fkSchoolId: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: schoolMasterUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    Country?: CountryUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    State?: StateUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    City?: CityUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolMasterAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSchoolId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolMasterAddressCreateManyInput = {
    id?: string
    fkSchoolId: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolMasterAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSchoolId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassmasterCreateInput = {
    id?: string
    name: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassmasterUncheckedCreateInput = {
    id?: string
    name: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassmasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassmasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassmasterCreateManyInput = {
    id?: string
    name: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassmasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassmasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectmasterCreateInput = {
    id?: string
    name: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectmasterUncheckedCreateInput = {
    id?: string
    name: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectmasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectmasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectmasterCreateManyInput = {
    id?: string
    name: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectmasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectmasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentMasterCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    dob: Date | string
    admissionId: string
    rollNo: string
    profileImg: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentDetail?: StudentDocumentsCreateNestedManyWithoutStudentIdInput
    StudentAddress?: StudentAddressCreateNestedManyWithoutStudentIdInput
    StudentParents?: StudentParentsCreateNestedManyWithoutStudentIdInput
  }

  export type StudentMasterUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    dob: Date | string
    admissionId: string
    rollNo: string
    profileImg: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentDetail?: StudentDocumentsUncheckedCreateNestedManyWithoutStudentIdInput
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutStudentIdInput
    StudentParents?: StudentParentsUncheckedCreateNestedManyWithoutStudentIdInput
  }

  export type StudentMasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionId?: StringFieldUpdateOperationsInput | string
    rollNo?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentDetail?: StudentDocumentsUpdateManyWithoutStudentIdNestedInput
    StudentAddress?: StudentAddressUpdateManyWithoutStudentIdNestedInput
    StudentParents?: StudentParentsUpdateManyWithoutStudentIdNestedInput
  }

  export type StudentMasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionId?: StringFieldUpdateOperationsInput | string
    rollNo?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentDetail?: StudentDocumentsUncheckedUpdateManyWithoutStudentIdNestedInput
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutStudentIdNestedInput
    StudentParents?: StudentParentsUncheckedUpdateManyWithoutStudentIdNestedInput
  }

  export type StudentMasterCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    dob: Date | string
    admissionId: string
    rollNo: string
    profileImg: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentMasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionId?: StringFieldUpdateOperationsInput | string
    rollNo?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentMasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionId?: StringFieldUpdateOperationsInput | string
    rollNo?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentsCreateInput = {
    id?: string
    StudentId: StudentMasterCreateNestedOneWithoutStudentParentsInput
    name: string
    relation: string
    phone: string
    email: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentsUncheckedCreateInput = {
    id?: string
    fkStudentId: string
    name: string
    relation: string
    phone: string
    email: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    StudentId?: StudentMasterUpdateOneRequiredWithoutStudentParentsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkStudentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentsCreateManyInput = {
    id?: string
    fkStudentId: string
    name: string
    relation: string
    phone: string
    email: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkStudentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentsCreateInput = {
    id?: string
    StudentId: StudentMasterCreateNestedOneWithoutStudentDetailInput
    category: string
    docUrl: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentDocumentsUncheckedCreateInput = {
    id?: string
    fkStudentId: string
    category: string
    docUrl: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentDocumentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    StudentId?: StudentMasterUpdateOneRequiredWithoutStudentDetailNestedInput
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkStudentId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentsCreateManyInput = {
    id?: string
    fkStudentId: string
    category: string
    docUrl: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentDocumentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkStudentId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressCreateInput = {
    id?: string
    StudentId: StudentMasterCreateNestedOneWithoutStudentAddressInput
    Country: CountryCreateNestedOneWithoutStudentAddressInput
    State: StateCreateNestedOneWithoutStudentAddressInput
    City: CityCreateNestedOneWithoutStudentAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressUncheckedCreateInput = {
    id?: string
    fkStudentId: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    StudentId?: StudentMasterUpdateOneRequiredWithoutStudentAddressNestedInput
    Country?: CountryUpdateOneRequiredWithoutStudentAddressNestedInput
    State?: StateUpdateOneRequiredWithoutStudentAddressNestedInput
    City?: CityUpdateOneRequiredWithoutStudentAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkStudentId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressCreateManyInput = {
    id?: string
    fkStudentId: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkStudentId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherDepartmentCreateInput = {
    id?: string
    department: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherMaster?: TeacherMasterCreateNestedManyWithoutTeacherdepartmentInput
  }

  export type TeacherDepartmentUncheckedCreateInput = {
    id?: string
    department: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherMaster?: TeacherMasterUncheckedCreateNestedManyWithoutTeacherdepartmentInput
  }

  export type TeacherDepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherMaster?: TeacherMasterUpdateManyWithoutTeacherdepartmentNestedInput
  }

  export type TeacherDepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherMaster?: TeacherMasterUncheckedUpdateManyWithoutTeacherdepartmentNestedInput
  }

  export type TeacherDepartmentCreateManyInput = {
    id?: string
    department: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherDepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherDepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherMasterCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    Teacherdepartment: TeacherDepartmentCreateNestedOneWithoutTeacherMasterInput
    profileImg: string
    joiningDate: Date | string
    designation: DesignationCreateNestedOneWithoutTeacherMasterInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherDocuments?: TeacherDocumentsCreateNestedManyWithoutTeacherIdInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutTeacherIdInput
    TeacherExprience?: TeacherExprienceCreateNestedManyWithoutTeacherIdInput
  }

  export type TeacherMasterUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    fkTeacherDepartmentId: string
    profileImg: string
    joiningDate: Date | string
    fkDesignationId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherDocuments?: TeacherDocumentsUncheckedCreateNestedManyWithoutTeacherIdInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutTeacherIdInput
    TeacherExprience?: TeacherExprienceUncheckedCreateNestedManyWithoutTeacherIdInput
  }

  export type TeacherMasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    Teacherdepartment?: TeacherDepartmentUpdateOneRequiredWithoutTeacherMasterNestedInput
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    designation?: DesignationUpdateOneRequiredWithoutTeacherMasterNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherDocuments?: TeacherDocumentsUpdateManyWithoutTeacherIdNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutTeacherIdNestedInput
    TeacherExprience?: TeacherExprienceUpdateManyWithoutTeacherIdNestedInput
  }

  export type TeacherMasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    fkTeacherDepartmentId?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fkDesignationId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherDocuments?: TeacherDocumentsUncheckedUpdateManyWithoutTeacherIdNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutTeacherIdNestedInput
    TeacherExprience?: TeacherExprienceUncheckedUpdateManyWithoutTeacherIdNestedInput
  }

  export type TeacherMasterCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    fkTeacherDepartmentId: string
    profileImg: string
    joiningDate: Date | string
    fkDesignationId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherMasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherMasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    fkTeacherDepartmentId?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fkDesignationId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherExprienceCreateInput = {
    id?: string
    TeacherId: TeacherMasterCreateNestedOneWithoutTeacherExprienceInput
    skills?: TeacherExprienceCreateskillsInput | Enumerable<InputJsonValue>
    experience: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherExprienceUncheckedCreateInput = {
    id?: string
    fkTeacherId: string
    skills?: TeacherExprienceCreateskillsInput | Enumerable<InputJsonValue>
    experience: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherExprienceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    TeacherId?: TeacherMasterUpdateOneRequiredWithoutTeacherExprienceNestedInput
    skills?: TeacherExprienceUpdateskillsInput | Enumerable<InputJsonValue>
    experience?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherExprienceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkTeacherId?: StringFieldUpdateOperationsInput | string
    skills?: TeacherExprienceUpdateskillsInput | Enumerable<InputJsonValue>
    experience?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherExprienceCreateManyInput = {
    id?: string
    fkTeacherId: string
    skills?: TeacherExprienceCreateskillsInput | Enumerable<InputJsonValue>
    experience: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherExprienceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: TeacherExprienceUpdateskillsInput | Enumerable<InputJsonValue>
    experience?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherExprienceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkTeacherId?: StringFieldUpdateOperationsInput | string
    skills?: TeacherExprienceUpdateskillsInput | Enumerable<InputJsonValue>
    experience?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherDocumentsCreateInput = {
    id?: string
    TeacherId: TeacherMasterCreateNestedOneWithoutTeacherDocumentsInput
    category: string
    docUrl: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherDocumentsUncheckedCreateInput = {
    id?: string
    fkTeacherId: string
    category: string
    docUrl: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherDocumentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    TeacherId?: TeacherMasterUpdateOneRequiredWithoutTeacherDocumentsNestedInput
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherDocumentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkTeacherId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherDocumentsCreateManyInput = {
    id?: string
    fkTeacherId: string
    category: string
    docUrl: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherDocumentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherDocumentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkTeacherId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressCreateInput = {
    id?: string
    TeacherId: TeacherMasterCreateNestedOneWithoutTeacherAddressInput
    Country: CountryCreateNestedOneWithoutTeacherAddressInput
    State: StateCreateNestedOneWithoutTeacherAddressInput
    City: CityCreateNestedOneWithoutTeacherAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressUncheckedCreateInput = {
    id?: string
    fkTeacherId: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    TeacherId?: TeacherMasterUpdateOneRequiredWithoutTeacherAddressNestedInput
    Country?: CountryUpdateOneRequiredWithoutTeacherAddressNestedInput
    State?: StateUpdateOneRequiredWithoutTeacherAddressNestedInput
    City?: CityUpdateOneRequiredWithoutTeacherAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkTeacherId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressCreateManyInput = {
    id?: string
    fkTeacherId: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkTeacherId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    mode?: QueryMode
    not?: NestedUuidFilter | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type SalesTeamListRelationFilter = {
    every?: SalesTeamWhereInput
    some?: SalesTeamWhereInput
    none?: SalesTeamWhereInput
  }

  export type TeacherMasterListRelationFilter = {
    every?: TeacherMasterWhereInput
    some?: TeacherMasterWhereInput
    none?: TeacherMasterWhereInput
  }

  export type SalesTeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherMasterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DesignationCountOrderByAggregateInput = {
    id?: SortOrder
    roles?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignationMaxOrderByAggregateInput = {
    id?: SortOrder
    roles?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignationMinOrderByAggregateInput = {
    id?: SortOrder
    roles?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StateListRelationFilter = {
    every?: StateWhereInput
    some?: StateWhereInput
    none?: StateWhereInput
  }

  export type StudentAddressListRelationFilter = {
    every?: StudentAddressWhereInput
    some?: StudentAddressWhereInput
    none?: StudentAddressWhereInput
  }

  export type TeacherAddressListRelationFilter = {
    every?: TeacherAddressWhereInput
    some?: TeacherAddressWhereInput
    none?: TeacherAddressWhereInput
  }

  export type SalesTeamAddressListRelationFilter = {
    every?: SalesTeamAddressWhereInput
    some?: SalesTeamAddressWhereInput
    none?: SalesTeamAddressWhereInput
  }

  export type SchoolMasterAddressListRelationFilter = {
    every?: SchoolMasterAddressWhereInput
    some?: SchoolMasterAddressWhereInput
    none?: SchoolMasterAddressWhereInput
  }

  export type StateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesTeamAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolMasterAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    CounrtyName?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    CounrtyName?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    CounrtyName?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StateCountOrderByAggregateInput = {
    id?: SortOrder
    StateName?: SortOrder
    fkCountryId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StateMaxOrderByAggregateInput = {
    id?: SortOrder
    StateName?: SortOrder
    fkCountryId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StateMinOrderByAggregateInput = {
    id?: SortOrder
    StateName?: SortOrder
    fkCountryId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StateRelationFilter = {
    is?: StateWhereInput
    isNot?: StateWhereInput
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    CityName?: SortOrder
    fkStateId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    CityName?: SortOrder
    fkStateId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    CityName?: SortOrder
    fkStateId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignationRelationFilter = {
    is?: DesignationWhereInput
    isNot?: DesignationWhereInput
  }

  export type SalesTeamDocumentsListRelationFilter = {
    every?: SalesTeamDocumentsWhereInput
    some?: SalesTeamDocumentsWhereInput
    none?: SalesTeamDocumentsWhereInput
  }

  export type SchoolMasterListRelationFilter = {
    every?: schoolMasterWhereInput
    some?: schoolMasterWhereInput
    none?: schoolMasterWhereInput
  }

  export type SalesTeamDocumentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type schoolMasterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesTeamCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    fkDesignationId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    fkDesignationId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    fkDesignationId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamRelationFilter = {
    is?: SalesTeamWhereInput
    isNot?: SalesTeamWhereInput
  }

  export type SalesTeamDocumentsCountOrderByAggregateInput = {
    id?: SortOrder
    fkSalesTeamId?: SortOrder
    category?: SortOrder
    comment?: SortOrder
    url?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamDocumentsMaxOrderByAggregateInput = {
    id?: SortOrder
    fkSalesTeamId?: SortOrder
    category?: SortOrder
    comment?: SortOrder
    url?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamDocumentsMinOrderByAggregateInput = {
    id?: SortOrder
    fkSalesTeamId?: SortOrder
    category?: SortOrder
    comment?: SortOrder
    url?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type SalesTeamAddressCountOrderByAggregateInput = {
    id?: SortOrder
    fkSalesTeamId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    fkSalesTeamId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamAddressMinOrderByAggregateInput = {
    id?: SortOrder
    fkSalesTeamId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolBoardCountOrderByAggregateInput = {
    id?: SortOrder
    boardname?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolBoardMaxOrderByAggregateInput = {
    id?: SortOrder
    boardname?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolBoardMinOrderByAggregateInput = {
    id?: SortOrder
    boardname?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type schoolTypeCountOrderByAggregateInput = {
    id?: SortOrder
    schoolType?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type schoolTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolType?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type schoolTypeMinOrderByAggregateInput = {
    id?: SortOrder
    schoolType?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolTypeRelationFilter = {
    is?: schoolTypeWhereInput
    isNot?: schoolTypeWhereInput
  }

  export type SchoolBoardRelationFilter = {
    is?: SchoolBoardWhereInput
    isNot?: SchoolBoardWhereInput
  }

  export type schoolMasterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    afflicationCode?: SortOrder
    fkSchoolType?: SortOrder
    fkSchoolBoard?: SortOrder
    fkSalesTeamId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type schoolMasterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    afflicationCode?: SortOrder
    fkSchoolType?: SortOrder
    fkSchoolBoard?: SortOrder
    fkSalesTeamId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type schoolMasterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    afflicationCode?: SortOrder
    fkSchoolType?: SortOrder
    fkSchoolBoard?: SortOrder
    fkSalesTeamId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMasterRelationFilter = {
    is?: schoolMasterWhereInput
    isNot?: schoolMasterWhereInput
  }

  export type SchoolMasterAddressCountOrderByAggregateInput = {
    id?: SortOrder
    fkSchoolId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMasterAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    fkSchoolId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMasterAddressMinOrderByAggregateInput = {
    id?: SortOrder
    fkSchoolId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassmasterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassmasterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassmasterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectmasterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectmasterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectmasterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentDocumentsListRelationFilter = {
    every?: StudentDocumentsWhereInput
    some?: StudentDocumentsWhereInput
    none?: StudentDocumentsWhereInput
  }

  export type StudentParentsListRelationFilter = {
    every?: StudentParentsWhereInput
    some?: StudentParentsWhereInput
    none?: StudentParentsWhereInput
  }

  export type StudentDocumentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentParentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentMasterCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    admissionId?: SortOrder
    rollNo?: SortOrder
    profileImg?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMasterMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    admissionId?: SortOrder
    rollNo?: SortOrder
    profileImg?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMasterMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    admissionId?: SortOrder
    rollNo?: SortOrder
    profileImg?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMasterRelationFilter = {
    is?: StudentMasterWhereInput
    isNot?: StudentMasterWhereInput
  }

  export type StudentParentsCountOrderByAggregateInput = {
    id?: SortOrder
    fkStudentId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentParentsMaxOrderByAggregateInput = {
    id?: SortOrder
    fkStudentId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentParentsMinOrderByAggregateInput = {
    id?: SortOrder
    fkStudentId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentDocumentsCountOrderByAggregateInput = {
    id?: SortOrder
    fkStudentId?: SortOrder
    category?: SortOrder
    docUrl?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentDocumentsMaxOrderByAggregateInput = {
    id?: SortOrder
    fkStudentId?: SortOrder
    category?: SortOrder
    docUrl?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentDocumentsMinOrderByAggregateInput = {
    id?: SortOrder
    fkStudentId?: SortOrder
    category?: SortOrder
    docUrl?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAddressCountOrderByAggregateInput = {
    id?: SortOrder
    fkStudentId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    fkStudentId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAddressMinOrderByAggregateInput = {
    id?: SortOrder
    fkStudentId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherDepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    department?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherDepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    department?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherDepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    department?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherDepartmentRelationFilter = {
    is?: TeacherDepartmentWhereInput
    isNot?: TeacherDepartmentWhereInput
  }

  export type TeacherDocumentsListRelationFilter = {
    every?: TeacherDocumentsWhereInput
    some?: TeacherDocumentsWhereInput
    none?: TeacherDocumentsWhereInput
  }

  export type TeacherExprienceListRelationFilter = {
    every?: TeacherExprienceWhereInput
    some?: TeacherExprienceWhereInput
    none?: TeacherExprienceWhereInput
  }

  export type TeacherDocumentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherExprienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherMasterCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    teacherId?: SortOrder
    fkTeacherDepartmentId?: SortOrder
    profileImg?: SortOrder
    joiningDate?: SortOrder
    fkDesignationId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMasterMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    teacherId?: SortOrder
    fkTeacherDepartmentId?: SortOrder
    profileImg?: SortOrder
    joiningDate?: SortOrder
    fkDesignationId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMasterMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    teacherId?: SortOrder
    fkTeacherDepartmentId?: SortOrder
    profileImg?: SortOrder
    joiningDate?: SortOrder
    fkDesignationId?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMasterRelationFilter = {
    is?: TeacherMasterWhereInput
    isNot?: TeacherMasterWhereInput
  }
  export type JsonNullableListFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase>, Exclude<keyof Required<JsonNullableListFilterBase>, 'path'>>,
        Required<JsonNullableListFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase>, 'path'>>

  export type JsonNullableListFilterBase = {
    equals?: Enumerable<InputJsonValue> | null
    has?: InputJsonValue | null
    hasEvery?: Enumerable<InputJsonValue>
    hasSome?: Enumerable<InputJsonValue>
    isEmpty?: boolean
  }

  export type TeacherExprienceCountOrderByAggregateInput = {
    id?: SortOrder
    fkTeacherId?: SortOrder
    skills?: SortOrder
    experience?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherExprienceMaxOrderByAggregateInput = {
    id?: SortOrder
    fkTeacherId?: SortOrder
    experience?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherExprienceMinOrderByAggregateInput = {
    id?: SortOrder
    fkTeacherId?: SortOrder
    experience?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherDocumentsCountOrderByAggregateInput = {
    id?: SortOrder
    fkTeacherId?: SortOrder
    category?: SortOrder
    docUrl?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherDocumentsMaxOrderByAggregateInput = {
    id?: SortOrder
    fkTeacherId?: SortOrder
    category?: SortOrder
    docUrl?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherDocumentsMinOrderByAggregateInput = {
    id?: SortOrder
    fkTeacherId?: SortOrder
    category?: SortOrder
    docUrl?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherAddressCountOrderByAggregateInput = {
    id?: SortOrder
    fkTeacherId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    fkTeacherId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherAddressMinOrderByAggregateInput = {
    id?: SortOrder
    fkTeacherId?: SortOrder
    fkCountryId?: SortOrder
    fkStateId?: SortOrder
    fkCityId?: SortOrder
    Address?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamCreateNestedManyWithoutDesignationInput = {
    create?: XOR<Enumerable<SalesTeamCreateWithoutDesignationInput>, Enumerable<SalesTeamUncheckedCreateWithoutDesignationInput>>
    connectOrCreate?: Enumerable<SalesTeamCreateOrConnectWithoutDesignationInput>
    createMany?: SalesTeamCreateManyDesignationInputEnvelope
    connect?: Enumerable<SalesTeamWhereUniqueInput>
  }

  export type TeacherMasterCreateNestedManyWithoutDesignationInput = {
    create?: XOR<Enumerable<TeacherMasterCreateWithoutDesignationInput>, Enumerable<TeacherMasterUncheckedCreateWithoutDesignationInput>>
    connectOrCreate?: Enumerable<TeacherMasterCreateOrConnectWithoutDesignationInput>
    createMany?: TeacherMasterCreateManyDesignationInputEnvelope
    connect?: Enumerable<TeacherMasterWhereUniqueInput>
  }

  export type SalesTeamUncheckedCreateNestedManyWithoutDesignationInput = {
    create?: XOR<Enumerable<SalesTeamCreateWithoutDesignationInput>, Enumerable<SalesTeamUncheckedCreateWithoutDesignationInput>>
    connectOrCreate?: Enumerable<SalesTeamCreateOrConnectWithoutDesignationInput>
    createMany?: SalesTeamCreateManyDesignationInputEnvelope
    connect?: Enumerable<SalesTeamWhereUniqueInput>
  }

  export type TeacherMasterUncheckedCreateNestedManyWithoutDesignationInput = {
    create?: XOR<Enumerable<TeacherMasterCreateWithoutDesignationInput>, Enumerable<TeacherMasterUncheckedCreateWithoutDesignationInput>>
    connectOrCreate?: Enumerable<TeacherMasterCreateOrConnectWithoutDesignationInput>
    createMany?: TeacherMasterCreateManyDesignationInputEnvelope
    connect?: Enumerable<TeacherMasterWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SalesTeamUpdateManyWithoutDesignationNestedInput = {
    create?: XOR<Enumerable<SalesTeamCreateWithoutDesignationInput>, Enumerable<SalesTeamUncheckedCreateWithoutDesignationInput>>
    connectOrCreate?: Enumerable<SalesTeamCreateOrConnectWithoutDesignationInput>
    upsert?: Enumerable<SalesTeamUpsertWithWhereUniqueWithoutDesignationInput>
    createMany?: SalesTeamCreateManyDesignationInputEnvelope
    set?: Enumerable<SalesTeamWhereUniqueInput>
    disconnect?: Enumerable<SalesTeamWhereUniqueInput>
    delete?: Enumerable<SalesTeamWhereUniqueInput>
    connect?: Enumerable<SalesTeamWhereUniqueInput>
    update?: Enumerable<SalesTeamUpdateWithWhereUniqueWithoutDesignationInput>
    updateMany?: Enumerable<SalesTeamUpdateManyWithWhereWithoutDesignationInput>
    deleteMany?: Enumerable<SalesTeamScalarWhereInput>
  }

  export type TeacherMasterUpdateManyWithoutDesignationNestedInput = {
    create?: XOR<Enumerable<TeacherMasterCreateWithoutDesignationInput>, Enumerable<TeacherMasterUncheckedCreateWithoutDesignationInput>>
    connectOrCreate?: Enumerable<TeacherMasterCreateOrConnectWithoutDesignationInput>
    upsert?: Enumerable<TeacherMasterUpsertWithWhereUniqueWithoutDesignationInput>
    createMany?: TeacherMasterCreateManyDesignationInputEnvelope
    set?: Enumerable<TeacherMasterWhereUniqueInput>
    disconnect?: Enumerable<TeacherMasterWhereUniqueInput>
    delete?: Enumerable<TeacherMasterWhereUniqueInput>
    connect?: Enumerable<TeacherMasterWhereUniqueInput>
    update?: Enumerable<TeacherMasterUpdateWithWhereUniqueWithoutDesignationInput>
    updateMany?: Enumerable<TeacherMasterUpdateManyWithWhereWithoutDesignationInput>
    deleteMany?: Enumerable<TeacherMasterScalarWhereInput>
  }

  export type SalesTeamUncheckedUpdateManyWithoutDesignationNestedInput = {
    create?: XOR<Enumerable<SalesTeamCreateWithoutDesignationInput>, Enumerable<SalesTeamUncheckedCreateWithoutDesignationInput>>
    connectOrCreate?: Enumerable<SalesTeamCreateOrConnectWithoutDesignationInput>
    upsert?: Enumerable<SalesTeamUpsertWithWhereUniqueWithoutDesignationInput>
    createMany?: SalesTeamCreateManyDesignationInputEnvelope
    set?: Enumerable<SalesTeamWhereUniqueInput>
    disconnect?: Enumerable<SalesTeamWhereUniqueInput>
    delete?: Enumerable<SalesTeamWhereUniqueInput>
    connect?: Enumerable<SalesTeamWhereUniqueInput>
    update?: Enumerable<SalesTeamUpdateWithWhereUniqueWithoutDesignationInput>
    updateMany?: Enumerable<SalesTeamUpdateManyWithWhereWithoutDesignationInput>
    deleteMany?: Enumerable<SalesTeamScalarWhereInput>
  }

  export type TeacherMasterUncheckedUpdateManyWithoutDesignationNestedInput = {
    create?: XOR<Enumerable<TeacherMasterCreateWithoutDesignationInput>, Enumerable<TeacherMasterUncheckedCreateWithoutDesignationInput>>
    connectOrCreate?: Enumerable<TeacherMasterCreateOrConnectWithoutDesignationInput>
    upsert?: Enumerable<TeacherMasterUpsertWithWhereUniqueWithoutDesignationInput>
    createMany?: TeacherMasterCreateManyDesignationInputEnvelope
    set?: Enumerable<TeacherMasterWhereUniqueInput>
    disconnect?: Enumerable<TeacherMasterWhereUniqueInput>
    delete?: Enumerable<TeacherMasterWhereUniqueInput>
    connect?: Enumerable<TeacherMasterWhereUniqueInput>
    update?: Enumerable<TeacherMasterUpdateWithWhereUniqueWithoutDesignationInput>
    updateMany?: Enumerable<TeacherMasterUpdateManyWithWhereWithoutDesignationInput>
    deleteMany?: Enumerable<TeacherMasterScalarWhereInput>
  }

  export type StateCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
  }

  export type StudentAddressCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutCountryInput>, Enumerable<StudentAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutCountryInput>
    createMany?: StudentAddressCreateManyCountryInputEnvelope
    connect?: Enumerable<StudentAddressWhereUniqueInput>
  }

  export type TeacherAddressCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutCountryInput>, Enumerable<TeacherAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutCountryInput>
    createMany?: TeacherAddressCreateManyCountryInputEnvelope
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
  }

  export type SalesTeamAddressCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutCountryInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutCountryInput>
    createMany?: SalesTeamAddressCreateManyCountryInputEnvelope
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
  }

  export type SchoolMasterAddressCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutCountryInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutCountryInput>
    createMany?: SchoolMasterAddressCreateManyCountryInputEnvelope
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
  }

  export type StateUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
  }

  export type StudentAddressUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutCountryInput>, Enumerable<StudentAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutCountryInput>
    createMany?: StudentAddressCreateManyCountryInputEnvelope
    connect?: Enumerable<StudentAddressWhereUniqueInput>
  }

  export type TeacherAddressUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutCountryInput>, Enumerable<TeacherAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutCountryInput>
    createMany?: TeacherAddressCreateManyCountryInputEnvelope
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
  }

  export type SalesTeamAddressUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutCountryInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutCountryInput>
    createMany?: SalesTeamAddressCreateManyCountryInputEnvelope
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
  }

  export type SchoolMasterAddressUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutCountryInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutCountryInput>
    createMany?: SchoolMasterAddressCreateManyCountryInputEnvelope
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
  }

  export type StateUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StateUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    set?: Enumerable<StateWhereUniqueInput>
    disconnect?: Enumerable<StateWhereUniqueInput>
    delete?: Enumerable<StateWhereUniqueInput>
    connect?: Enumerable<StateWhereUniqueInput>
    update?: Enumerable<StateUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StateUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StateScalarWhereInput>
  }

  export type StudentAddressUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutCountryInput>, Enumerable<StudentAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StudentAddressUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StudentAddressCreateManyCountryInputEnvelope
    set?: Enumerable<StudentAddressWhereUniqueInput>
    disconnect?: Enumerable<StudentAddressWhereUniqueInput>
    delete?: Enumerable<StudentAddressWhereUniqueInput>
    connect?: Enumerable<StudentAddressWhereUniqueInput>
    update?: Enumerable<StudentAddressUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StudentAddressUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StudentAddressScalarWhereInput>
  }

  export type TeacherAddressUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutCountryInput>, Enumerable<TeacherAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<TeacherAddressUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: TeacherAddressCreateManyCountryInputEnvelope
    set?: Enumerable<TeacherAddressWhereUniqueInput>
    disconnect?: Enumerable<TeacherAddressWhereUniqueInput>
    delete?: Enumerable<TeacherAddressWhereUniqueInput>
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
    update?: Enumerable<TeacherAddressUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<TeacherAddressUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<TeacherAddressScalarWhereInput>
  }

  export type SalesTeamAddressUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutCountryInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<SalesTeamAddressUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: SalesTeamAddressCreateManyCountryInputEnvelope
    set?: Enumerable<SalesTeamAddressWhereUniqueInput>
    disconnect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    delete?: Enumerable<SalesTeamAddressWhereUniqueInput>
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    update?: Enumerable<SalesTeamAddressUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<SalesTeamAddressUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<SalesTeamAddressScalarWhereInput>
  }

  export type SchoolMasterAddressUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutCountryInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<SchoolMasterAddressUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: SchoolMasterAddressCreateManyCountryInputEnvelope
    set?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    disconnect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    delete?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    update?: Enumerable<SchoolMasterAddressUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<SchoolMasterAddressUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<SchoolMasterAddressScalarWhereInput>
  }

  export type StateUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StateUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    set?: Enumerable<StateWhereUniqueInput>
    disconnect?: Enumerable<StateWhereUniqueInput>
    delete?: Enumerable<StateWhereUniqueInput>
    connect?: Enumerable<StateWhereUniqueInput>
    update?: Enumerable<StateUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StateUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StateScalarWhereInput>
  }

  export type StudentAddressUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutCountryInput>, Enumerable<StudentAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StudentAddressUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StudentAddressCreateManyCountryInputEnvelope
    set?: Enumerable<StudentAddressWhereUniqueInput>
    disconnect?: Enumerable<StudentAddressWhereUniqueInput>
    delete?: Enumerable<StudentAddressWhereUniqueInput>
    connect?: Enumerable<StudentAddressWhereUniqueInput>
    update?: Enumerable<StudentAddressUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StudentAddressUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StudentAddressScalarWhereInput>
  }

  export type TeacherAddressUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutCountryInput>, Enumerable<TeacherAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<TeacherAddressUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: TeacherAddressCreateManyCountryInputEnvelope
    set?: Enumerable<TeacherAddressWhereUniqueInput>
    disconnect?: Enumerable<TeacherAddressWhereUniqueInput>
    delete?: Enumerable<TeacherAddressWhereUniqueInput>
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
    update?: Enumerable<TeacherAddressUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<TeacherAddressUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<TeacherAddressScalarWhereInput>
  }

  export type SalesTeamAddressUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutCountryInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<SalesTeamAddressUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: SalesTeamAddressCreateManyCountryInputEnvelope
    set?: Enumerable<SalesTeamAddressWhereUniqueInput>
    disconnect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    delete?: Enumerable<SalesTeamAddressWhereUniqueInput>
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    update?: Enumerable<SalesTeamAddressUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<SalesTeamAddressUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<SalesTeamAddressScalarWhereInput>
  }

  export type SchoolMasterAddressUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutCountryInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<SchoolMasterAddressUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: SchoolMasterAddressCreateManyCountryInputEnvelope
    set?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    disconnect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    delete?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    update?: Enumerable<SchoolMasterAddressUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<SchoolMasterAddressUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<SchoolMasterAddressScalarWhereInput>
  }

  export type CountryCreateNestedOneWithoutStateInput = {
    create?: XOR<CountryCreateWithoutStateInput, CountryUncheckedCreateWithoutStateInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStateInput
    connect?: CountryWhereUniqueInput
  }

  export type CityCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type StudentAddressCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutStateInput>, Enumerable<StudentAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutStateInput>
    createMany?: StudentAddressCreateManyStateInputEnvelope
    connect?: Enumerable<StudentAddressWhereUniqueInput>
  }

  export type TeacherAddressCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutStateInput>, Enumerable<TeacherAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutStateInput>
    createMany?: TeacherAddressCreateManyStateInputEnvelope
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
  }

  export type SalesTeamAddressCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutStateInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutStateInput>
    createMany?: SalesTeamAddressCreateManyStateInputEnvelope
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
  }

  export type SchoolMasterAddressCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutStateInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutStateInput>
    createMany?: SchoolMasterAddressCreateManyStateInputEnvelope
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
  }

  export type CityUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type StudentAddressUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutStateInput>, Enumerable<StudentAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutStateInput>
    createMany?: StudentAddressCreateManyStateInputEnvelope
    connect?: Enumerable<StudentAddressWhereUniqueInput>
  }

  export type TeacherAddressUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutStateInput>, Enumerable<TeacherAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutStateInput>
    createMany?: TeacherAddressCreateManyStateInputEnvelope
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
  }

  export type SalesTeamAddressUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutStateInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutStateInput>
    createMany?: SalesTeamAddressCreateManyStateInputEnvelope
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
  }

  export type SchoolMasterAddressUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutStateInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutStateInput>
    createMany?: SchoolMasterAddressCreateManyStateInputEnvelope
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
  }

  export type CountryUpdateOneRequiredWithoutStateNestedInput = {
    create?: XOR<CountryCreateWithoutStateInput, CountryUncheckedCreateWithoutStateInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStateInput
    upsert?: CountryUpsertWithoutStateInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutStateInput, CountryUncheckedUpdateWithoutStateInput>
  }

  export type CityUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    connect?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type StudentAddressUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutStateInput>, Enumerable<StudentAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<StudentAddressUpsertWithWhereUniqueWithoutStateInput>
    createMany?: StudentAddressCreateManyStateInputEnvelope
    set?: Enumerable<StudentAddressWhereUniqueInput>
    disconnect?: Enumerable<StudentAddressWhereUniqueInput>
    delete?: Enumerable<StudentAddressWhereUniqueInput>
    connect?: Enumerable<StudentAddressWhereUniqueInput>
    update?: Enumerable<StudentAddressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<StudentAddressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<StudentAddressScalarWhereInput>
  }

  export type TeacherAddressUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutStateInput>, Enumerable<TeacherAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<TeacherAddressUpsertWithWhereUniqueWithoutStateInput>
    createMany?: TeacherAddressCreateManyStateInputEnvelope
    set?: Enumerable<TeacherAddressWhereUniqueInput>
    disconnect?: Enumerable<TeacherAddressWhereUniqueInput>
    delete?: Enumerable<TeacherAddressWhereUniqueInput>
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
    update?: Enumerable<TeacherAddressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<TeacherAddressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<TeacherAddressScalarWhereInput>
  }

  export type SalesTeamAddressUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutStateInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<SalesTeamAddressUpsertWithWhereUniqueWithoutStateInput>
    createMany?: SalesTeamAddressCreateManyStateInputEnvelope
    set?: Enumerable<SalesTeamAddressWhereUniqueInput>
    disconnect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    delete?: Enumerable<SalesTeamAddressWhereUniqueInput>
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    update?: Enumerable<SalesTeamAddressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<SalesTeamAddressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<SalesTeamAddressScalarWhereInput>
  }

  export type SchoolMasterAddressUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutStateInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<SchoolMasterAddressUpsertWithWhereUniqueWithoutStateInput>
    createMany?: SchoolMasterAddressCreateManyStateInputEnvelope
    set?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    disconnect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    delete?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    update?: Enumerable<SchoolMasterAddressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<SchoolMasterAddressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<SchoolMasterAddressScalarWhereInput>
  }

  export type CityUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    connect?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type StudentAddressUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutStateInput>, Enumerable<StudentAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<StudentAddressUpsertWithWhereUniqueWithoutStateInput>
    createMany?: StudentAddressCreateManyStateInputEnvelope
    set?: Enumerable<StudentAddressWhereUniqueInput>
    disconnect?: Enumerable<StudentAddressWhereUniqueInput>
    delete?: Enumerable<StudentAddressWhereUniqueInput>
    connect?: Enumerable<StudentAddressWhereUniqueInput>
    update?: Enumerable<StudentAddressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<StudentAddressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<StudentAddressScalarWhereInput>
  }

  export type TeacherAddressUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutStateInput>, Enumerable<TeacherAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<TeacherAddressUpsertWithWhereUniqueWithoutStateInput>
    createMany?: TeacherAddressCreateManyStateInputEnvelope
    set?: Enumerable<TeacherAddressWhereUniqueInput>
    disconnect?: Enumerable<TeacherAddressWhereUniqueInput>
    delete?: Enumerable<TeacherAddressWhereUniqueInput>
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
    update?: Enumerable<TeacherAddressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<TeacherAddressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<TeacherAddressScalarWhereInput>
  }

  export type SalesTeamAddressUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutStateInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<SalesTeamAddressUpsertWithWhereUniqueWithoutStateInput>
    createMany?: SalesTeamAddressCreateManyStateInputEnvelope
    set?: Enumerable<SalesTeamAddressWhereUniqueInput>
    disconnect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    delete?: Enumerable<SalesTeamAddressWhereUniqueInput>
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    update?: Enumerable<SalesTeamAddressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<SalesTeamAddressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<SalesTeamAddressScalarWhereInput>
  }

  export type SchoolMasterAddressUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutStateInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<SchoolMasterAddressUpsertWithWhereUniqueWithoutStateInput>
    createMany?: SchoolMasterAddressCreateManyStateInputEnvelope
    set?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    disconnect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    delete?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    update?: Enumerable<SchoolMasterAddressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<SchoolMasterAddressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<SchoolMasterAddressScalarWhereInput>
  }

  export type StateCreateNestedOneWithoutCityInput = {
    create?: XOR<StateCreateWithoutCityInput, StateUncheckedCreateWithoutCityInput>
    connectOrCreate?: StateCreateOrConnectWithoutCityInput
    connect?: StateWhereUniqueInput
  }

  export type StudentAddressCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutCityInput>, Enumerable<StudentAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutCityInput>
    createMany?: StudentAddressCreateManyCityInputEnvelope
    connect?: Enumerable<StudentAddressWhereUniqueInput>
  }

  export type TeacherAddressCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutCityInput>, Enumerable<TeacherAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutCityInput>
    createMany?: TeacherAddressCreateManyCityInputEnvelope
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
  }

  export type SalesTeamAddressCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutCityInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutCityInput>
    createMany?: SalesTeamAddressCreateManyCityInputEnvelope
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
  }

  export type SchoolMasterAddressCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutCityInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutCityInput>
    createMany?: SchoolMasterAddressCreateManyCityInputEnvelope
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
  }

  export type StudentAddressUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutCityInput>, Enumerable<StudentAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutCityInput>
    createMany?: StudentAddressCreateManyCityInputEnvelope
    connect?: Enumerable<StudentAddressWhereUniqueInput>
  }

  export type TeacherAddressUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutCityInput>, Enumerable<TeacherAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutCityInput>
    createMany?: TeacherAddressCreateManyCityInputEnvelope
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
  }

  export type SalesTeamAddressUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutCityInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutCityInput>
    createMany?: SalesTeamAddressCreateManyCityInputEnvelope
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
  }

  export type SchoolMasterAddressUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutCityInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutCityInput>
    createMany?: SchoolMasterAddressCreateManyCityInputEnvelope
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
  }

  export type StateUpdateOneRequiredWithoutCityNestedInput = {
    create?: XOR<StateCreateWithoutCityInput, StateUncheckedCreateWithoutCityInput>
    connectOrCreate?: StateCreateOrConnectWithoutCityInput
    upsert?: StateUpsertWithoutCityInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutCityInput, StateUncheckedUpdateWithoutCityInput>
  }

  export type StudentAddressUpdateManyWithoutCityNestedInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutCityInput>, Enumerable<StudentAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<StudentAddressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: StudentAddressCreateManyCityInputEnvelope
    set?: Enumerable<StudentAddressWhereUniqueInput>
    disconnect?: Enumerable<StudentAddressWhereUniqueInput>
    delete?: Enumerable<StudentAddressWhereUniqueInput>
    connect?: Enumerable<StudentAddressWhereUniqueInput>
    update?: Enumerable<StudentAddressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<StudentAddressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<StudentAddressScalarWhereInput>
  }

  export type TeacherAddressUpdateManyWithoutCityNestedInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutCityInput>, Enumerable<TeacherAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<TeacherAddressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: TeacherAddressCreateManyCityInputEnvelope
    set?: Enumerable<TeacherAddressWhereUniqueInput>
    disconnect?: Enumerable<TeacherAddressWhereUniqueInput>
    delete?: Enumerable<TeacherAddressWhereUniqueInput>
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
    update?: Enumerable<TeacherAddressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<TeacherAddressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<TeacherAddressScalarWhereInput>
  }

  export type SalesTeamAddressUpdateManyWithoutCityNestedInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutCityInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<SalesTeamAddressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: SalesTeamAddressCreateManyCityInputEnvelope
    set?: Enumerable<SalesTeamAddressWhereUniqueInput>
    disconnect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    delete?: Enumerable<SalesTeamAddressWhereUniqueInput>
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    update?: Enumerable<SalesTeamAddressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<SalesTeamAddressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<SalesTeamAddressScalarWhereInput>
  }

  export type SchoolMasterAddressUpdateManyWithoutCityNestedInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutCityInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<SchoolMasterAddressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: SchoolMasterAddressCreateManyCityInputEnvelope
    set?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    disconnect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    delete?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    update?: Enumerable<SchoolMasterAddressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<SchoolMasterAddressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<SchoolMasterAddressScalarWhereInput>
  }

  export type StudentAddressUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutCityInput>, Enumerable<StudentAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<StudentAddressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: StudentAddressCreateManyCityInputEnvelope
    set?: Enumerable<StudentAddressWhereUniqueInput>
    disconnect?: Enumerable<StudentAddressWhereUniqueInput>
    delete?: Enumerable<StudentAddressWhereUniqueInput>
    connect?: Enumerable<StudentAddressWhereUniqueInput>
    update?: Enumerable<StudentAddressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<StudentAddressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<StudentAddressScalarWhereInput>
  }

  export type TeacherAddressUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutCityInput>, Enumerable<TeacherAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<TeacherAddressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: TeacherAddressCreateManyCityInputEnvelope
    set?: Enumerable<TeacherAddressWhereUniqueInput>
    disconnect?: Enumerable<TeacherAddressWhereUniqueInput>
    delete?: Enumerable<TeacherAddressWhereUniqueInput>
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
    update?: Enumerable<TeacherAddressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<TeacherAddressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<TeacherAddressScalarWhereInput>
  }

  export type SalesTeamAddressUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutCityInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<SalesTeamAddressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: SalesTeamAddressCreateManyCityInputEnvelope
    set?: Enumerable<SalesTeamAddressWhereUniqueInput>
    disconnect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    delete?: Enumerable<SalesTeamAddressWhereUniqueInput>
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    update?: Enumerable<SalesTeamAddressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<SalesTeamAddressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<SalesTeamAddressScalarWhereInput>
  }

  export type SchoolMasterAddressUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutCityInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<SchoolMasterAddressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: SchoolMasterAddressCreateManyCityInputEnvelope
    set?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    disconnect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    delete?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    update?: Enumerable<SchoolMasterAddressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<SchoolMasterAddressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<SchoolMasterAddressScalarWhereInput>
  }

  export type DesignationCreateNestedOneWithoutSalesTeamInput = {
    create?: XOR<DesignationCreateWithoutSalesTeamInput, DesignationUncheckedCreateWithoutSalesTeamInput>
    connectOrCreate?: DesignationCreateOrConnectWithoutSalesTeamInput
    connect?: DesignationWhereUniqueInput
  }

  export type SalesTeamDocumentsCreateNestedManyWithoutSalesTeamInput = {
    create?: XOR<Enumerable<SalesTeamDocumentsCreateWithoutSalesTeamInput>, Enumerable<SalesTeamDocumentsUncheckedCreateWithoutSalesTeamInput>>
    connectOrCreate?: Enumerable<SalesTeamDocumentsCreateOrConnectWithoutSalesTeamInput>
    createMany?: SalesTeamDocumentsCreateManySalesTeamInputEnvelope
    connect?: Enumerable<SalesTeamDocumentsWhereUniqueInput>
  }

  export type SalesTeamAddressCreateNestedManyWithoutSalesTeamInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutSalesTeamInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutSalesTeamInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutSalesTeamInput>
    createMany?: SalesTeamAddressCreateManySalesTeamInputEnvelope
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
  }

  export type schoolMasterCreateNestedManyWithoutSalesTeamInput = {
    create?: XOR<Enumerable<schoolMasterCreateWithoutSalesTeamInput>, Enumerable<schoolMasterUncheckedCreateWithoutSalesTeamInput>>
    connectOrCreate?: Enumerable<schoolMasterCreateOrConnectWithoutSalesTeamInput>
    createMany?: schoolMasterCreateManySalesTeamInputEnvelope
    connect?: Enumerable<schoolMasterWhereUniqueInput>
  }

  export type SalesTeamDocumentsUncheckedCreateNestedManyWithoutSalesTeamInput = {
    create?: XOR<Enumerable<SalesTeamDocumentsCreateWithoutSalesTeamInput>, Enumerable<SalesTeamDocumentsUncheckedCreateWithoutSalesTeamInput>>
    connectOrCreate?: Enumerable<SalesTeamDocumentsCreateOrConnectWithoutSalesTeamInput>
    createMany?: SalesTeamDocumentsCreateManySalesTeamInputEnvelope
    connect?: Enumerable<SalesTeamDocumentsWhereUniqueInput>
  }

  export type SalesTeamAddressUncheckedCreateNestedManyWithoutSalesTeamInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutSalesTeamInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutSalesTeamInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutSalesTeamInput>
    createMany?: SalesTeamAddressCreateManySalesTeamInputEnvelope
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
  }

  export type schoolMasterUncheckedCreateNestedManyWithoutSalesTeamInput = {
    create?: XOR<Enumerable<schoolMasterCreateWithoutSalesTeamInput>, Enumerable<schoolMasterUncheckedCreateWithoutSalesTeamInput>>
    connectOrCreate?: Enumerable<schoolMasterCreateOrConnectWithoutSalesTeamInput>
    createMany?: schoolMasterCreateManySalesTeamInputEnvelope
    connect?: Enumerable<schoolMasterWhereUniqueInput>
  }

  export type DesignationUpdateOneRequiredWithoutSalesTeamNestedInput = {
    create?: XOR<DesignationCreateWithoutSalesTeamInput, DesignationUncheckedCreateWithoutSalesTeamInput>
    connectOrCreate?: DesignationCreateOrConnectWithoutSalesTeamInput
    upsert?: DesignationUpsertWithoutSalesTeamInput
    connect?: DesignationWhereUniqueInput
    update?: XOR<DesignationUpdateWithoutSalesTeamInput, DesignationUncheckedUpdateWithoutSalesTeamInput>
  }

  export type SalesTeamDocumentsUpdateManyWithoutSalesTeamNestedInput = {
    create?: XOR<Enumerable<SalesTeamDocumentsCreateWithoutSalesTeamInput>, Enumerable<SalesTeamDocumentsUncheckedCreateWithoutSalesTeamInput>>
    connectOrCreate?: Enumerable<SalesTeamDocumentsCreateOrConnectWithoutSalesTeamInput>
    upsert?: Enumerable<SalesTeamDocumentsUpsertWithWhereUniqueWithoutSalesTeamInput>
    createMany?: SalesTeamDocumentsCreateManySalesTeamInputEnvelope
    set?: Enumerable<SalesTeamDocumentsWhereUniqueInput>
    disconnect?: Enumerable<SalesTeamDocumentsWhereUniqueInput>
    delete?: Enumerable<SalesTeamDocumentsWhereUniqueInput>
    connect?: Enumerable<SalesTeamDocumentsWhereUniqueInput>
    update?: Enumerable<SalesTeamDocumentsUpdateWithWhereUniqueWithoutSalesTeamInput>
    updateMany?: Enumerable<SalesTeamDocumentsUpdateManyWithWhereWithoutSalesTeamInput>
    deleteMany?: Enumerable<SalesTeamDocumentsScalarWhereInput>
  }

  export type SalesTeamAddressUpdateManyWithoutSalesTeamNestedInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutSalesTeamInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutSalesTeamInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutSalesTeamInput>
    upsert?: Enumerable<SalesTeamAddressUpsertWithWhereUniqueWithoutSalesTeamInput>
    createMany?: SalesTeamAddressCreateManySalesTeamInputEnvelope
    set?: Enumerable<SalesTeamAddressWhereUniqueInput>
    disconnect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    delete?: Enumerable<SalesTeamAddressWhereUniqueInput>
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    update?: Enumerable<SalesTeamAddressUpdateWithWhereUniqueWithoutSalesTeamInput>
    updateMany?: Enumerable<SalesTeamAddressUpdateManyWithWhereWithoutSalesTeamInput>
    deleteMany?: Enumerable<SalesTeamAddressScalarWhereInput>
  }

  export type schoolMasterUpdateManyWithoutSalesTeamNestedInput = {
    create?: XOR<Enumerable<schoolMasterCreateWithoutSalesTeamInput>, Enumerable<schoolMasterUncheckedCreateWithoutSalesTeamInput>>
    connectOrCreate?: Enumerable<schoolMasterCreateOrConnectWithoutSalesTeamInput>
    upsert?: Enumerable<schoolMasterUpsertWithWhereUniqueWithoutSalesTeamInput>
    createMany?: schoolMasterCreateManySalesTeamInputEnvelope
    set?: Enumerable<schoolMasterWhereUniqueInput>
    disconnect?: Enumerable<schoolMasterWhereUniqueInput>
    delete?: Enumerable<schoolMasterWhereUniqueInput>
    connect?: Enumerable<schoolMasterWhereUniqueInput>
    update?: Enumerable<schoolMasterUpdateWithWhereUniqueWithoutSalesTeamInput>
    updateMany?: Enumerable<schoolMasterUpdateManyWithWhereWithoutSalesTeamInput>
    deleteMany?: Enumerable<schoolMasterScalarWhereInput>
  }

  export type SalesTeamDocumentsUncheckedUpdateManyWithoutSalesTeamNestedInput = {
    create?: XOR<Enumerable<SalesTeamDocumentsCreateWithoutSalesTeamInput>, Enumerable<SalesTeamDocumentsUncheckedCreateWithoutSalesTeamInput>>
    connectOrCreate?: Enumerable<SalesTeamDocumentsCreateOrConnectWithoutSalesTeamInput>
    upsert?: Enumerable<SalesTeamDocumentsUpsertWithWhereUniqueWithoutSalesTeamInput>
    createMany?: SalesTeamDocumentsCreateManySalesTeamInputEnvelope
    set?: Enumerable<SalesTeamDocumentsWhereUniqueInput>
    disconnect?: Enumerable<SalesTeamDocumentsWhereUniqueInput>
    delete?: Enumerable<SalesTeamDocumentsWhereUniqueInput>
    connect?: Enumerable<SalesTeamDocumentsWhereUniqueInput>
    update?: Enumerable<SalesTeamDocumentsUpdateWithWhereUniqueWithoutSalesTeamInput>
    updateMany?: Enumerable<SalesTeamDocumentsUpdateManyWithWhereWithoutSalesTeamInput>
    deleteMany?: Enumerable<SalesTeamDocumentsScalarWhereInput>
  }

  export type SalesTeamAddressUncheckedUpdateManyWithoutSalesTeamNestedInput = {
    create?: XOR<Enumerable<SalesTeamAddressCreateWithoutSalesTeamInput>, Enumerable<SalesTeamAddressUncheckedCreateWithoutSalesTeamInput>>
    connectOrCreate?: Enumerable<SalesTeamAddressCreateOrConnectWithoutSalesTeamInput>
    upsert?: Enumerable<SalesTeamAddressUpsertWithWhereUniqueWithoutSalesTeamInput>
    createMany?: SalesTeamAddressCreateManySalesTeamInputEnvelope
    set?: Enumerable<SalesTeamAddressWhereUniqueInput>
    disconnect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    delete?: Enumerable<SalesTeamAddressWhereUniqueInput>
    connect?: Enumerable<SalesTeamAddressWhereUniqueInput>
    update?: Enumerable<SalesTeamAddressUpdateWithWhereUniqueWithoutSalesTeamInput>
    updateMany?: Enumerable<SalesTeamAddressUpdateManyWithWhereWithoutSalesTeamInput>
    deleteMany?: Enumerable<SalesTeamAddressScalarWhereInput>
  }

  export type schoolMasterUncheckedUpdateManyWithoutSalesTeamNestedInput = {
    create?: XOR<Enumerable<schoolMasterCreateWithoutSalesTeamInput>, Enumerable<schoolMasterUncheckedCreateWithoutSalesTeamInput>>
    connectOrCreate?: Enumerable<schoolMasterCreateOrConnectWithoutSalesTeamInput>
    upsert?: Enumerable<schoolMasterUpsertWithWhereUniqueWithoutSalesTeamInput>
    createMany?: schoolMasterCreateManySalesTeamInputEnvelope
    set?: Enumerable<schoolMasterWhereUniqueInput>
    disconnect?: Enumerable<schoolMasterWhereUniqueInput>
    delete?: Enumerable<schoolMasterWhereUniqueInput>
    connect?: Enumerable<schoolMasterWhereUniqueInput>
    update?: Enumerable<schoolMasterUpdateWithWhereUniqueWithoutSalesTeamInput>
    updateMany?: Enumerable<schoolMasterUpdateManyWithWhereWithoutSalesTeamInput>
    deleteMany?: Enumerable<schoolMasterScalarWhereInput>
  }

  export type SalesTeamCreateNestedOneWithoutSalesTeamDocumentsInput = {
    create?: XOR<SalesTeamCreateWithoutSalesTeamDocumentsInput, SalesTeamUncheckedCreateWithoutSalesTeamDocumentsInput>
    connectOrCreate?: SalesTeamCreateOrConnectWithoutSalesTeamDocumentsInput
    connect?: SalesTeamWhereUniqueInput
  }

  export type SalesTeamUpdateOneRequiredWithoutSalesTeamDocumentsNestedInput = {
    create?: XOR<SalesTeamCreateWithoutSalesTeamDocumentsInput, SalesTeamUncheckedCreateWithoutSalesTeamDocumentsInput>
    connectOrCreate?: SalesTeamCreateOrConnectWithoutSalesTeamDocumentsInput
    upsert?: SalesTeamUpsertWithoutSalesTeamDocumentsInput
    connect?: SalesTeamWhereUniqueInput
    update?: XOR<SalesTeamUpdateWithoutSalesTeamDocumentsInput, SalesTeamUncheckedUpdateWithoutSalesTeamDocumentsInput>
  }

  export type SalesTeamCreateNestedOneWithoutSalesTeamAddressInput = {
    create?: XOR<SalesTeamCreateWithoutSalesTeamAddressInput, SalesTeamUncheckedCreateWithoutSalesTeamAddressInput>
    connectOrCreate?: SalesTeamCreateOrConnectWithoutSalesTeamAddressInput
    connect?: SalesTeamWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutSalesTeamAddressInput = {
    create?: XOR<CountryCreateWithoutSalesTeamAddressInput, CountryUncheckedCreateWithoutSalesTeamAddressInput>
    connectOrCreate?: CountryCreateOrConnectWithoutSalesTeamAddressInput
    connect?: CountryWhereUniqueInput
  }

  export type StateCreateNestedOneWithoutSalesTeamAddressInput = {
    create?: XOR<StateCreateWithoutSalesTeamAddressInput, StateUncheckedCreateWithoutSalesTeamAddressInput>
    connectOrCreate?: StateCreateOrConnectWithoutSalesTeamAddressInput
    connect?: StateWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutSalesTeamAddressInput = {
    create?: XOR<CityCreateWithoutSalesTeamAddressInput, CityUncheckedCreateWithoutSalesTeamAddressInput>
    connectOrCreate?: CityCreateOrConnectWithoutSalesTeamAddressInput
    connect?: CityWhereUniqueInput
  }

  export type SalesTeamUpdateOneRequiredWithoutSalesTeamAddressNestedInput = {
    create?: XOR<SalesTeamCreateWithoutSalesTeamAddressInput, SalesTeamUncheckedCreateWithoutSalesTeamAddressInput>
    connectOrCreate?: SalesTeamCreateOrConnectWithoutSalesTeamAddressInput
    upsert?: SalesTeamUpsertWithoutSalesTeamAddressInput
    connect?: SalesTeamWhereUniqueInput
    update?: XOR<SalesTeamUpdateWithoutSalesTeamAddressInput, SalesTeamUncheckedUpdateWithoutSalesTeamAddressInput>
  }

  export type CountryUpdateOneRequiredWithoutSalesTeamAddressNestedInput = {
    create?: XOR<CountryCreateWithoutSalesTeamAddressInput, CountryUncheckedCreateWithoutSalesTeamAddressInput>
    connectOrCreate?: CountryCreateOrConnectWithoutSalesTeamAddressInput
    upsert?: CountryUpsertWithoutSalesTeamAddressInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutSalesTeamAddressInput, CountryUncheckedUpdateWithoutSalesTeamAddressInput>
  }

  export type StateUpdateOneRequiredWithoutSalesTeamAddressNestedInput = {
    create?: XOR<StateCreateWithoutSalesTeamAddressInput, StateUncheckedCreateWithoutSalesTeamAddressInput>
    connectOrCreate?: StateCreateOrConnectWithoutSalesTeamAddressInput
    upsert?: StateUpsertWithoutSalesTeamAddressInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutSalesTeamAddressInput, StateUncheckedUpdateWithoutSalesTeamAddressInput>
  }

  export type CityUpdateOneRequiredWithoutSalesTeamAddressNestedInput = {
    create?: XOR<CityCreateWithoutSalesTeamAddressInput, CityUncheckedCreateWithoutSalesTeamAddressInput>
    connectOrCreate?: CityCreateOrConnectWithoutSalesTeamAddressInput
    upsert?: CityUpsertWithoutSalesTeamAddressInput
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutSalesTeamAddressInput, CityUncheckedUpdateWithoutSalesTeamAddressInput>
  }

  export type schoolMasterCreateNestedManyWithoutSchoolBoardInput = {
    create?: XOR<Enumerable<schoolMasterCreateWithoutSchoolBoardInput>, Enumerable<schoolMasterUncheckedCreateWithoutSchoolBoardInput>>
    connectOrCreate?: Enumerable<schoolMasterCreateOrConnectWithoutSchoolBoardInput>
    createMany?: schoolMasterCreateManySchoolBoardInputEnvelope
    connect?: Enumerable<schoolMasterWhereUniqueInput>
  }

  export type schoolMasterUncheckedCreateNestedManyWithoutSchoolBoardInput = {
    create?: XOR<Enumerable<schoolMasterCreateWithoutSchoolBoardInput>, Enumerable<schoolMasterUncheckedCreateWithoutSchoolBoardInput>>
    connectOrCreate?: Enumerable<schoolMasterCreateOrConnectWithoutSchoolBoardInput>
    createMany?: schoolMasterCreateManySchoolBoardInputEnvelope
    connect?: Enumerable<schoolMasterWhereUniqueInput>
  }

  export type schoolMasterUpdateManyWithoutSchoolBoardNestedInput = {
    create?: XOR<Enumerable<schoolMasterCreateWithoutSchoolBoardInput>, Enumerable<schoolMasterUncheckedCreateWithoutSchoolBoardInput>>
    connectOrCreate?: Enumerable<schoolMasterCreateOrConnectWithoutSchoolBoardInput>
    upsert?: Enumerable<schoolMasterUpsertWithWhereUniqueWithoutSchoolBoardInput>
    createMany?: schoolMasterCreateManySchoolBoardInputEnvelope
    set?: Enumerable<schoolMasterWhereUniqueInput>
    disconnect?: Enumerable<schoolMasterWhereUniqueInput>
    delete?: Enumerable<schoolMasterWhereUniqueInput>
    connect?: Enumerable<schoolMasterWhereUniqueInput>
    update?: Enumerable<schoolMasterUpdateWithWhereUniqueWithoutSchoolBoardInput>
    updateMany?: Enumerable<schoolMasterUpdateManyWithWhereWithoutSchoolBoardInput>
    deleteMany?: Enumerable<schoolMasterScalarWhereInput>
  }

  export type schoolMasterUncheckedUpdateManyWithoutSchoolBoardNestedInput = {
    create?: XOR<Enumerable<schoolMasterCreateWithoutSchoolBoardInput>, Enumerable<schoolMasterUncheckedCreateWithoutSchoolBoardInput>>
    connectOrCreate?: Enumerable<schoolMasterCreateOrConnectWithoutSchoolBoardInput>
    upsert?: Enumerable<schoolMasterUpsertWithWhereUniqueWithoutSchoolBoardInput>
    createMany?: schoolMasterCreateManySchoolBoardInputEnvelope
    set?: Enumerable<schoolMasterWhereUniqueInput>
    disconnect?: Enumerable<schoolMasterWhereUniqueInput>
    delete?: Enumerable<schoolMasterWhereUniqueInput>
    connect?: Enumerable<schoolMasterWhereUniqueInput>
    update?: Enumerable<schoolMasterUpdateWithWhereUniqueWithoutSchoolBoardInput>
    updateMany?: Enumerable<schoolMasterUpdateManyWithWhereWithoutSchoolBoardInput>
    deleteMany?: Enumerable<schoolMasterScalarWhereInput>
  }

  export type schoolMasterCreateNestedManyWithoutSchoolTypeInput = {
    create?: XOR<Enumerable<schoolMasterCreateWithoutSchoolTypeInput>, Enumerable<schoolMasterUncheckedCreateWithoutSchoolTypeInput>>
    connectOrCreate?: Enumerable<schoolMasterCreateOrConnectWithoutSchoolTypeInput>
    createMany?: schoolMasterCreateManySchoolTypeInputEnvelope
    connect?: Enumerable<schoolMasterWhereUniqueInput>
  }

  export type schoolMasterUncheckedCreateNestedManyWithoutSchoolTypeInput = {
    create?: XOR<Enumerable<schoolMasterCreateWithoutSchoolTypeInput>, Enumerable<schoolMasterUncheckedCreateWithoutSchoolTypeInput>>
    connectOrCreate?: Enumerable<schoolMasterCreateOrConnectWithoutSchoolTypeInput>
    createMany?: schoolMasterCreateManySchoolTypeInputEnvelope
    connect?: Enumerable<schoolMasterWhereUniqueInput>
  }

  export type schoolMasterUpdateManyWithoutSchoolTypeNestedInput = {
    create?: XOR<Enumerable<schoolMasterCreateWithoutSchoolTypeInput>, Enumerable<schoolMasterUncheckedCreateWithoutSchoolTypeInput>>
    connectOrCreate?: Enumerable<schoolMasterCreateOrConnectWithoutSchoolTypeInput>
    upsert?: Enumerable<schoolMasterUpsertWithWhereUniqueWithoutSchoolTypeInput>
    createMany?: schoolMasterCreateManySchoolTypeInputEnvelope
    set?: Enumerable<schoolMasterWhereUniqueInput>
    disconnect?: Enumerable<schoolMasterWhereUniqueInput>
    delete?: Enumerable<schoolMasterWhereUniqueInput>
    connect?: Enumerable<schoolMasterWhereUniqueInput>
    update?: Enumerable<schoolMasterUpdateWithWhereUniqueWithoutSchoolTypeInput>
    updateMany?: Enumerable<schoolMasterUpdateManyWithWhereWithoutSchoolTypeInput>
    deleteMany?: Enumerable<schoolMasterScalarWhereInput>
  }

  export type schoolMasterUncheckedUpdateManyWithoutSchoolTypeNestedInput = {
    create?: XOR<Enumerable<schoolMasterCreateWithoutSchoolTypeInput>, Enumerable<schoolMasterUncheckedCreateWithoutSchoolTypeInput>>
    connectOrCreate?: Enumerable<schoolMasterCreateOrConnectWithoutSchoolTypeInput>
    upsert?: Enumerable<schoolMasterUpsertWithWhereUniqueWithoutSchoolTypeInput>
    createMany?: schoolMasterCreateManySchoolTypeInputEnvelope
    set?: Enumerable<schoolMasterWhereUniqueInput>
    disconnect?: Enumerable<schoolMasterWhereUniqueInput>
    delete?: Enumerable<schoolMasterWhereUniqueInput>
    connect?: Enumerable<schoolMasterWhereUniqueInput>
    update?: Enumerable<schoolMasterUpdateWithWhereUniqueWithoutSchoolTypeInput>
    updateMany?: Enumerable<schoolMasterUpdateManyWithWhereWithoutSchoolTypeInput>
    deleteMany?: Enumerable<schoolMasterScalarWhereInput>
  }

  export type schoolTypeCreateNestedOneWithoutSchoolMasterInput = {
    create?: XOR<schoolTypeCreateWithoutSchoolMasterInput, schoolTypeUncheckedCreateWithoutSchoolMasterInput>
    connectOrCreate?: schoolTypeCreateOrConnectWithoutSchoolMasterInput
    connect?: schoolTypeWhereUniqueInput
  }

  export type SchoolBoardCreateNestedOneWithoutSchoolMasterInput = {
    create?: XOR<SchoolBoardCreateWithoutSchoolMasterInput, SchoolBoardUncheckedCreateWithoutSchoolMasterInput>
    connectOrCreate?: SchoolBoardCreateOrConnectWithoutSchoolMasterInput
    connect?: SchoolBoardWhereUniqueInput
  }

  export type SalesTeamCreateNestedOneWithoutSchoolMasterInput = {
    create?: XOR<SalesTeamCreateWithoutSchoolMasterInput, SalesTeamUncheckedCreateWithoutSchoolMasterInput>
    connectOrCreate?: SalesTeamCreateOrConnectWithoutSchoolMasterInput
    connect?: SalesTeamWhereUniqueInput
  }

  export type SchoolMasterAddressCreateNestedManyWithoutSchoolIdInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutSchoolIdInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutSchoolIdInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutSchoolIdInput>
    createMany?: SchoolMasterAddressCreateManySchoolIdInputEnvelope
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
  }

  export type SchoolMasterAddressUncheckedCreateNestedManyWithoutSchoolIdInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutSchoolIdInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutSchoolIdInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutSchoolIdInput>
    createMany?: SchoolMasterAddressCreateManySchoolIdInputEnvelope
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
  }

  export type schoolTypeUpdateOneRequiredWithoutSchoolMasterNestedInput = {
    create?: XOR<schoolTypeCreateWithoutSchoolMasterInput, schoolTypeUncheckedCreateWithoutSchoolMasterInput>
    connectOrCreate?: schoolTypeCreateOrConnectWithoutSchoolMasterInput
    upsert?: schoolTypeUpsertWithoutSchoolMasterInput
    connect?: schoolTypeWhereUniqueInput
    update?: XOR<schoolTypeUpdateWithoutSchoolMasterInput, schoolTypeUncheckedUpdateWithoutSchoolMasterInput>
  }

  export type SchoolBoardUpdateOneRequiredWithoutSchoolMasterNestedInput = {
    create?: XOR<SchoolBoardCreateWithoutSchoolMasterInput, SchoolBoardUncheckedCreateWithoutSchoolMasterInput>
    connectOrCreate?: SchoolBoardCreateOrConnectWithoutSchoolMasterInput
    upsert?: SchoolBoardUpsertWithoutSchoolMasterInput
    connect?: SchoolBoardWhereUniqueInput
    update?: XOR<SchoolBoardUpdateWithoutSchoolMasterInput, SchoolBoardUncheckedUpdateWithoutSchoolMasterInput>
  }

  export type SalesTeamUpdateOneRequiredWithoutSchoolMasterNestedInput = {
    create?: XOR<SalesTeamCreateWithoutSchoolMasterInput, SalesTeamUncheckedCreateWithoutSchoolMasterInput>
    connectOrCreate?: SalesTeamCreateOrConnectWithoutSchoolMasterInput
    upsert?: SalesTeamUpsertWithoutSchoolMasterInput
    connect?: SalesTeamWhereUniqueInput
    update?: XOR<SalesTeamUpdateWithoutSchoolMasterInput, SalesTeamUncheckedUpdateWithoutSchoolMasterInput>
  }

  export type SchoolMasterAddressUpdateManyWithoutSchoolIdNestedInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutSchoolIdInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutSchoolIdInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutSchoolIdInput>
    upsert?: Enumerable<SchoolMasterAddressUpsertWithWhereUniqueWithoutSchoolIdInput>
    createMany?: SchoolMasterAddressCreateManySchoolIdInputEnvelope
    set?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    disconnect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    delete?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    update?: Enumerable<SchoolMasterAddressUpdateWithWhereUniqueWithoutSchoolIdInput>
    updateMany?: Enumerable<SchoolMasterAddressUpdateManyWithWhereWithoutSchoolIdInput>
    deleteMany?: Enumerable<SchoolMasterAddressScalarWhereInput>
  }

  export type SchoolMasterAddressUncheckedUpdateManyWithoutSchoolIdNestedInput = {
    create?: XOR<Enumerable<SchoolMasterAddressCreateWithoutSchoolIdInput>, Enumerable<SchoolMasterAddressUncheckedCreateWithoutSchoolIdInput>>
    connectOrCreate?: Enumerable<SchoolMasterAddressCreateOrConnectWithoutSchoolIdInput>
    upsert?: Enumerable<SchoolMasterAddressUpsertWithWhereUniqueWithoutSchoolIdInput>
    createMany?: SchoolMasterAddressCreateManySchoolIdInputEnvelope
    set?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    disconnect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    delete?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    connect?: Enumerable<SchoolMasterAddressWhereUniqueInput>
    update?: Enumerable<SchoolMasterAddressUpdateWithWhereUniqueWithoutSchoolIdInput>
    updateMany?: Enumerable<SchoolMasterAddressUpdateManyWithWhereWithoutSchoolIdInput>
    deleteMany?: Enumerable<SchoolMasterAddressScalarWhereInput>
  }

  export type schoolMasterCreateNestedOneWithoutSchoolMasterAddressInput = {
    create?: XOR<schoolMasterCreateWithoutSchoolMasterAddressInput, schoolMasterUncheckedCreateWithoutSchoolMasterAddressInput>
    connectOrCreate?: schoolMasterCreateOrConnectWithoutSchoolMasterAddressInput
    connect?: schoolMasterWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutSchoolMasterAddressInput = {
    create?: XOR<CountryCreateWithoutSchoolMasterAddressInput, CountryUncheckedCreateWithoutSchoolMasterAddressInput>
    connectOrCreate?: CountryCreateOrConnectWithoutSchoolMasterAddressInput
    connect?: CountryWhereUniqueInput
  }

  export type StateCreateNestedOneWithoutSchoolMasterAddressInput = {
    create?: XOR<StateCreateWithoutSchoolMasterAddressInput, StateUncheckedCreateWithoutSchoolMasterAddressInput>
    connectOrCreate?: StateCreateOrConnectWithoutSchoolMasterAddressInput
    connect?: StateWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutSchoolMasterAddressInput = {
    create?: XOR<CityCreateWithoutSchoolMasterAddressInput, CityUncheckedCreateWithoutSchoolMasterAddressInput>
    connectOrCreate?: CityCreateOrConnectWithoutSchoolMasterAddressInput
    connect?: CityWhereUniqueInput
  }

  export type schoolMasterUpdateOneRequiredWithoutSchoolMasterAddressNestedInput = {
    create?: XOR<schoolMasterCreateWithoutSchoolMasterAddressInput, schoolMasterUncheckedCreateWithoutSchoolMasterAddressInput>
    connectOrCreate?: schoolMasterCreateOrConnectWithoutSchoolMasterAddressInput
    upsert?: schoolMasterUpsertWithoutSchoolMasterAddressInput
    connect?: schoolMasterWhereUniqueInput
    update?: XOR<schoolMasterUpdateWithoutSchoolMasterAddressInput, schoolMasterUncheckedUpdateWithoutSchoolMasterAddressInput>
  }

  export type CountryUpdateOneRequiredWithoutSchoolMasterAddressNestedInput = {
    create?: XOR<CountryCreateWithoutSchoolMasterAddressInput, CountryUncheckedCreateWithoutSchoolMasterAddressInput>
    connectOrCreate?: CountryCreateOrConnectWithoutSchoolMasterAddressInput
    upsert?: CountryUpsertWithoutSchoolMasterAddressInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutSchoolMasterAddressInput, CountryUncheckedUpdateWithoutSchoolMasterAddressInput>
  }

  export type StateUpdateOneRequiredWithoutSchoolMasterAddressNestedInput = {
    create?: XOR<StateCreateWithoutSchoolMasterAddressInput, StateUncheckedCreateWithoutSchoolMasterAddressInput>
    connectOrCreate?: StateCreateOrConnectWithoutSchoolMasterAddressInput
    upsert?: StateUpsertWithoutSchoolMasterAddressInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutSchoolMasterAddressInput, StateUncheckedUpdateWithoutSchoolMasterAddressInput>
  }

  export type CityUpdateOneRequiredWithoutSchoolMasterAddressNestedInput = {
    create?: XOR<CityCreateWithoutSchoolMasterAddressInput, CityUncheckedCreateWithoutSchoolMasterAddressInput>
    connectOrCreate?: CityCreateOrConnectWithoutSchoolMasterAddressInput
    upsert?: CityUpsertWithoutSchoolMasterAddressInput
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutSchoolMasterAddressInput, CityUncheckedUpdateWithoutSchoolMasterAddressInput>
  }

  export type StudentDocumentsCreateNestedManyWithoutStudentIdInput = {
    create?: XOR<Enumerable<StudentDocumentsCreateWithoutStudentIdInput>, Enumerable<StudentDocumentsUncheckedCreateWithoutStudentIdInput>>
    connectOrCreate?: Enumerable<StudentDocumentsCreateOrConnectWithoutStudentIdInput>
    createMany?: StudentDocumentsCreateManyStudentIdInputEnvelope
    connect?: Enumerable<StudentDocumentsWhereUniqueInput>
  }

  export type StudentAddressCreateNestedManyWithoutStudentIdInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutStudentIdInput>, Enumerable<StudentAddressUncheckedCreateWithoutStudentIdInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutStudentIdInput>
    createMany?: StudentAddressCreateManyStudentIdInputEnvelope
    connect?: Enumerable<StudentAddressWhereUniqueInput>
  }

  export type StudentParentsCreateNestedManyWithoutStudentIdInput = {
    create?: XOR<Enumerable<StudentParentsCreateWithoutStudentIdInput>, Enumerable<StudentParentsUncheckedCreateWithoutStudentIdInput>>
    connectOrCreate?: Enumerable<StudentParentsCreateOrConnectWithoutStudentIdInput>
    createMany?: StudentParentsCreateManyStudentIdInputEnvelope
    connect?: Enumerable<StudentParentsWhereUniqueInput>
  }

  export type StudentDocumentsUncheckedCreateNestedManyWithoutStudentIdInput = {
    create?: XOR<Enumerable<StudentDocumentsCreateWithoutStudentIdInput>, Enumerable<StudentDocumentsUncheckedCreateWithoutStudentIdInput>>
    connectOrCreate?: Enumerable<StudentDocumentsCreateOrConnectWithoutStudentIdInput>
    createMany?: StudentDocumentsCreateManyStudentIdInputEnvelope
    connect?: Enumerable<StudentDocumentsWhereUniqueInput>
  }

  export type StudentAddressUncheckedCreateNestedManyWithoutStudentIdInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutStudentIdInput>, Enumerable<StudentAddressUncheckedCreateWithoutStudentIdInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutStudentIdInput>
    createMany?: StudentAddressCreateManyStudentIdInputEnvelope
    connect?: Enumerable<StudentAddressWhereUniqueInput>
  }

  export type StudentParentsUncheckedCreateNestedManyWithoutStudentIdInput = {
    create?: XOR<Enumerable<StudentParentsCreateWithoutStudentIdInput>, Enumerable<StudentParentsUncheckedCreateWithoutStudentIdInput>>
    connectOrCreate?: Enumerable<StudentParentsCreateOrConnectWithoutStudentIdInput>
    createMany?: StudentParentsCreateManyStudentIdInputEnvelope
    connect?: Enumerable<StudentParentsWhereUniqueInput>
  }

  export type StudentDocumentsUpdateManyWithoutStudentIdNestedInput = {
    create?: XOR<Enumerable<StudentDocumentsCreateWithoutStudentIdInput>, Enumerable<StudentDocumentsUncheckedCreateWithoutStudentIdInput>>
    connectOrCreate?: Enumerable<StudentDocumentsCreateOrConnectWithoutStudentIdInput>
    upsert?: Enumerable<StudentDocumentsUpsertWithWhereUniqueWithoutStudentIdInput>
    createMany?: StudentDocumentsCreateManyStudentIdInputEnvelope
    set?: Enumerable<StudentDocumentsWhereUniqueInput>
    disconnect?: Enumerable<StudentDocumentsWhereUniqueInput>
    delete?: Enumerable<StudentDocumentsWhereUniqueInput>
    connect?: Enumerable<StudentDocumentsWhereUniqueInput>
    update?: Enumerable<StudentDocumentsUpdateWithWhereUniqueWithoutStudentIdInput>
    updateMany?: Enumerable<StudentDocumentsUpdateManyWithWhereWithoutStudentIdInput>
    deleteMany?: Enumerable<StudentDocumentsScalarWhereInput>
  }

  export type StudentAddressUpdateManyWithoutStudentIdNestedInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutStudentIdInput>, Enumerable<StudentAddressUncheckedCreateWithoutStudentIdInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutStudentIdInput>
    upsert?: Enumerable<StudentAddressUpsertWithWhereUniqueWithoutStudentIdInput>
    createMany?: StudentAddressCreateManyStudentIdInputEnvelope
    set?: Enumerable<StudentAddressWhereUniqueInput>
    disconnect?: Enumerable<StudentAddressWhereUniqueInput>
    delete?: Enumerable<StudentAddressWhereUniqueInput>
    connect?: Enumerable<StudentAddressWhereUniqueInput>
    update?: Enumerable<StudentAddressUpdateWithWhereUniqueWithoutStudentIdInput>
    updateMany?: Enumerable<StudentAddressUpdateManyWithWhereWithoutStudentIdInput>
    deleteMany?: Enumerable<StudentAddressScalarWhereInput>
  }

  export type StudentParentsUpdateManyWithoutStudentIdNestedInput = {
    create?: XOR<Enumerable<StudentParentsCreateWithoutStudentIdInput>, Enumerable<StudentParentsUncheckedCreateWithoutStudentIdInput>>
    connectOrCreate?: Enumerable<StudentParentsCreateOrConnectWithoutStudentIdInput>
    upsert?: Enumerable<StudentParentsUpsertWithWhereUniqueWithoutStudentIdInput>
    createMany?: StudentParentsCreateManyStudentIdInputEnvelope
    set?: Enumerable<StudentParentsWhereUniqueInput>
    disconnect?: Enumerable<StudentParentsWhereUniqueInput>
    delete?: Enumerable<StudentParentsWhereUniqueInput>
    connect?: Enumerable<StudentParentsWhereUniqueInput>
    update?: Enumerable<StudentParentsUpdateWithWhereUniqueWithoutStudentIdInput>
    updateMany?: Enumerable<StudentParentsUpdateManyWithWhereWithoutStudentIdInput>
    deleteMany?: Enumerable<StudentParentsScalarWhereInput>
  }

  export type StudentDocumentsUncheckedUpdateManyWithoutStudentIdNestedInput = {
    create?: XOR<Enumerable<StudentDocumentsCreateWithoutStudentIdInput>, Enumerable<StudentDocumentsUncheckedCreateWithoutStudentIdInput>>
    connectOrCreate?: Enumerable<StudentDocumentsCreateOrConnectWithoutStudentIdInput>
    upsert?: Enumerable<StudentDocumentsUpsertWithWhereUniqueWithoutStudentIdInput>
    createMany?: StudentDocumentsCreateManyStudentIdInputEnvelope
    set?: Enumerable<StudentDocumentsWhereUniqueInput>
    disconnect?: Enumerable<StudentDocumentsWhereUniqueInput>
    delete?: Enumerable<StudentDocumentsWhereUniqueInput>
    connect?: Enumerable<StudentDocumentsWhereUniqueInput>
    update?: Enumerable<StudentDocumentsUpdateWithWhereUniqueWithoutStudentIdInput>
    updateMany?: Enumerable<StudentDocumentsUpdateManyWithWhereWithoutStudentIdInput>
    deleteMany?: Enumerable<StudentDocumentsScalarWhereInput>
  }

  export type StudentAddressUncheckedUpdateManyWithoutStudentIdNestedInput = {
    create?: XOR<Enumerable<StudentAddressCreateWithoutStudentIdInput>, Enumerable<StudentAddressUncheckedCreateWithoutStudentIdInput>>
    connectOrCreate?: Enumerable<StudentAddressCreateOrConnectWithoutStudentIdInput>
    upsert?: Enumerable<StudentAddressUpsertWithWhereUniqueWithoutStudentIdInput>
    createMany?: StudentAddressCreateManyStudentIdInputEnvelope
    set?: Enumerable<StudentAddressWhereUniqueInput>
    disconnect?: Enumerable<StudentAddressWhereUniqueInput>
    delete?: Enumerable<StudentAddressWhereUniqueInput>
    connect?: Enumerable<StudentAddressWhereUniqueInput>
    update?: Enumerable<StudentAddressUpdateWithWhereUniqueWithoutStudentIdInput>
    updateMany?: Enumerable<StudentAddressUpdateManyWithWhereWithoutStudentIdInput>
    deleteMany?: Enumerable<StudentAddressScalarWhereInput>
  }

  export type StudentParentsUncheckedUpdateManyWithoutStudentIdNestedInput = {
    create?: XOR<Enumerable<StudentParentsCreateWithoutStudentIdInput>, Enumerable<StudentParentsUncheckedCreateWithoutStudentIdInput>>
    connectOrCreate?: Enumerable<StudentParentsCreateOrConnectWithoutStudentIdInput>
    upsert?: Enumerable<StudentParentsUpsertWithWhereUniqueWithoutStudentIdInput>
    createMany?: StudentParentsCreateManyStudentIdInputEnvelope
    set?: Enumerable<StudentParentsWhereUniqueInput>
    disconnect?: Enumerable<StudentParentsWhereUniqueInput>
    delete?: Enumerable<StudentParentsWhereUniqueInput>
    connect?: Enumerable<StudentParentsWhereUniqueInput>
    update?: Enumerable<StudentParentsUpdateWithWhereUniqueWithoutStudentIdInput>
    updateMany?: Enumerable<StudentParentsUpdateManyWithWhereWithoutStudentIdInput>
    deleteMany?: Enumerable<StudentParentsScalarWhereInput>
  }

  export type StudentMasterCreateNestedOneWithoutStudentParentsInput = {
    create?: XOR<StudentMasterCreateWithoutStudentParentsInput, StudentMasterUncheckedCreateWithoutStudentParentsInput>
    connectOrCreate?: StudentMasterCreateOrConnectWithoutStudentParentsInput
    connect?: StudentMasterWhereUniqueInput
  }

  export type StudentMasterUpdateOneRequiredWithoutStudentParentsNestedInput = {
    create?: XOR<StudentMasterCreateWithoutStudentParentsInput, StudentMasterUncheckedCreateWithoutStudentParentsInput>
    connectOrCreate?: StudentMasterCreateOrConnectWithoutStudentParentsInput
    upsert?: StudentMasterUpsertWithoutStudentParentsInput
    connect?: StudentMasterWhereUniqueInput
    update?: XOR<StudentMasterUpdateWithoutStudentParentsInput, StudentMasterUncheckedUpdateWithoutStudentParentsInput>
  }

  export type StudentMasterCreateNestedOneWithoutStudentDetailInput = {
    create?: XOR<StudentMasterCreateWithoutStudentDetailInput, StudentMasterUncheckedCreateWithoutStudentDetailInput>
    connectOrCreate?: StudentMasterCreateOrConnectWithoutStudentDetailInput
    connect?: StudentMasterWhereUniqueInput
  }

  export type StudentMasterUpdateOneRequiredWithoutStudentDetailNestedInput = {
    create?: XOR<StudentMasterCreateWithoutStudentDetailInput, StudentMasterUncheckedCreateWithoutStudentDetailInput>
    connectOrCreate?: StudentMasterCreateOrConnectWithoutStudentDetailInput
    upsert?: StudentMasterUpsertWithoutStudentDetailInput
    connect?: StudentMasterWhereUniqueInput
    update?: XOR<StudentMasterUpdateWithoutStudentDetailInput, StudentMasterUncheckedUpdateWithoutStudentDetailInput>
  }

  export type StudentMasterCreateNestedOneWithoutStudentAddressInput = {
    create?: XOR<StudentMasterCreateWithoutStudentAddressInput, StudentMasterUncheckedCreateWithoutStudentAddressInput>
    connectOrCreate?: StudentMasterCreateOrConnectWithoutStudentAddressInput
    connect?: StudentMasterWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutStudentAddressInput = {
    create?: XOR<CountryCreateWithoutStudentAddressInput, CountryUncheckedCreateWithoutStudentAddressInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStudentAddressInput
    connect?: CountryWhereUniqueInput
  }

  export type StateCreateNestedOneWithoutStudentAddressInput = {
    create?: XOR<StateCreateWithoutStudentAddressInput, StateUncheckedCreateWithoutStudentAddressInput>
    connectOrCreate?: StateCreateOrConnectWithoutStudentAddressInput
    connect?: StateWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutStudentAddressInput = {
    create?: XOR<CityCreateWithoutStudentAddressInput, CityUncheckedCreateWithoutStudentAddressInput>
    connectOrCreate?: CityCreateOrConnectWithoutStudentAddressInput
    connect?: CityWhereUniqueInput
  }

  export type StudentMasterUpdateOneRequiredWithoutStudentAddressNestedInput = {
    create?: XOR<StudentMasterCreateWithoutStudentAddressInput, StudentMasterUncheckedCreateWithoutStudentAddressInput>
    connectOrCreate?: StudentMasterCreateOrConnectWithoutStudentAddressInput
    upsert?: StudentMasterUpsertWithoutStudentAddressInput
    connect?: StudentMasterWhereUniqueInput
    update?: XOR<StudentMasterUpdateWithoutStudentAddressInput, StudentMasterUncheckedUpdateWithoutStudentAddressInput>
  }

  export type CountryUpdateOneRequiredWithoutStudentAddressNestedInput = {
    create?: XOR<CountryCreateWithoutStudentAddressInput, CountryUncheckedCreateWithoutStudentAddressInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStudentAddressInput
    upsert?: CountryUpsertWithoutStudentAddressInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutStudentAddressInput, CountryUncheckedUpdateWithoutStudentAddressInput>
  }

  export type StateUpdateOneRequiredWithoutStudentAddressNestedInput = {
    create?: XOR<StateCreateWithoutStudentAddressInput, StateUncheckedCreateWithoutStudentAddressInput>
    connectOrCreate?: StateCreateOrConnectWithoutStudentAddressInput
    upsert?: StateUpsertWithoutStudentAddressInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutStudentAddressInput, StateUncheckedUpdateWithoutStudentAddressInput>
  }

  export type CityUpdateOneRequiredWithoutStudentAddressNestedInput = {
    create?: XOR<CityCreateWithoutStudentAddressInput, CityUncheckedCreateWithoutStudentAddressInput>
    connectOrCreate?: CityCreateOrConnectWithoutStudentAddressInput
    upsert?: CityUpsertWithoutStudentAddressInput
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutStudentAddressInput, CityUncheckedUpdateWithoutStudentAddressInput>
  }

  export type TeacherMasterCreateNestedManyWithoutTeacherdepartmentInput = {
    create?: XOR<Enumerable<TeacherMasterCreateWithoutTeacherdepartmentInput>, Enumerable<TeacherMasterUncheckedCreateWithoutTeacherdepartmentInput>>
    connectOrCreate?: Enumerable<TeacherMasterCreateOrConnectWithoutTeacherdepartmentInput>
    createMany?: TeacherMasterCreateManyTeacherdepartmentInputEnvelope
    connect?: Enumerable<TeacherMasterWhereUniqueInput>
  }

  export type TeacherMasterUncheckedCreateNestedManyWithoutTeacherdepartmentInput = {
    create?: XOR<Enumerable<TeacherMasterCreateWithoutTeacherdepartmentInput>, Enumerable<TeacherMasterUncheckedCreateWithoutTeacherdepartmentInput>>
    connectOrCreate?: Enumerable<TeacherMasterCreateOrConnectWithoutTeacherdepartmentInput>
    createMany?: TeacherMasterCreateManyTeacherdepartmentInputEnvelope
    connect?: Enumerable<TeacherMasterWhereUniqueInput>
  }

  export type TeacherMasterUpdateManyWithoutTeacherdepartmentNestedInput = {
    create?: XOR<Enumerable<TeacherMasterCreateWithoutTeacherdepartmentInput>, Enumerable<TeacherMasterUncheckedCreateWithoutTeacherdepartmentInput>>
    connectOrCreate?: Enumerable<TeacherMasterCreateOrConnectWithoutTeacherdepartmentInput>
    upsert?: Enumerable<TeacherMasterUpsertWithWhereUniqueWithoutTeacherdepartmentInput>
    createMany?: TeacherMasterCreateManyTeacherdepartmentInputEnvelope
    set?: Enumerable<TeacherMasterWhereUniqueInput>
    disconnect?: Enumerable<TeacherMasterWhereUniqueInput>
    delete?: Enumerable<TeacherMasterWhereUniqueInput>
    connect?: Enumerable<TeacherMasterWhereUniqueInput>
    update?: Enumerable<TeacherMasterUpdateWithWhereUniqueWithoutTeacherdepartmentInput>
    updateMany?: Enumerable<TeacherMasterUpdateManyWithWhereWithoutTeacherdepartmentInput>
    deleteMany?: Enumerable<TeacherMasterScalarWhereInput>
  }

  export type TeacherMasterUncheckedUpdateManyWithoutTeacherdepartmentNestedInput = {
    create?: XOR<Enumerable<TeacherMasterCreateWithoutTeacherdepartmentInput>, Enumerable<TeacherMasterUncheckedCreateWithoutTeacherdepartmentInput>>
    connectOrCreate?: Enumerable<TeacherMasterCreateOrConnectWithoutTeacherdepartmentInput>
    upsert?: Enumerable<TeacherMasterUpsertWithWhereUniqueWithoutTeacherdepartmentInput>
    createMany?: TeacherMasterCreateManyTeacherdepartmentInputEnvelope
    set?: Enumerable<TeacherMasterWhereUniqueInput>
    disconnect?: Enumerable<TeacherMasterWhereUniqueInput>
    delete?: Enumerable<TeacherMasterWhereUniqueInput>
    connect?: Enumerable<TeacherMasterWhereUniqueInput>
    update?: Enumerable<TeacherMasterUpdateWithWhereUniqueWithoutTeacherdepartmentInput>
    updateMany?: Enumerable<TeacherMasterUpdateManyWithWhereWithoutTeacherdepartmentInput>
    deleteMany?: Enumerable<TeacherMasterScalarWhereInput>
  }

  export type TeacherDepartmentCreateNestedOneWithoutTeacherMasterInput = {
    create?: XOR<TeacherDepartmentCreateWithoutTeacherMasterInput, TeacherDepartmentUncheckedCreateWithoutTeacherMasterInput>
    connectOrCreate?: TeacherDepartmentCreateOrConnectWithoutTeacherMasterInput
    connect?: TeacherDepartmentWhereUniqueInput
  }

  export type DesignationCreateNestedOneWithoutTeacherMasterInput = {
    create?: XOR<DesignationCreateWithoutTeacherMasterInput, DesignationUncheckedCreateWithoutTeacherMasterInput>
    connectOrCreate?: DesignationCreateOrConnectWithoutTeacherMasterInput
    connect?: DesignationWhereUniqueInput
  }

  export type TeacherDocumentsCreateNestedManyWithoutTeacherIdInput = {
    create?: XOR<Enumerable<TeacherDocumentsCreateWithoutTeacherIdInput>, Enumerable<TeacherDocumentsUncheckedCreateWithoutTeacherIdInput>>
    connectOrCreate?: Enumerable<TeacherDocumentsCreateOrConnectWithoutTeacherIdInput>
    createMany?: TeacherDocumentsCreateManyTeacherIdInputEnvelope
    connect?: Enumerable<TeacherDocumentsWhereUniqueInput>
  }

  export type TeacherAddressCreateNestedManyWithoutTeacherIdInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutTeacherIdInput>, Enumerable<TeacherAddressUncheckedCreateWithoutTeacherIdInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutTeacherIdInput>
    createMany?: TeacherAddressCreateManyTeacherIdInputEnvelope
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
  }

  export type TeacherExprienceCreateNestedManyWithoutTeacherIdInput = {
    create?: XOR<Enumerable<TeacherExprienceCreateWithoutTeacherIdInput>, Enumerable<TeacherExprienceUncheckedCreateWithoutTeacherIdInput>>
    connectOrCreate?: Enumerable<TeacherExprienceCreateOrConnectWithoutTeacherIdInput>
    createMany?: TeacherExprienceCreateManyTeacherIdInputEnvelope
    connect?: Enumerable<TeacherExprienceWhereUniqueInput>
  }

  export type TeacherDocumentsUncheckedCreateNestedManyWithoutTeacherIdInput = {
    create?: XOR<Enumerable<TeacherDocumentsCreateWithoutTeacherIdInput>, Enumerable<TeacherDocumentsUncheckedCreateWithoutTeacherIdInput>>
    connectOrCreate?: Enumerable<TeacherDocumentsCreateOrConnectWithoutTeacherIdInput>
    createMany?: TeacherDocumentsCreateManyTeacherIdInputEnvelope
    connect?: Enumerable<TeacherDocumentsWhereUniqueInput>
  }

  export type TeacherAddressUncheckedCreateNestedManyWithoutTeacherIdInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutTeacherIdInput>, Enumerable<TeacherAddressUncheckedCreateWithoutTeacherIdInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutTeacherIdInput>
    createMany?: TeacherAddressCreateManyTeacherIdInputEnvelope
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
  }

  export type TeacherExprienceUncheckedCreateNestedManyWithoutTeacherIdInput = {
    create?: XOR<Enumerable<TeacherExprienceCreateWithoutTeacherIdInput>, Enumerable<TeacherExprienceUncheckedCreateWithoutTeacherIdInput>>
    connectOrCreate?: Enumerable<TeacherExprienceCreateOrConnectWithoutTeacherIdInput>
    createMany?: TeacherExprienceCreateManyTeacherIdInputEnvelope
    connect?: Enumerable<TeacherExprienceWhereUniqueInput>
  }

  export type TeacherDepartmentUpdateOneRequiredWithoutTeacherMasterNestedInput = {
    create?: XOR<TeacherDepartmentCreateWithoutTeacherMasterInput, TeacherDepartmentUncheckedCreateWithoutTeacherMasterInput>
    connectOrCreate?: TeacherDepartmentCreateOrConnectWithoutTeacherMasterInput
    upsert?: TeacherDepartmentUpsertWithoutTeacherMasterInput
    connect?: TeacherDepartmentWhereUniqueInput
    update?: XOR<TeacherDepartmentUpdateWithoutTeacherMasterInput, TeacherDepartmentUncheckedUpdateWithoutTeacherMasterInput>
  }

  export type DesignationUpdateOneRequiredWithoutTeacherMasterNestedInput = {
    create?: XOR<DesignationCreateWithoutTeacherMasterInput, DesignationUncheckedCreateWithoutTeacherMasterInput>
    connectOrCreate?: DesignationCreateOrConnectWithoutTeacherMasterInput
    upsert?: DesignationUpsertWithoutTeacherMasterInput
    connect?: DesignationWhereUniqueInput
    update?: XOR<DesignationUpdateWithoutTeacherMasterInput, DesignationUncheckedUpdateWithoutTeacherMasterInput>
  }

  export type TeacherDocumentsUpdateManyWithoutTeacherIdNestedInput = {
    create?: XOR<Enumerable<TeacherDocumentsCreateWithoutTeacherIdInput>, Enumerable<TeacherDocumentsUncheckedCreateWithoutTeacherIdInput>>
    connectOrCreate?: Enumerable<TeacherDocumentsCreateOrConnectWithoutTeacherIdInput>
    upsert?: Enumerable<TeacherDocumentsUpsertWithWhereUniqueWithoutTeacherIdInput>
    createMany?: TeacherDocumentsCreateManyTeacherIdInputEnvelope
    set?: Enumerable<TeacherDocumentsWhereUniqueInput>
    disconnect?: Enumerable<TeacherDocumentsWhereUniqueInput>
    delete?: Enumerable<TeacherDocumentsWhereUniqueInput>
    connect?: Enumerable<TeacherDocumentsWhereUniqueInput>
    update?: Enumerable<TeacherDocumentsUpdateWithWhereUniqueWithoutTeacherIdInput>
    updateMany?: Enumerable<TeacherDocumentsUpdateManyWithWhereWithoutTeacherIdInput>
    deleteMany?: Enumerable<TeacherDocumentsScalarWhereInput>
  }

  export type TeacherAddressUpdateManyWithoutTeacherIdNestedInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutTeacherIdInput>, Enumerable<TeacherAddressUncheckedCreateWithoutTeacherIdInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutTeacherIdInput>
    upsert?: Enumerable<TeacherAddressUpsertWithWhereUniqueWithoutTeacherIdInput>
    createMany?: TeacherAddressCreateManyTeacherIdInputEnvelope
    set?: Enumerable<TeacherAddressWhereUniqueInput>
    disconnect?: Enumerable<TeacherAddressWhereUniqueInput>
    delete?: Enumerable<TeacherAddressWhereUniqueInput>
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
    update?: Enumerable<TeacherAddressUpdateWithWhereUniqueWithoutTeacherIdInput>
    updateMany?: Enumerable<TeacherAddressUpdateManyWithWhereWithoutTeacherIdInput>
    deleteMany?: Enumerable<TeacherAddressScalarWhereInput>
  }

  export type TeacherExprienceUpdateManyWithoutTeacherIdNestedInput = {
    create?: XOR<Enumerable<TeacherExprienceCreateWithoutTeacherIdInput>, Enumerable<TeacherExprienceUncheckedCreateWithoutTeacherIdInput>>
    connectOrCreate?: Enumerable<TeacherExprienceCreateOrConnectWithoutTeacherIdInput>
    upsert?: Enumerable<TeacherExprienceUpsertWithWhereUniqueWithoutTeacherIdInput>
    createMany?: TeacherExprienceCreateManyTeacherIdInputEnvelope
    set?: Enumerable<TeacherExprienceWhereUniqueInput>
    disconnect?: Enumerable<TeacherExprienceWhereUniqueInput>
    delete?: Enumerable<TeacherExprienceWhereUniqueInput>
    connect?: Enumerable<TeacherExprienceWhereUniqueInput>
    update?: Enumerable<TeacherExprienceUpdateWithWhereUniqueWithoutTeacherIdInput>
    updateMany?: Enumerable<TeacherExprienceUpdateManyWithWhereWithoutTeacherIdInput>
    deleteMany?: Enumerable<TeacherExprienceScalarWhereInput>
  }

  export type TeacherDocumentsUncheckedUpdateManyWithoutTeacherIdNestedInput = {
    create?: XOR<Enumerable<TeacherDocumentsCreateWithoutTeacherIdInput>, Enumerable<TeacherDocumentsUncheckedCreateWithoutTeacherIdInput>>
    connectOrCreate?: Enumerable<TeacherDocumentsCreateOrConnectWithoutTeacherIdInput>
    upsert?: Enumerable<TeacherDocumentsUpsertWithWhereUniqueWithoutTeacherIdInput>
    createMany?: TeacherDocumentsCreateManyTeacherIdInputEnvelope
    set?: Enumerable<TeacherDocumentsWhereUniqueInput>
    disconnect?: Enumerable<TeacherDocumentsWhereUniqueInput>
    delete?: Enumerable<TeacherDocumentsWhereUniqueInput>
    connect?: Enumerable<TeacherDocumentsWhereUniqueInput>
    update?: Enumerable<TeacherDocumentsUpdateWithWhereUniqueWithoutTeacherIdInput>
    updateMany?: Enumerable<TeacherDocumentsUpdateManyWithWhereWithoutTeacherIdInput>
    deleteMany?: Enumerable<TeacherDocumentsScalarWhereInput>
  }

  export type TeacherAddressUncheckedUpdateManyWithoutTeacherIdNestedInput = {
    create?: XOR<Enumerable<TeacherAddressCreateWithoutTeacherIdInput>, Enumerable<TeacherAddressUncheckedCreateWithoutTeacherIdInput>>
    connectOrCreate?: Enumerable<TeacherAddressCreateOrConnectWithoutTeacherIdInput>
    upsert?: Enumerable<TeacherAddressUpsertWithWhereUniqueWithoutTeacherIdInput>
    createMany?: TeacherAddressCreateManyTeacherIdInputEnvelope
    set?: Enumerable<TeacherAddressWhereUniqueInput>
    disconnect?: Enumerable<TeacherAddressWhereUniqueInput>
    delete?: Enumerable<TeacherAddressWhereUniqueInput>
    connect?: Enumerable<TeacherAddressWhereUniqueInput>
    update?: Enumerable<TeacherAddressUpdateWithWhereUniqueWithoutTeacherIdInput>
    updateMany?: Enumerable<TeacherAddressUpdateManyWithWhereWithoutTeacherIdInput>
    deleteMany?: Enumerable<TeacherAddressScalarWhereInput>
  }

  export type TeacherExprienceUncheckedUpdateManyWithoutTeacherIdNestedInput = {
    create?: XOR<Enumerable<TeacherExprienceCreateWithoutTeacherIdInput>, Enumerable<TeacherExprienceUncheckedCreateWithoutTeacherIdInput>>
    connectOrCreate?: Enumerable<TeacherExprienceCreateOrConnectWithoutTeacherIdInput>
    upsert?: Enumerable<TeacherExprienceUpsertWithWhereUniqueWithoutTeacherIdInput>
    createMany?: TeacherExprienceCreateManyTeacherIdInputEnvelope
    set?: Enumerable<TeacherExprienceWhereUniqueInput>
    disconnect?: Enumerable<TeacherExprienceWhereUniqueInput>
    delete?: Enumerable<TeacherExprienceWhereUniqueInput>
    connect?: Enumerable<TeacherExprienceWhereUniqueInput>
    update?: Enumerable<TeacherExprienceUpdateWithWhereUniqueWithoutTeacherIdInput>
    updateMany?: Enumerable<TeacherExprienceUpdateManyWithWhereWithoutTeacherIdInput>
    deleteMany?: Enumerable<TeacherExprienceScalarWhereInput>
  }

  export type TeacherMasterCreateNestedOneWithoutTeacherExprienceInput = {
    create?: XOR<TeacherMasterCreateWithoutTeacherExprienceInput, TeacherMasterUncheckedCreateWithoutTeacherExprienceInput>
    connectOrCreate?: TeacherMasterCreateOrConnectWithoutTeacherExprienceInput
    connect?: TeacherMasterWhereUniqueInput
  }

  export type TeacherExprienceCreateskillsInput = {
    set: Enumerable<InputJsonValue>
  }

  export type TeacherMasterUpdateOneRequiredWithoutTeacherExprienceNestedInput = {
    create?: XOR<TeacherMasterCreateWithoutTeacherExprienceInput, TeacherMasterUncheckedCreateWithoutTeacherExprienceInput>
    connectOrCreate?: TeacherMasterCreateOrConnectWithoutTeacherExprienceInput
    upsert?: TeacherMasterUpsertWithoutTeacherExprienceInput
    connect?: TeacherMasterWhereUniqueInput
    update?: XOR<TeacherMasterUpdateWithoutTeacherExprienceInput, TeacherMasterUncheckedUpdateWithoutTeacherExprienceInput>
  }

  export type TeacherExprienceUpdateskillsInput = {
    set?: Enumerable<InputJsonValue>
    push?: InputJsonValue | Enumerable<InputJsonValue>
  }

  export type TeacherMasterCreateNestedOneWithoutTeacherDocumentsInput = {
    create?: XOR<TeacherMasterCreateWithoutTeacherDocumentsInput, TeacherMasterUncheckedCreateWithoutTeacherDocumentsInput>
    connectOrCreate?: TeacherMasterCreateOrConnectWithoutTeacherDocumentsInput
    connect?: TeacherMasterWhereUniqueInput
  }

  export type TeacherMasterUpdateOneRequiredWithoutTeacherDocumentsNestedInput = {
    create?: XOR<TeacherMasterCreateWithoutTeacherDocumentsInput, TeacherMasterUncheckedCreateWithoutTeacherDocumentsInput>
    connectOrCreate?: TeacherMasterCreateOrConnectWithoutTeacherDocumentsInput
    upsert?: TeacherMasterUpsertWithoutTeacherDocumentsInput
    connect?: TeacherMasterWhereUniqueInput
    update?: XOR<TeacherMasterUpdateWithoutTeacherDocumentsInput, TeacherMasterUncheckedUpdateWithoutTeacherDocumentsInput>
  }

  export type TeacherMasterCreateNestedOneWithoutTeacherAddressInput = {
    create?: XOR<TeacherMasterCreateWithoutTeacherAddressInput, TeacherMasterUncheckedCreateWithoutTeacherAddressInput>
    connectOrCreate?: TeacherMasterCreateOrConnectWithoutTeacherAddressInput
    connect?: TeacherMasterWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutTeacherAddressInput = {
    create?: XOR<CountryCreateWithoutTeacherAddressInput, CountryUncheckedCreateWithoutTeacherAddressInput>
    connectOrCreate?: CountryCreateOrConnectWithoutTeacherAddressInput
    connect?: CountryWhereUniqueInput
  }

  export type StateCreateNestedOneWithoutTeacherAddressInput = {
    create?: XOR<StateCreateWithoutTeacherAddressInput, StateUncheckedCreateWithoutTeacherAddressInput>
    connectOrCreate?: StateCreateOrConnectWithoutTeacherAddressInput
    connect?: StateWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutTeacherAddressInput = {
    create?: XOR<CityCreateWithoutTeacherAddressInput, CityUncheckedCreateWithoutTeacherAddressInput>
    connectOrCreate?: CityCreateOrConnectWithoutTeacherAddressInput
    connect?: CityWhereUniqueInput
  }

  export type TeacherMasterUpdateOneRequiredWithoutTeacherAddressNestedInput = {
    create?: XOR<TeacherMasterCreateWithoutTeacherAddressInput, TeacherMasterUncheckedCreateWithoutTeacherAddressInput>
    connectOrCreate?: TeacherMasterCreateOrConnectWithoutTeacherAddressInput
    upsert?: TeacherMasterUpsertWithoutTeacherAddressInput
    connect?: TeacherMasterWhereUniqueInput
    update?: XOR<TeacherMasterUpdateWithoutTeacherAddressInput, TeacherMasterUncheckedUpdateWithoutTeacherAddressInput>
  }

  export type CountryUpdateOneRequiredWithoutTeacherAddressNestedInput = {
    create?: XOR<CountryCreateWithoutTeacherAddressInput, CountryUncheckedCreateWithoutTeacherAddressInput>
    connectOrCreate?: CountryCreateOrConnectWithoutTeacherAddressInput
    upsert?: CountryUpsertWithoutTeacherAddressInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutTeacherAddressInput, CountryUncheckedUpdateWithoutTeacherAddressInput>
  }

  export type StateUpdateOneRequiredWithoutTeacherAddressNestedInput = {
    create?: XOR<StateCreateWithoutTeacherAddressInput, StateUncheckedCreateWithoutTeacherAddressInput>
    connectOrCreate?: StateCreateOrConnectWithoutTeacherAddressInput
    upsert?: StateUpsertWithoutTeacherAddressInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutTeacherAddressInput, StateUncheckedUpdateWithoutTeacherAddressInput>
  }

  export type CityUpdateOneRequiredWithoutTeacherAddressNestedInput = {
    create?: XOR<CityCreateWithoutTeacherAddressInput, CityUncheckedCreateWithoutTeacherAddressInput>
    connectOrCreate?: CityCreateOrConnectWithoutTeacherAddressInput
    upsert?: CityUpsertWithoutTeacherAddressInput
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutTeacherAddressInput, CityUncheckedUpdateWithoutTeacherAddressInput>
  }

  export type NestedUuidFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    not?: NestedUuidFilter | string
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedUuidWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    not?: NestedUuidWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type SalesTeamCreateWithoutDesignationInput = {
    id?: string
    email: string
    phone: string
    password: string
    dob: Date | string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeamDocuments?: SalesTeamDocumentsCreateNestedManyWithoutSalesTeamInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutSalesTeamInput
    schoolMaster?: schoolMasterCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamUncheckedCreateWithoutDesignationInput = {
    id?: string
    email: string
    phone: string
    password: string
    dob: Date | string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeamDocuments?: SalesTeamDocumentsUncheckedCreateNestedManyWithoutSalesTeamInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutSalesTeamInput
    schoolMaster?: schoolMasterUncheckedCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamCreateOrConnectWithoutDesignationInput = {
    where: SalesTeamWhereUniqueInput
    create: XOR<SalesTeamCreateWithoutDesignationInput, SalesTeamUncheckedCreateWithoutDesignationInput>
  }

  export type SalesTeamCreateManyDesignationInputEnvelope = {
    data: Enumerable<SalesTeamCreateManyDesignationInput>
    skipDuplicates?: boolean
  }

  export type TeacherMasterCreateWithoutDesignationInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    Teacherdepartment: TeacherDepartmentCreateNestedOneWithoutTeacherMasterInput
    profileImg: string
    joiningDate: Date | string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherDocuments?: TeacherDocumentsCreateNestedManyWithoutTeacherIdInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutTeacherIdInput
    TeacherExprience?: TeacherExprienceCreateNestedManyWithoutTeacherIdInput
  }

  export type TeacherMasterUncheckedCreateWithoutDesignationInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    fkTeacherDepartmentId: string
    profileImg: string
    joiningDate: Date | string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherDocuments?: TeacherDocumentsUncheckedCreateNestedManyWithoutTeacherIdInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutTeacherIdInput
    TeacherExprience?: TeacherExprienceUncheckedCreateNestedManyWithoutTeacherIdInput
  }

  export type TeacherMasterCreateOrConnectWithoutDesignationInput = {
    where: TeacherMasterWhereUniqueInput
    create: XOR<TeacherMasterCreateWithoutDesignationInput, TeacherMasterUncheckedCreateWithoutDesignationInput>
  }

  export type TeacherMasterCreateManyDesignationInputEnvelope = {
    data: Enumerable<TeacherMasterCreateManyDesignationInput>
    skipDuplicates?: boolean
  }

  export type SalesTeamUpsertWithWhereUniqueWithoutDesignationInput = {
    where: SalesTeamWhereUniqueInput
    update: XOR<SalesTeamUpdateWithoutDesignationInput, SalesTeamUncheckedUpdateWithoutDesignationInput>
    create: XOR<SalesTeamCreateWithoutDesignationInput, SalesTeamUncheckedCreateWithoutDesignationInput>
  }

  export type SalesTeamUpdateWithWhereUniqueWithoutDesignationInput = {
    where: SalesTeamWhereUniqueInput
    data: XOR<SalesTeamUpdateWithoutDesignationInput, SalesTeamUncheckedUpdateWithoutDesignationInput>
  }

  export type SalesTeamUpdateManyWithWhereWithoutDesignationInput = {
    where: SalesTeamScalarWhereInput
    data: XOR<SalesTeamUpdateManyMutationInput, SalesTeamUncheckedUpdateManyWithoutSalesTeamInput>
  }

  export type SalesTeamScalarWhereInput = {
    AND?: Enumerable<SalesTeamScalarWhereInput>
    OR?: Enumerable<SalesTeamScalarWhereInput>
    NOT?: Enumerable<SalesTeamScalarWhereInput>
    id?: UuidFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    password?: StringFilter | string
    dob?: DateTimeFilter | Date | string
    fkDesignationId?: UuidFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TeacherMasterUpsertWithWhereUniqueWithoutDesignationInput = {
    where: TeacherMasterWhereUniqueInput
    update: XOR<TeacherMasterUpdateWithoutDesignationInput, TeacherMasterUncheckedUpdateWithoutDesignationInput>
    create: XOR<TeacherMasterCreateWithoutDesignationInput, TeacherMasterUncheckedCreateWithoutDesignationInput>
  }

  export type TeacherMasterUpdateWithWhereUniqueWithoutDesignationInput = {
    where: TeacherMasterWhereUniqueInput
    data: XOR<TeacherMasterUpdateWithoutDesignationInput, TeacherMasterUncheckedUpdateWithoutDesignationInput>
  }

  export type TeacherMasterUpdateManyWithWhereWithoutDesignationInput = {
    where: TeacherMasterScalarWhereInput
    data: XOR<TeacherMasterUpdateManyMutationInput, TeacherMasterUncheckedUpdateManyWithoutTeacherMasterInput>
  }

  export type TeacherMasterScalarWhereInput = {
    AND?: Enumerable<TeacherMasterScalarWhereInput>
    OR?: Enumerable<TeacherMasterScalarWhereInput>
    NOT?: Enumerable<TeacherMasterScalarWhereInput>
    id?: UuidFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    password?: StringFilter | string
    gender?: StringFilter | string
    dob?: DateTimeFilter | Date | string
    teacherId?: StringFilter | string
    fkTeacherDepartmentId?: UuidFilter | string
    profileImg?: StringFilter | string
    joiningDate?: DateTimeFilter | Date | string
    fkDesignationId?: UuidFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StateCreateWithoutCountryInput = {
    id?: string
    StateName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    City?: CityCreateNestedManyWithoutStateInput
    StudentAddress?: StudentAddressCreateNestedManyWithoutStateInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutStateInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutStateInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutCountryInput = {
    id?: string
    StateName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    City?: CityUncheckedCreateNestedManyWithoutStateInput
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutStateInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutStateInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutStateInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutCountryInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateCreateManyCountryInputEnvelope = {
    data: Enumerable<StateCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type StudentAddressCreateWithoutCountryInput = {
    id?: string
    StudentId: StudentMasterCreateNestedOneWithoutStudentAddressInput
    State: StateCreateNestedOneWithoutStudentAddressInput
    City: CityCreateNestedOneWithoutStudentAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressUncheckedCreateWithoutCountryInput = {
    id?: string
    fkStudentId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressCreateOrConnectWithoutCountryInput = {
    where: StudentAddressWhereUniqueInput
    create: XOR<StudentAddressCreateWithoutCountryInput, StudentAddressUncheckedCreateWithoutCountryInput>
  }

  export type StudentAddressCreateManyCountryInputEnvelope = {
    data: Enumerable<StudentAddressCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type TeacherAddressCreateWithoutCountryInput = {
    id?: string
    TeacherId: TeacherMasterCreateNestedOneWithoutTeacherAddressInput
    State: StateCreateNestedOneWithoutTeacherAddressInput
    City: CityCreateNestedOneWithoutTeacherAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressUncheckedCreateWithoutCountryInput = {
    id?: string
    fkTeacherId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressCreateOrConnectWithoutCountryInput = {
    where: TeacherAddressWhereUniqueInput
    create: XOR<TeacherAddressCreateWithoutCountryInput, TeacherAddressUncheckedCreateWithoutCountryInput>
  }

  export type TeacherAddressCreateManyCountryInputEnvelope = {
    data: Enumerable<TeacherAddressCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type SalesTeamAddressCreateWithoutCountryInput = {
    id?: string
    salesTeam: SalesTeamCreateNestedOneWithoutSalesTeamAddressInput
    State: StateCreateNestedOneWithoutSalesTeamAddressInput
    City: CityCreateNestedOneWithoutSalesTeamAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressUncheckedCreateWithoutCountryInput = {
    id?: string
    fkSalesTeamId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressCreateOrConnectWithoutCountryInput = {
    where: SalesTeamAddressWhereUniqueInput
    create: XOR<SalesTeamAddressCreateWithoutCountryInput, SalesTeamAddressUncheckedCreateWithoutCountryInput>
  }

  export type SalesTeamAddressCreateManyCountryInputEnvelope = {
    data: Enumerable<SalesTeamAddressCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type SchoolMasterAddressCreateWithoutCountryInput = {
    id?: string
    schoolId: schoolMasterCreateNestedOneWithoutSchoolMasterAddressInput
    State: StateCreateNestedOneWithoutSchoolMasterAddressInput
    City: CityCreateNestedOneWithoutSchoolMasterAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressUncheckedCreateWithoutCountryInput = {
    id?: string
    fkSchoolId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressCreateOrConnectWithoutCountryInput = {
    where: SchoolMasterAddressWhereUniqueInput
    create: XOR<SchoolMasterAddressCreateWithoutCountryInput, SchoolMasterAddressUncheckedCreateWithoutCountryInput>
  }

  export type SchoolMasterAddressCreateManyCountryInputEnvelope = {
    data: Enumerable<SchoolMasterAddressCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type StateUpsertWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    update: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateUpdateWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    data: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
  }

  export type StateUpdateManyWithWhereWithoutCountryInput = {
    where: StateScalarWhereInput
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyWithoutStateInput>
  }

  export type StateScalarWhereInput = {
    AND?: Enumerable<StateScalarWhereInput>
    OR?: Enumerable<StateScalarWhereInput>
    NOT?: Enumerable<StateScalarWhereInput>
    id?: UuidFilter | string
    StateName?: StringFilter | string
    fkCountryId?: UuidFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StudentAddressUpsertWithWhereUniqueWithoutCountryInput = {
    where: StudentAddressWhereUniqueInput
    update: XOR<StudentAddressUpdateWithoutCountryInput, StudentAddressUncheckedUpdateWithoutCountryInput>
    create: XOR<StudentAddressCreateWithoutCountryInput, StudentAddressUncheckedCreateWithoutCountryInput>
  }

  export type StudentAddressUpdateWithWhereUniqueWithoutCountryInput = {
    where: StudentAddressWhereUniqueInput
    data: XOR<StudentAddressUpdateWithoutCountryInput, StudentAddressUncheckedUpdateWithoutCountryInput>
  }

  export type StudentAddressUpdateManyWithWhereWithoutCountryInput = {
    where: StudentAddressScalarWhereInput
    data: XOR<StudentAddressUpdateManyMutationInput, StudentAddressUncheckedUpdateManyWithoutStudentAddressInput>
  }

  export type StudentAddressScalarWhereInput = {
    AND?: Enumerable<StudentAddressScalarWhereInput>
    OR?: Enumerable<StudentAddressScalarWhereInput>
    NOT?: Enumerable<StudentAddressScalarWhereInput>
    id?: UuidFilter | string
    fkStudentId?: UuidFilter | string
    fkCountryId?: UuidFilter | string
    fkStateId?: UuidFilter | string
    fkCityId?: UuidFilter | string
    Address?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TeacherAddressUpsertWithWhereUniqueWithoutCountryInput = {
    where: TeacherAddressWhereUniqueInput
    update: XOR<TeacherAddressUpdateWithoutCountryInput, TeacherAddressUncheckedUpdateWithoutCountryInput>
    create: XOR<TeacherAddressCreateWithoutCountryInput, TeacherAddressUncheckedCreateWithoutCountryInput>
  }

  export type TeacherAddressUpdateWithWhereUniqueWithoutCountryInput = {
    where: TeacherAddressWhereUniqueInput
    data: XOR<TeacherAddressUpdateWithoutCountryInput, TeacherAddressUncheckedUpdateWithoutCountryInput>
  }

  export type TeacherAddressUpdateManyWithWhereWithoutCountryInput = {
    where: TeacherAddressScalarWhereInput
    data: XOR<TeacherAddressUpdateManyMutationInput, TeacherAddressUncheckedUpdateManyWithoutTeacherAddressInput>
  }

  export type TeacherAddressScalarWhereInput = {
    AND?: Enumerable<TeacherAddressScalarWhereInput>
    OR?: Enumerable<TeacherAddressScalarWhereInput>
    NOT?: Enumerable<TeacherAddressScalarWhereInput>
    id?: UuidFilter | string
    fkTeacherId?: UuidFilter | string
    fkCountryId?: UuidFilter | string
    fkStateId?: UuidFilter | string
    fkCityId?: UuidFilter | string
    Address?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SalesTeamAddressUpsertWithWhereUniqueWithoutCountryInput = {
    where: SalesTeamAddressWhereUniqueInput
    update: XOR<SalesTeamAddressUpdateWithoutCountryInput, SalesTeamAddressUncheckedUpdateWithoutCountryInput>
    create: XOR<SalesTeamAddressCreateWithoutCountryInput, SalesTeamAddressUncheckedCreateWithoutCountryInput>
  }

  export type SalesTeamAddressUpdateWithWhereUniqueWithoutCountryInput = {
    where: SalesTeamAddressWhereUniqueInput
    data: XOR<SalesTeamAddressUpdateWithoutCountryInput, SalesTeamAddressUncheckedUpdateWithoutCountryInput>
  }

  export type SalesTeamAddressUpdateManyWithWhereWithoutCountryInput = {
    where: SalesTeamAddressScalarWhereInput
    data: XOR<SalesTeamAddressUpdateManyMutationInput, SalesTeamAddressUncheckedUpdateManyWithoutSalesTeamAddressInput>
  }

  export type SalesTeamAddressScalarWhereInput = {
    AND?: Enumerable<SalesTeamAddressScalarWhereInput>
    OR?: Enumerable<SalesTeamAddressScalarWhereInput>
    NOT?: Enumerable<SalesTeamAddressScalarWhereInput>
    id?: UuidFilter | string
    fkSalesTeamId?: UuidFilter | string
    fkCountryId?: UuidFilter | string
    fkStateId?: UuidFilter | string
    fkCityId?: UuidFilter | string
    Address?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SchoolMasterAddressUpsertWithWhereUniqueWithoutCountryInput = {
    where: SchoolMasterAddressWhereUniqueInput
    update: XOR<SchoolMasterAddressUpdateWithoutCountryInput, SchoolMasterAddressUncheckedUpdateWithoutCountryInput>
    create: XOR<SchoolMasterAddressCreateWithoutCountryInput, SchoolMasterAddressUncheckedCreateWithoutCountryInput>
  }

  export type SchoolMasterAddressUpdateWithWhereUniqueWithoutCountryInput = {
    where: SchoolMasterAddressWhereUniqueInput
    data: XOR<SchoolMasterAddressUpdateWithoutCountryInput, SchoolMasterAddressUncheckedUpdateWithoutCountryInput>
  }

  export type SchoolMasterAddressUpdateManyWithWhereWithoutCountryInput = {
    where: SchoolMasterAddressScalarWhereInput
    data: XOR<SchoolMasterAddressUpdateManyMutationInput, SchoolMasterAddressUncheckedUpdateManyWithoutSchoolMasterAddressInput>
  }

  export type SchoolMasterAddressScalarWhereInput = {
    AND?: Enumerable<SchoolMasterAddressScalarWhereInput>
    OR?: Enumerable<SchoolMasterAddressScalarWhereInput>
    NOT?: Enumerable<SchoolMasterAddressScalarWhereInput>
    id?: UuidFilter | string
    fkSchoolId?: UuidFilter | string
    fkCountryId?: UuidFilter | string
    fkStateId?: UuidFilter | string
    fkCityId?: UuidFilter | string
    Address?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CountryCreateWithoutStateInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressCreateNestedManyWithoutCountryInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutCountryInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutCountryInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutStateInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutCountryInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutCountryInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutCountryInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutStateInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutStateInput, CountryUncheckedCreateWithoutStateInput>
  }

  export type CityCreateWithoutStateInput = {
    id?: string
    CityName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressCreateNestedManyWithoutCityInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutCityInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutCityInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutStateInput = {
    id?: string
    CityName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutCityInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutCityInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutCityInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutStateInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityCreateManyStateInputEnvelope = {
    data: Enumerable<CityCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type StudentAddressCreateWithoutStateInput = {
    id?: string
    StudentId: StudentMasterCreateNestedOneWithoutStudentAddressInput
    Country: CountryCreateNestedOneWithoutStudentAddressInput
    City: CityCreateNestedOneWithoutStudentAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressUncheckedCreateWithoutStateInput = {
    id?: string
    fkStudentId: string
    fkCountryId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressCreateOrConnectWithoutStateInput = {
    where: StudentAddressWhereUniqueInput
    create: XOR<StudentAddressCreateWithoutStateInput, StudentAddressUncheckedCreateWithoutStateInput>
  }

  export type StudentAddressCreateManyStateInputEnvelope = {
    data: Enumerable<StudentAddressCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type TeacherAddressCreateWithoutStateInput = {
    id?: string
    TeacherId: TeacherMasterCreateNestedOneWithoutTeacherAddressInput
    Country: CountryCreateNestedOneWithoutTeacherAddressInput
    City: CityCreateNestedOneWithoutTeacherAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressUncheckedCreateWithoutStateInput = {
    id?: string
    fkTeacherId: string
    fkCountryId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressCreateOrConnectWithoutStateInput = {
    where: TeacherAddressWhereUniqueInput
    create: XOR<TeacherAddressCreateWithoutStateInput, TeacherAddressUncheckedCreateWithoutStateInput>
  }

  export type TeacherAddressCreateManyStateInputEnvelope = {
    data: Enumerable<TeacherAddressCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type SalesTeamAddressCreateWithoutStateInput = {
    id?: string
    salesTeam: SalesTeamCreateNestedOneWithoutSalesTeamAddressInput
    Country: CountryCreateNestedOneWithoutSalesTeamAddressInput
    City: CityCreateNestedOneWithoutSalesTeamAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressUncheckedCreateWithoutStateInput = {
    id?: string
    fkSalesTeamId: string
    fkCountryId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressCreateOrConnectWithoutStateInput = {
    where: SalesTeamAddressWhereUniqueInput
    create: XOR<SalesTeamAddressCreateWithoutStateInput, SalesTeamAddressUncheckedCreateWithoutStateInput>
  }

  export type SalesTeamAddressCreateManyStateInputEnvelope = {
    data: Enumerable<SalesTeamAddressCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type SchoolMasterAddressCreateWithoutStateInput = {
    id?: string
    schoolId: schoolMasterCreateNestedOneWithoutSchoolMasterAddressInput
    Country: CountryCreateNestedOneWithoutSchoolMasterAddressInput
    City: CityCreateNestedOneWithoutSchoolMasterAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressUncheckedCreateWithoutStateInput = {
    id?: string
    fkSchoolId: string
    fkCountryId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressCreateOrConnectWithoutStateInput = {
    where: SchoolMasterAddressWhereUniqueInput
    create: XOR<SchoolMasterAddressCreateWithoutStateInput, SchoolMasterAddressUncheckedCreateWithoutStateInput>
  }

  export type SchoolMasterAddressCreateManyStateInputEnvelope = {
    data: Enumerable<SchoolMasterAddressCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutStateInput = {
    update: XOR<CountryUpdateWithoutStateInput, CountryUncheckedUpdateWithoutStateInput>
    create: XOR<CountryCreateWithoutStateInput, CountryUncheckedCreateWithoutStateInput>
  }

  export type CountryUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUpdateManyWithoutCountryNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutCountryNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutCountryNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutCountryNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutCountryNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutCountryNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CityUpsertWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityUpdateWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
  }

  export type CityUpdateManyWithWhereWithoutStateInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCityInput>
  }

  export type CityScalarWhereInput = {
    AND?: Enumerable<CityScalarWhereInput>
    OR?: Enumerable<CityScalarWhereInput>
    NOT?: Enumerable<CityScalarWhereInput>
    id?: UuidFilter | string
    CityName?: StringFilter | string
    fkStateId?: UuidFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StudentAddressUpsertWithWhereUniqueWithoutStateInput = {
    where: StudentAddressWhereUniqueInput
    update: XOR<StudentAddressUpdateWithoutStateInput, StudentAddressUncheckedUpdateWithoutStateInput>
    create: XOR<StudentAddressCreateWithoutStateInput, StudentAddressUncheckedCreateWithoutStateInput>
  }

  export type StudentAddressUpdateWithWhereUniqueWithoutStateInput = {
    where: StudentAddressWhereUniqueInput
    data: XOR<StudentAddressUpdateWithoutStateInput, StudentAddressUncheckedUpdateWithoutStateInput>
  }

  export type StudentAddressUpdateManyWithWhereWithoutStateInput = {
    where: StudentAddressScalarWhereInput
    data: XOR<StudentAddressUpdateManyMutationInput, StudentAddressUncheckedUpdateManyWithoutStudentAddressInput>
  }

  export type TeacherAddressUpsertWithWhereUniqueWithoutStateInput = {
    where: TeacherAddressWhereUniqueInput
    update: XOR<TeacherAddressUpdateWithoutStateInput, TeacherAddressUncheckedUpdateWithoutStateInput>
    create: XOR<TeacherAddressCreateWithoutStateInput, TeacherAddressUncheckedCreateWithoutStateInput>
  }

  export type TeacherAddressUpdateWithWhereUniqueWithoutStateInput = {
    where: TeacherAddressWhereUniqueInput
    data: XOR<TeacherAddressUpdateWithoutStateInput, TeacherAddressUncheckedUpdateWithoutStateInput>
  }

  export type TeacherAddressUpdateManyWithWhereWithoutStateInput = {
    where: TeacherAddressScalarWhereInput
    data: XOR<TeacherAddressUpdateManyMutationInput, TeacherAddressUncheckedUpdateManyWithoutTeacherAddressInput>
  }

  export type SalesTeamAddressUpsertWithWhereUniqueWithoutStateInput = {
    where: SalesTeamAddressWhereUniqueInput
    update: XOR<SalesTeamAddressUpdateWithoutStateInput, SalesTeamAddressUncheckedUpdateWithoutStateInput>
    create: XOR<SalesTeamAddressCreateWithoutStateInput, SalesTeamAddressUncheckedCreateWithoutStateInput>
  }

  export type SalesTeamAddressUpdateWithWhereUniqueWithoutStateInput = {
    where: SalesTeamAddressWhereUniqueInput
    data: XOR<SalesTeamAddressUpdateWithoutStateInput, SalesTeamAddressUncheckedUpdateWithoutStateInput>
  }

  export type SalesTeamAddressUpdateManyWithWhereWithoutStateInput = {
    where: SalesTeamAddressScalarWhereInput
    data: XOR<SalesTeamAddressUpdateManyMutationInput, SalesTeamAddressUncheckedUpdateManyWithoutSalesTeamAddressInput>
  }

  export type SchoolMasterAddressUpsertWithWhereUniqueWithoutStateInput = {
    where: SchoolMasterAddressWhereUniqueInput
    update: XOR<SchoolMasterAddressUpdateWithoutStateInput, SchoolMasterAddressUncheckedUpdateWithoutStateInput>
    create: XOR<SchoolMasterAddressCreateWithoutStateInput, SchoolMasterAddressUncheckedCreateWithoutStateInput>
  }

  export type SchoolMasterAddressUpdateWithWhereUniqueWithoutStateInput = {
    where: SchoolMasterAddressWhereUniqueInput
    data: XOR<SchoolMasterAddressUpdateWithoutStateInput, SchoolMasterAddressUncheckedUpdateWithoutStateInput>
  }

  export type SchoolMasterAddressUpdateManyWithWhereWithoutStateInput = {
    where: SchoolMasterAddressScalarWhereInput
    data: XOR<SchoolMasterAddressUpdateManyMutationInput, SchoolMasterAddressUncheckedUpdateManyWithoutSchoolMasterAddressInput>
  }

  export type StateCreateWithoutCityInput = {
    id?: string
    StateName: string
    Country: CountryCreateNestedOneWithoutStateInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressCreateNestedManyWithoutStateInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutStateInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutStateInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutCityInput = {
    id?: string
    StateName: string
    fkCountryId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutStateInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutStateInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutStateInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutCityInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCityInput, StateUncheckedCreateWithoutCityInput>
  }

  export type StudentAddressCreateWithoutCityInput = {
    id?: string
    StudentId: StudentMasterCreateNestedOneWithoutStudentAddressInput
    Country: CountryCreateNestedOneWithoutStudentAddressInput
    State: StateCreateNestedOneWithoutStudentAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressUncheckedCreateWithoutCityInput = {
    id?: string
    fkStudentId: string
    fkCountryId: string
    fkStateId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressCreateOrConnectWithoutCityInput = {
    where: StudentAddressWhereUniqueInput
    create: XOR<StudentAddressCreateWithoutCityInput, StudentAddressUncheckedCreateWithoutCityInput>
  }

  export type StudentAddressCreateManyCityInputEnvelope = {
    data: Enumerable<StudentAddressCreateManyCityInput>
    skipDuplicates?: boolean
  }

  export type TeacherAddressCreateWithoutCityInput = {
    id?: string
    TeacherId: TeacherMasterCreateNestedOneWithoutTeacherAddressInput
    Country: CountryCreateNestedOneWithoutTeacherAddressInput
    State: StateCreateNestedOneWithoutTeacherAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressUncheckedCreateWithoutCityInput = {
    id?: string
    fkTeacherId: string
    fkCountryId: string
    fkStateId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressCreateOrConnectWithoutCityInput = {
    where: TeacherAddressWhereUniqueInput
    create: XOR<TeacherAddressCreateWithoutCityInput, TeacherAddressUncheckedCreateWithoutCityInput>
  }

  export type TeacherAddressCreateManyCityInputEnvelope = {
    data: Enumerable<TeacherAddressCreateManyCityInput>
    skipDuplicates?: boolean
  }

  export type SalesTeamAddressCreateWithoutCityInput = {
    id?: string
    salesTeam: SalesTeamCreateNestedOneWithoutSalesTeamAddressInput
    Country: CountryCreateNestedOneWithoutSalesTeamAddressInput
    State: StateCreateNestedOneWithoutSalesTeamAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressUncheckedCreateWithoutCityInput = {
    id?: string
    fkSalesTeamId: string
    fkCountryId: string
    fkStateId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressCreateOrConnectWithoutCityInput = {
    where: SalesTeamAddressWhereUniqueInput
    create: XOR<SalesTeamAddressCreateWithoutCityInput, SalesTeamAddressUncheckedCreateWithoutCityInput>
  }

  export type SalesTeamAddressCreateManyCityInputEnvelope = {
    data: Enumerable<SalesTeamAddressCreateManyCityInput>
    skipDuplicates?: boolean
  }

  export type SchoolMasterAddressCreateWithoutCityInput = {
    id?: string
    schoolId: schoolMasterCreateNestedOneWithoutSchoolMasterAddressInput
    Country: CountryCreateNestedOneWithoutSchoolMasterAddressInput
    State: StateCreateNestedOneWithoutSchoolMasterAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressUncheckedCreateWithoutCityInput = {
    id?: string
    fkSchoolId: string
    fkCountryId: string
    fkStateId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressCreateOrConnectWithoutCityInput = {
    where: SchoolMasterAddressWhereUniqueInput
    create: XOR<SchoolMasterAddressCreateWithoutCityInput, SchoolMasterAddressUncheckedCreateWithoutCityInput>
  }

  export type SchoolMasterAddressCreateManyCityInputEnvelope = {
    data: Enumerable<SchoolMasterAddressCreateManyCityInput>
    skipDuplicates?: boolean
  }

  export type StateUpsertWithoutCityInput = {
    update: XOR<StateUpdateWithoutCityInput, StateUncheckedUpdateWithoutCityInput>
    create: XOR<StateCreateWithoutCityInput, StateUncheckedCreateWithoutCityInput>
  }

  export type StateUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    Country?: CountryUpdateOneRequiredWithoutStateNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUpdateManyWithoutStateNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutStateNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutStateNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutStateNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutStateNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutStateNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutStateNestedInput
  }

  export type StudentAddressUpsertWithWhereUniqueWithoutCityInput = {
    where: StudentAddressWhereUniqueInput
    update: XOR<StudentAddressUpdateWithoutCityInput, StudentAddressUncheckedUpdateWithoutCityInput>
    create: XOR<StudentAddressCreateWithoutCityInput, StudentAddressUncheckedCreateWithoutCityInput>
  }

  export type StudentAddressUpdateWithWhereUniqueWithoutCityInput = {
    where: StudentAddressWhereUniqueInput
    data: XOR<StudentAddressUpdateWithoutCityInput, StudentAddressUncheckedUpdateWithoutCityInput>
  }

  export type StudentAddressUpdateManyWithWhereWithoutCityInput = {
    where: StudentAddressScalarWhereInput
    data: XOR<StudentAddressUpdateManyMutationInput, StudentAddressUncheckedUpdateManyWithoutStudentAddressInput>
  }

  export type TeacherAddressUpsertWithWhereUniqueWithoutCityInput = {
    where: TeacherAddressWhereUniqueInput
    update: XOR<TeacherAddressUpdateWithoutCityInput, TeacherAddressUncheckedUpdateWithoutCityInput>
    create: XOR<TeacherAddressCreateWithoutCityInput, TeacherAddressUncheckedCreateWithoutCityInput>
  }

  export type TeacherAddressUpdateWithWhereUniqueWithoutCityInput = {
    where: TeacherAddressWhereUniqueInput
    data: XOR<TeacherAddressUpdateWithoutCityInput, TeacherAddressUncheckedUpdateWithoutCityInput>
  }

  export type TeacherAddressUpdateManyWithWhereWithoutCityInput = {
    where: TeacherAddressScalarWhereInput
    data: XOR<TeacherAddressUpdateManyMutationInput, TeacherAddressUncheckedUpdateManyWithoutTeacherAddressInput>
  }

  export type SalesTeamAddressUpsertWithWhereUniqueWithoutCityInput = {
    where: SalesTeamAddressWhereUniqueInput
    update: XOR<SalesTeamAddressUpdateWithoutCityInput, SalesTeamAddressUncheckedUpdateWithoutCityInput>
    create: XOR<SalesTeamAddressCreateWithoutCityInput, SalesTeamAddressUncheckedCreateWithoutCityInput>
  }

  export type SalesTeamAddressUpdateWithWhereUniqueWithoutCityInput = {
    where: SalesTeamAddressWhereUniqueInput
    data: XOR<SalesTeamAddressUpdateWithoutCityInput, SalesTeamAddressUncheckedUpdateWithoutCityInput>
  }

  export type SalesTeamAddressUpdateManyWithWhereWithoutCityInput = {
    where: SalesTeamAddressScalarWhereInput
    data: XOR<SalesTeamAddressUpdateManyMutationInput, SalesTeamAddressUncheckedUpdateManyWithoutSalesTeamAddressInput>
  }

  export type SchoolMasterAddressUpsertWithWhereUniqueWithoutCityInput = {
    where: SchoolMasterAddressWhereUniqueInput
    update: XOR<SchoolMasterAddressUpdateWithoutCityInput, SchoolMasterAddressUncheckedUpdateWithoutCityInput>
    create: XOR<SchoolMasterAddressCreateWithoutCityInput, SchoolMasterAddressUncheckedCreateWithoutCityInput>
  }

  export type SchoolMasterAddressUpdateWithWhereUniqueWithoutCityInput = {
    where: SchoolMasterAddressWhereUniqueInput
    data: XOR<SchoolMasterAddressUpdateWithoutCityInput, SchoolMasterAddressUncheckedUpdateWithoutCityInput>
  }

  export type SchoolMasterAddressUpdateManyWithWhereWithoutCityInput = {
    where: SchoolMasterAddressScalarWhereInput
    data: XOR<SchoolMasterAddressUpdateManyMutationInput, SchoolMasterAddressUncheckedUpdateManyWithoutSchoolMasterAddressInput>
  }

  export type DesignationCreateWithoutSalesTeamInput = {
    id?: string
    roles: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherMaster?: TeacherMasterCreateNestedManyWithoutDesignationInput
  }

  export type DesignationUncheckedCreateWithoutSalesTeamInput = {
    id?: string
    roles: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherMaster?: TeacherMasterUncheckedCreateNestedManyWithoutDesignationInput
  }

  export type DesignationCreateOrConnectWithoutSalesTeamInput = {
    where: DesignationWhereUniqueInput
    create: XOR<DesignationCreateWithoutSalesTeamInput, DesignationUncheckedCreateWithoutSalesTeamInput>
  }

  export type SalesTeamDocumentsCreateWithoutSalesTeamInput = {
    id?: string
    category: string
    comment: string
    url: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamDocumentsUncheckedCreateWithoutSalesTeamInput = {
    id?: string
    category: string
    comment: string
    url: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamDocumentsCreateOrConnectWithoutSalesTeamInput = {
    where: SalesTeamDocumentsWhereUniqueInput
    create: XOR<SalesTeamDocumentsCreateWithoutSalesTeamInput, SalesTeamDocumentsUncheckedCreateWithoutSalesTeamInput>
  }

  export type SalesTeamDocumentsCreateManySalesTeamInputEnvelope = {
    data: Enumerable<SalesTeamDocumentsCreateManySalesTeamInput>
    skipDuplicates?: boolean
  }

  export type SalesTeamAddressCreateWithoutSalesTeamInput = {
    id?: string
    Country: CountryCreateNestedOneWithoutSalesTeamAddressInput
    State: StateCreateNestedOneWithoutSalesTeamAddressInput
    City: CityCreateNestedOneWithoutSalesTeamAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressUncheckedCreateWithoutSalesTeamInput = {
    id?: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressCreateOrConnectWithoutSalesTeamInput = {
    where: SalesTeamAddressWhereUniqueInput
    create: XOR<SalesTeamAddressCreateWithoutSalesTeamInput, SalesTeamAddressUncheckedCreateWithoutSalesTeamInput>
  }

  export type SalesTeamAddressCreateManySalesTeamInputEnvelope = {
    data: Enumerable<SalesTeamAddressCreateManySalesTeamInput>
    skipDuplicates?: boolean
  }

  export type schoolMasterCreateWithoutSalesTeamInput = {
    id?: string
    name: string
    afflicationCode: string
    schoolType: schoolTypeCreateNestedOneWithoutSchoolMasterInput
    schoolBoard: SchoolBoardCreateNestedOneWithoutSchoolMasterInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutSchoolIdInput
  }

  export type schoolMasterUncheckedCreateWithoutSalesTeamInput = {
    id?: string
    name: string
    afflicationCode: string
    fkSchoolType: string
    fkSchoolBoard: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutSchoolIdInput
  }

  export type schoolMasterCreateOrConnectWithoutSalesTeamInput = {
    where: schoolMasterWhereUniqueInput
    create: XOR<schoolMasterCreateWithoutSalesTeamInput, schoolMasterUncheckedCreateWithoutSalesTeamInput>
  }

  export type schoolMasterCreateManySalesTeamInputEnvelope = {
    data: Enumerable<schoolMasterCreateManySalesTeamInput>
    skipDuplicates?: boolean
  }

  export type DesignationUpsertWithoutSalesTeamInput = {
    update: XOR<DesignationUpdateWithoutSalesTeamInput, DesignationUncheckedUpdateWithoutSalesTeamInput>
    create: XOR<DesignationCreateWithoutSalesTeamInput, DesignationUncheckedCreateWithoutSalesTeamInput>
  }

  export type DesignationUpdateWithoutSalesTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherMaster?: TeacherMasterUpdateManyWithoutDesignationNestedInput
  }

  export type DesignationUncheckedUpdateWithoutSalesTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherMaster?: TeacherMasterUncheckedUpdateManyWithoutDesignationNestedInput
  }

  export type SalesTeamDocumentsUpsertWithWhereUniqueWithoutSalesTeamInput = {
    where: SalesTeamDocumentsWhereUniqueInput
    update: XOR<SalesTeamDocumentsUpdateWithoutSalesTeamInput, SalesTeamDocumentsUncheckedUpdateWithoutSalesTeamInput>
    create: XOR<SalesTeamDocumentsCreateWithoutSalesTeamInput, SalesTeamDocumentsUncheckedCreateWithoutSalesTeamInput>
  }

  export type SalesTeamDocumentsUpdateWithWhereUniqueWithoutSalesTeamInput = {
    where: SalesTeamDocumentsWhereUniqueInput
    data: XOR<SalesTeamDocumentsUpdateWithoutSalesTeamInput, SalesTeamDocumentsUncheckedUpdateWithoutSalesTeamInput>
  }

  export type SalesTeamDocumentsUpdateManyWithWhereWithoutSalesTeamInput = {
    where: SalesTeamDocumentsScalarWhereInput
    data: XOR<SalesTeamDocumentsUpdateManyMutationInput, SalesTeamDocumentsUncheckedUpdateManyWithoutSalesTeamDocumentsInput>
  }

  export type SalesTeamDocumentsScalarWhereInput = {
    AND?: Enumerable<SalesTeamDocumentsScalarWhereInput>
    OR?: Enumerable<SalesTeamDocumentsScalarWhereInput>
    NOT?: Enumerable<SalesTeamDocumentsScalarWhereInput>
    id?: UuidFilter | string
    fkSalesTeamId?: UuidFilter | string
    category?: StringFilter | string
    comment?: StringFilter | string
    url?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SalesTeamAddressUpsertWithWhereUniqueWithoutSalesTeamInput = {
    where: SalesTeamAddressWhereUniqueInput
    update: XOR<SalesTeamAddressUpdateWithoutSalesTeamInput, SalesTeamAddressUncheckedUpdateWithoutSalesTeamInput>
    create: XOR<SalesTeamAddressCreateWithoutSalesTeamInput, SalesTeamAddressUncheckedCreateWithoutSalesTeamInput>
  }

  export type SalesTeamAddressUpdateWithWhereUniqueWithoutSalesTeamInput = {
    where: SalesTeamAddressWhereUniqueInput
    data: XOR<SalesTeamAddressUpdateWithoutSalesTeamInput, SalesTeamAddressUncheckedUpdateWithoutSalesTeamInput>
  }

  export type SalesTeamAddressUpdateManyWithWhereWithoutSalesTeamInput = {
    where: SalesTeamAddressScalarWhereInput
    data: XOR<SalesTeamAddressUpdateManyMutationInput, SalesTeamAddressUncheckedUpdateManyWithoutSalesTeamAddressInput>
  }

  export type schoolMasterUpsertWithWhereUniqueWithoutSalesTeamInput = {
    where: schoolMasterWhereUniqueInput
    update: XOR<schoolMasterUpdateWithoutSalesTeamInput, schoolMasterUncheckedUpdateWithoutSalesTeamInput>
    create: XOR<schoolMasterCreateWithoutSalesTeamInput, schoolMasterUncheckedCreateWithoutSalesTeamInput>
  }

  export type schoolMasterUpdateWithWhereUniqueWithoutSalesTeamInput = {
    where: schoolMasterWhereUniqueInput
    data: XOR<schoolMasterUpdateWithoutSalesTeamInput, schoolMasterUncheckedUpdateWithoutSalesTeamInput>
  }

  export type schoolMasterUpdateManyWithWhereWithoutSalesTeamInput = {
    where: schoolMasterScalarWhereInput
    data: XOR<schoolMasterUpdateManyMutationInput, schoolMasterUncheckedUpdateManyWithoutSchoolMasterInput>
  }

  export type schoolMasterScalarWhereInput = {
    AND?: Enumerable<schoolMasterScalarWhereInput>
    OR?: Enumerable<schoolMasterScalarWhereInput>
    NOT?: Enumerable<schoolMasterScalarWhereInput>
    id?: UuidFilter | string
    name?: StringFilter | string
    afflicationCode?: StringFilter | string
    fkSchoolType?: UuidFilter | string
    fkSchoolBoard?: UuidFilter | string
    fkSalesTeamId?: UuidFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SalesTeamCreateWithoutSalesTeamDocumentsInput = {
    id?: string
    email: string
    phone: string
    password: string
    dob: Date | string
    designation: DesignationCreateNestedOneWithoutSalesTeamInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutSalesTeamInput
    schoolMaster?: schoolMasterCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamUncheckedCreateWithoutSalesTeamDocumentsInput = {
    id?: string
    email: string
    phone: string
    password: string
    dob: Date | string
    fkDesignationId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutSalesTeamInput
    schoolMaster?: schoolMasterUncheckedCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamCreateOrConnectWithoutSalesTeamDocumentsInput = {
    where: SalesTeamWhereUniqueInput
    create: XOR<SalesTeamCreateWithoutSalesTeamDocumentsInput, SalesTeamUncheckedCreateWithoutSalesTeamDocumentsInput>
  }

  export type SalesTeamUpsertWithoutSalesTeamDocumentsInput = {
    update: XOR<SalesTeamUpdateWithoutSalesTeamDocumentsInput, SalesTeamUncheckedUpdateWithoutSalesTeamDocumentsInput>
    create: XOR<SalesTeamCreateWithoutSalesTeamDocumentsInput, SalesTeamUncheckedCreateWithoutSalesTeamDocumentsInput>
  }

  export type SalesTeamUpdateWithoutSalesTeamDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    designation?: DesignationUpdateOneRequiredWithoutSalesTeamNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutSalesTeamNestedInput
    schoolMaster?: schoolMasterUpdateManyWithoutSalesTeamNestedInput
  }

  export type SalesTeamUncheckedUpdateWithoutSalesTeamDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    fkDesignationId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutSalesTeamNestedInput
    schoolMaster?: schoolMasterUncheckedUpdateManyWithoutSalesTeamNestedInput
  }

  export type SalesTeamCreateWithoutSalesTeamAddressInput = {
    id?: string
    email: string
    phone: string
    password: string
    dob: Date | string
    designation: DesignationCreateNestedOneWithoutSalesTeamInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeamDocuments?: SalesTeamDocumentsCreateNestedManyWithoutSalesTeamInput
    schoolMaster?: schoolMasterCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamUncheckedCreateWithoutSalesTeamAddressInput = {
    id?: string
    email: string
    phone: string
    password: string
    dob: Date | string
    fkDesignationId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeamDocuments?: SalesTeamDocumentsUncheckedCreateNestedManyWithoutSalesTeamInput
    schoolMaster?: schoolMasterUncheckedCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamCreateOrConnectWithoutSalesTeamAddressInput = {
    where: SalesTeamWhereUniqueInput
    create: XOR<SalesTeamCreateWithoutSalesTeamAddressInput, SalesTeamUncheckedCreateWithoutSalesTeamAddressInput>
  }

  export type CountryCreateWithoutSalesTeamAddressInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    State?: StateCreateNestedManyWithoutCountryInput
    StudentAddress?: StudentAddressCreateNestedManyWithoutCountryInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutCountryInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutSalesTeamAddressInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    State?: StateUncheckedCreateNestedManyWithoutCountryInput
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutCountryInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutCountryInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutSalesTeamAddressInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutSalesTeamAddressInput, CountryUncheckedCreateWithoutSalesTeamAddressInput>
  }

  export type StateCreateWithoutSalesTeamAddressInput = {
    id?: string
    StateName: string
    Country: CountryCreateNestedOneWithoutStateInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    City?: CityCreateNestedManyWithoutStateInput
    StudentAddress?: StudentAddressCreateNestedManyWithoutStateInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutStateInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutSalesTeamAddressInput = {
    id?: string
    StateName: string
    fkCountryId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    City?: CityUncheckedCreateNestedManyWithoutStateInput
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutStateInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutStateInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutSalesTeamAddressInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutSalesTeamAddressInput, StateUncheckedCreateWithoutSalesTeamAddressInput>
  }

  export type CityCreateWithoutSalesTeamAddressInput = {
    id?: string
    CityName: string
    State: StateCreateNestedOneWithoutCityInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressCreateNestedManyWithoutCityInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutCityInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutSalesTeamAddressInput = {
    id?: string
    CityName: string
    fkStateId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutCityInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutCityInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutSalesTeamAddressInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutSalesTeamAddressInput, CityUncheckedCreateWithoutSalesTeamAddressInput>
  }

  export type SalesTeamUpsertWithoutSalesTeamAddressInput = {
    update: XOR<SalesTeamUpdateWithoutSalesTeamAddressInput, SalesTeamUncheckedUpdateWithoutSalesTeamAddressInput>
    create: XOR<SalesTeamCreateWithoutSalesTeamAddressInput, SalesTeamUncheckedCreateWithoutSalesTeamAddressInput>
  }

  export type SalesTeamUpdateWithoutSalesTeamAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    designation?: DesignationUpdateOneRequiredWithoutSalesTeamNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeamDocuments?: SalesTeamDocumentsUpdateManyWithoutSalesTeamNestedInput
    schoolMaster?: schoolMasterUpdateManyWithoutSalesTeamNestedInput
  }

  export type SalesTeamUncheckedUpdateWithoutSalesTeamAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    fkDesignationId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeamDocuments?: SalesTeamDocumentsUncheckedUpdateManyWithoutSalesTeamNestedInput
    schoolMaster?: schoolMasterUncheckedUpdateManyWithoutSalesTeamNestedInput
  }

  export type CountryUpsertWithoutSalesTeamAddressInput = {
    update: XOR<CountryUpdateWithoutSalesTeamAddressInput, CountryUncheckedUpdateWithoutSalesTeamAddressInput>
    create: XOR<CountryCreateWithoutSalesTeamAddressInput, CountryUncheckedCreateWithoutSalesTeamAddressInput>
  }

  export type CountryUpdateWithoutSalesTeamAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    State?: StateUpdateManyWithoutCountryNestedInput
    StudentAddress?: StudentAddressUpdateManyWithoutCountryNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutCountryNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutSalesTeamAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    State?: StateUncheckedUpdateManyWithoutCountryNestedInput
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutCountryNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutCountryNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type StateUpsertWithoutSalesTeamAddressInput = {
    update: XOR<StateUpdateWithoutSalesTeamAddressInput, StateUncheckedUpdateWithoutSalesTeamAddressInput>
    create: XOR<StateCreateWithoutSalesTeamAddressInput, StateUncheckedCreateWithoutSalesTeamAddressInput>
  }

  export type StateUpdateWithoutSalesTeamAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    Country?: CountryUpdateOneRequiredWithoutStateNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUpdateManyWithoutStateNestedInput
    StudentAddress?: StudentAddressUpdateManyWithoutStateNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutStateNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutSalesTeamAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUncheckedUpdateManyWithoutStateNestedInput
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutStateNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutStateNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutStateNestedInput
  }

  export type CityUpsertWithoutSalesTeamAddressInput = {
    update: XOR<CityUpdateWithoutSalesTeamAddressInput, CityUncheckedUpdateWithoutSalesTeamAddressInput>
    create: XOR<CityCreateWithoutSalesTeamAddressInput, CityUncheckedCreateWithoutSalesTeamAddressInput>
  }

  export type CityUpdateWithoutSalesTeamAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    State?: StateUpdateOneRequiredWithoutCityNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUpdateManyWithoutCityNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutCityNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutSalesTeamAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutCityNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutCityNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutCityNestedInput
  }

  export type schoolMasterCreateWithoutSchoolBoardInput = {
    id?: string
    name: string
    afflicationCode: string
    schoolType: schoolTypeCreateNestedOneWithoutSchoolMasterInput
    salesTeam: SalesTeamCreateNestedOneWithoutSchoolMasterInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutSchoolIdInput
  }

  export type schoolMasterUncheckedCreateWithoutSchoolBoardInput = {
    id?: string
    name: string
    afflicationCode: string
    fkSchoolType: string
    fkSalesTeamId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutSchoolIdInput
  }

  export type schoolMasterCreateOrConnectWithoutSchoolBoardInput = {
    where: schoolMasterWhereUniqueInput
    create: XOR<schoolMasterCreateWithoutSchoolBoardInput, schoolMasterUncheckedCreateWithoutSchoolBoardInput>
  }

  export type schoolMasterCreateManySchoolBoardInputEnvelope = {
    data: Enumerable<schoolMasterCreateManySchoolBoardInput>
    skipDuplicates?: boolean
  }

  export type schoolMasterUpsertWithWhereUniqueWithoutSchoolBoardInput = {
    where: schoolMasterWhereUniqueInput
    update: XOR<schoolMasterUpdateWithoutSchoolBoardInput, schoolMasterUncheckedUpdateWithoutSchoolBoardInput>
    create: XOR<schoolMasterCreateWithoutSchoolBoardInput, schoolMasterUncheckedCreateWithoutSchoolBoardInput>
  }

  export type schoolMasterUpdateWithWhereUniqueWithoutSchoolBoardInput = {
    where: schoolMasterWhereUniqueInput
    data: XOR<schoolMasterUpdateWithoutSchoolBoardInput, schoolMasterUncheckedUpdateWithoutSchoolBoardInput>
  }

  export type schoolMasterUpdateManyWithWhereWithoutSchoolBoardInput = {
    where: schoolMasterScalarWhereInput
    data: XOR<schoolMasterUpdateManyMutationInput, schoolMasterUncheckedUpdateManyWithoutSchoolMasterInput>
  }

  export type schoolMasterCreateWithoutSchoolTypeInput = {
    id?: string
    name: string
    afflicationCode: string
    schoolBoard: SchoolBoardCreateNestedOneWithoutSchoolMasterInput
    salesTeam: SalesTeamCreateNestedOneWithoutSchoolMasterInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutSchoolIdInput
  }

  export type schoolMasterUncheckedCreateWithoutSchoolTypeInput = {
    id?: string
    name: string
    afflicationCode: string
    fkSchoolBoard: string
    fkSalesTeamId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutSchoolIdInput
  }

  export type schoolMasterCreateOrConnectWithoutSchoolTypeInput = {
    where: schoolMasterWhereUniqueInput
    create: XOR<schoolMasterCreateWithoutSchoolTypeInput, schoolMasterUncheckedCreateWithoutSchoolTypeInput>
  }

  export type schoolMasterCreateManySchoolTypeInputEnvelope = {
    data: Enumerable<schoolMasterCreateManySchoolTypeInput>
    skipDuplicates?: boolean
  }

  export type schoolMasterUpsertWithWhereUniqueWithoutSchoolTypeInput = {
    where: schoolMasterWhereUniqueInput
    update: XOR<schoolMasterUpdateWithoutSchoolTypeInput, schoolMasterUncheckedUpdateWithoutSchoolTypeInput>
    create: XOR<schoolMasterCreateWithoutSchoolTypeInput, schoolMasterUncheckedCreateWithoutSchoolTypeInput>
  }

  export type schoolMasterUpdateWithWhereUniqueWithoutSchoolTypeInput = {
    where: schoolMasterWhereUniqueInput
    data: XOR<schoolMasterUpdateWithoutSchoolTypeInput, schoolMasterUncheckedUpdateWithoutSchoolTypeInput>
  }

  export type schoolMasterUpdateManyWithWhereWithoutSchoolTypeInput = {
    where: schoolMasterScalarWhereInput
    data: XOR<schoolMasterUpdateManyMutationInput, schoolMasterUncheckedUpdateManyWithoutSchoolMasterInput>
  }

  export type schoolTypeCreateWithoutSchoolMasterInput = {
    id?: string
    schoolType: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type schoolTypeUncheckedCreateWithoutSchoolMasterInput = {
    id?: string
    schoolType: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type schoolTypeCreateOrConnectWithoutSchoolMasterInput = {
    where: schoolTypeWhereUniqueInput
    create: XOR<schoolTypeCreateWithoutSchoolMasterInput, schoolTypeUncheckedCreateWithoutSchoolMasterInput>
  }

  export type SchoolBoardCreateWithoutSchoolMasterInput = {
    id?: string
    boardname: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolBoardUncheckedCreateWithoutSchoolMasterInput = {
    id?: string
    boardname: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolBoardCreateOrConnectWithoutSchoolMasterInput = {
    where: SchoolBoardWhereUniqueInput
    create: XOR<SchoolBoardCreateWithoutSchoolMasterInput, SchoolBoardUncheckedCreateWithoutSchoolMasterInput>
  }

  export type SalesTeamCreateWithoutSchoolMasterInput = {
    id?: string
    email: string
    phone: string
    password: string
    dob: Date | string
    designation: DesignationCreateNestedOneWithoutSalesTeamInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeamDocuments?: SalesTeamDocumentsCreateNestedManyWithoutSalesTeamInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamUncheckedCreateWithoutSchoolMasterInput = {
    id?: string
    email: string
    phone: string
    password: string
    dob: Date | string
    fkDesignationId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeamDocuments?: SalesTeamDocumentsUncheckedCreateNestedManyWithoutSalesTeamInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamCreateOrConnectWithoutSchoolMasterInput = {
    where: SalesTeamWhereUniqueInput
    create: XOR<SalesTeamCreateWithoutSchoolMasterInput, SalesTeamUncheckedCreateWithoutSchoolMasterInput>
  }

  export type SchoolMasterAddressCreateWithoutSchoolIdInput = {
    id?: string
    Country: CountryCreateNestedOneWithoutSchoolMasterAddressInput
    State: StateCreateNestedOneWithoutSchoolMasterAddressInput
    City: CityCreateNestedOneWithoutSchoolMasterAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressUncheckedCreateWithoutSchoolIdInput = {
    id?: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressCreateOrConnectWithoutSchoolIdInput = {
    where: SchoolMasterAddressWhereUniqueInput
    create: XOR<SchoolMasterAddressCreateWithoutSchoolIdInput, SchoolMasterAddressUncheckedCreateWithoutSchoolIdInput>
  }

  export type SchoolMasterAddressCreateManySchoolIdInputEnvelope = {
    data: Enumerable<SchoolMasterAddressCreateManySchoolIdInput>
    skipDuplicates?: boolean
  }

  export type schoolTypeUpsertWithoutSchoolMasterInput = {
    update: XOR<schoolTypeUpdateWithoutSchoolMasterInput, schoolTypeUncheckedUpdateWithoutSchoolMasterInput>
    create: XOR<schoolTypeCreateWithoutSchoolMasterInput, schoolTypeUncheckedCreateWithoutSchoolMasterInput>
  }

  export type schoolTypeUpdateWithoutSchoolMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolType?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type schoolTypeUncheckedUpdateWithoutSchoolMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolType?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolBoardUpsertWithoutSchoolMasterInput = {
    update: XOR<SchoolBoardUpdateWithoutSchoolMasterInput, SchoolBoardUncheckedUpdateWithoutSchoolMasterInput>
    create: XOR<SchoolBoardCreateWithoutSchoolMasterInput, SchoolBoardUncheckedCreateWithoutSchoolMasterInput>
  }

  export type SchoolBoardUpdateWithoutSchoolMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardname?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolBoardUncheckedUpdateWithoutSchoolMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardname?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamUpsertWithoutSchoolMasterInput = {
    update: XOR<SalesTeamUpdateWithoutSchoolMasterInput, SalesTeamUncheckedUpdateWithoutSchoolMasterInput>
    create: XOR<SalesTeamCreateWithoutSchoolMasterInput, SalesTeamUncheckedCreateWithoutSchoolMasterInput>
  }

  export type SalesTeamUpdateWithoutSchoolMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    designation?: DesignationUpdateOneRequiredWithoutSalesTeamNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeamDocuments?: SalesTeamDocumentsUpdateManyWithoutSalesTeamNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutSalesTeamNestedInput
  }

  export type SalesTeamUncheckedUpdateWithoutSchoolMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    fkDesignationId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeamDocuments?: SalesTeamDocumentsUncheckedUpdateManyWithoutSalesTeamNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutSalesTeamNestedInput
  }

  export type SchoolMasterAddressUpsertWithWhereUniqueWithoutSchoolIdInput = {
    where: SchoolMasterAddressWhereUniqueInput
    update: XOR<SchoolMasterAddressUpdateWithoutSchoolIdInput, SchoolMasterAddressUncheckedUpdateWithoutSchoolIdInput>
    create: XOR<SchoolMasterAddressCreateWithoutSchoolIdInput, SchoolMasterAddressUncheckedCreateWithoutSchoolIdInput>
  }

  export type SchoolMasterAddressUpdateWithWhereUniqueWithoutSchoolIdInput = {
    where: SchoolMasterAddressWhereUniqueInput
    data: XOR<SchoolMasterAddressUpdateWithoutSchoolIdInput, SchoolMasterAddressUncheckedUpdateWithoutSchoolIdInput>
  }

  export type SchoolMasterAddressUpdateManyWithWhereWithoutSchoolIdInput = {
    where: SchoolMasterAddressScalarWhereInput
    data: XOR<SchoolMasterAddressUpdateManyMutationInput, SchoolMasterAddressUncheckedUpdateManyWithoutSchoolMasterAddressInput>
  }

  export type schoolMasterCreateWithoutSchoolMasterAddressInput = {
    id?: string
    name: string
    afflicationCode: string
    schoolType: schoolTypeCreateNestedOneWithoutSchoolMasterInput
    schoolBoard: SchoolBoardCreateNestedOneWithoutSchoolMasterInput
    salesTeam: SalesTeamCreateNestedOneWithoutSchoolMasterInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type schoolMasterUncheckedCreateWithoutSchoolMasterAddressInput = {
    id?: string
    name: string
    afflicationCode: string
    fkSchoolType: string
    fkSchoolBoard: string
    fkSalesTeamId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type schoolMasterCreateOrConnectWithoutSchoolMasterAddressInput = {
    where: schoolMasterWhereUniqueInput
    create: XOR<schoolMasterCreateWithoutSchoolMasterAddressInput, schoolMasterUncheckedCreateWithoutSchoolMasterAddressInput>
  }

  export type CountryCreateWithoutSchoolMasterAddressInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    State?: StateCreateNestedManyWithoutCountryInput
    StudentAddress?: StudentAddressCreateNestedManyWithoutCountryInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutCountryInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutSchoolMasterAddressInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    State?: StateUncheckedCreateNestedManyWithoutCountryInput
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutCountryInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutCountryInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutSchoolMasterAddressInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutSchoolMasterAddressInput, CountryUncheckedCreateWithoutSchoolMasterAddressInput>
  }

  export type StateCreateWithoutSchoolMasterAddressInput = {
    id?: string
    StateName: string
    Country: CountryCreateNestedOneWithoutStateInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    City?: CityCreateNestedManyWithoutStateInput
    StudentAddress?: StudentAddressCreateNestedManyWithoutStateInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutStateInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutSchoolMasterAddressInput = {
    id?: string
    StateName: string
    fkCountryId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    City?: CityUncheckedCreateNestedManyWithoutStateInput
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutStateInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutStateInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutSchoolMasterAddressInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutSchoolMasterAddressInput, StateUncheckedCreateWithoutSchoolMasterAddressInput>
  }

  export type CityCreateWithoutSchoolMasterAddressInput = {
    id?: string
    CityName: string
    State: StateCreateNestedOneWithoutCityInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressCreateNestedManyWithoutCityInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutCityInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutSchoolMasterAddressInput = {
    id?: string
    CityName: string
    fkStateId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutCityInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutCityInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutSchoolMasterAddressInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutSchoolMasterAddressInput, CityUncheckedCreateWithoutSchoolMasterAddressInput>
  }

  export type schoolMasterUpsertWithoutSchoolMasterAddressInput = {
    update: XOR<schoolMasterUpdateWithoutSchoolMasterAddressInput, schoolMasterUncheckedUpdateWithoutSchoolMasterAddressInput>
    create: XOR<schoolMasterCreateWithoutSchoolMasterAddressInput, schoolMasterUncheckedCreateWithoutSchoolMasterAddressInput>
  }

  export type schoolMasterUpdateWithoutSchoolMasterAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    schoolType?: schoolTypeUpdateOneRequiredWithoutSchoolMasterNestedInput
    schoolBoard?: SchoolBoardUpdateOneRequiredWithoutSchoolMasterNestedInput
    salesTeam?: SalesTeamUpdateOneRequiredWithoutSchoolMasterNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type schoolMasterUncheckedUpdateWithoutSchoolMasterAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    fkSchoolType?: StringFieldUpdateOperationsInput | string
    fkSchoolBoard?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUpsertWithoutSchoolMasterAddressInput = {
    update: XOR<CountryUpdateWithoutSchoolMasterAddressInput, CountryUncheckedUpdateWithoutSchoolMasterAddressInput>
    create: XOR<CountryCreateWithoutSchoolMasterAddressInput, CountryUncheckedCreateWithoutSchoolMasterAddressInput>
  }

  export type CountryUpdateWithoutSchoolMasterAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    State?: StateUpdateManyWithoutCountryNestedInput
    StudentAddress?: StudentAddressUpdateManyWithoutCountryNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutCountryNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutSchoolMasterAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    State?: StateUncheckedUpdateManyWithoutCountryNestedInput
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutCountryNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutCountryNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type StateUpsertWithoutSchoolMasterAddressInput = {
    update: XOR<StateUpdateWithoutSchoolMasterAddressInput, StateUncheckedUpdateWithoutSchoolMasterAddressInput>
    create: XOR<StateCreateWithoutSchoolMasterAddressInput, StateUncheckedCreateWithoutSchoolMasterAddressInput>
  }

  export type StateUpdateWithoutSchoolMasterAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    Country?: CountryUpdateOneRequiredWithoutStateNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUpdateManyWithoutStateNestedInput
    StudentAddress?: StudentAddressUpdateManyWithoutStateNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutStateNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutSchoolMasterAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUncheckedUpdateManyWithoutStateNestedInput
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutStateNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutStateNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutStateNestedInput
  }

  export type CityUpsertWithoutSchoolMasterAddressInput = {
    update: XOR<CityUpdateWithoutSchoolMasterAddressInput, CityUncheckedUpdateWithoutSchoolMasterAddressInput>
    create: XOR<CityCreateWithoutSchoolMasterAddressInput, CityUncheckedCreateWithoutSchoolMasterAddressInput>
  }

  export type CityUpdateWithoutSchoolMasterAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    State?: StateUpdateOneRequiredWithoutCityNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUpdateManyWithoutCityNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutCityNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutSchoolMasterAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutCityNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutCityNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutCityNestedInput
  }

  export type StudentDocumentsCreateWithoutStudentIdInput = {
    id?: string
    category: string
    docUrl: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentDocumentsUncheckedCreateWithoutStudentIdInput = {
    id?: string
    category: string
    docUrl: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentDocumentsCreateOrConnectWithoutStudentIdInput = {
    where: StudentDocumentsWhereUniqueInput
    create: XOR<StudentDocumentsCreateWithoutStudentIdInput, StudentDocumentsUncheckedCreateWithoutStudentIdInput>
  }

  export type StudentDocumentsCreateManyStudentIdInputEnvelope = {
    data: Enumerable<StudentDocumentsCreateManyStudentIdInput>
    skipDuplicates?: boolean
  }

  export type StudentAddressCreateWithoutStudentIdInput = {
    id?: string
    Country: CountryCreateNestedOneWithoutStudentAddressInput
    State: StateCreateNestedOneWithoutStudentAddressInput
    City: CityCreateNestedOneWithoutStudentAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressUncheckedCreateWithoutStudentIdInput = {
    id?: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressCreateOrConnectWithoutStudentIdInput = {
    where: StudentAddressWhereUniqueInput
    create: XOR<StudentAddressCreateWithoutStudentIdInput, StudentAddressUncheckedCreateWithoutStudentIdInput>
  }

  export type StudentAddressCreateManyStudentIdInputEnvelope = {
    data: Enumerable<StudentAddressCreateManyStudentIdInput>
    skipDuplicates?: boolean
  }

  export type StudentParentsCreateWithoutStudentIdInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentsUncheckedCreateWithoutStudentIdInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentsCreateOrConnectWithoutStudentIdInput = {
    where: StudentParentsWhereUniqueInput
    create: XOR<StudentParentsCreateWithoutStudentIdInput, StudentParentsUncheckedCreateWithoutStudentIdInput>
  }

  export type StudentParentsCreateManyStudentIdInputEnvelope = {
    data: Enumerable<StudentParentsCreateManyStudentIdInput>
    skipDuplicates?: boolean
  }

  export type StudentDocumentsUpsertWithWhereUniqueWithoutStudentIdInput = {
    where: StudentDocumentsWhereUniqueInput
    update: XOR<StudentDocumentsUpdateWithoutStudentIdInput, StudentDocumentsUncheckedUpdateWithoutStudentIdInput>
    create: XOR<StudentDocumentsCreateWithoutStudentIdInput, StudentDocumentsUncheckedCreateWithoutStudentIdInput>
  }

  export type StudentDocumentsUpdateWithWhereUniqueWithoutStudentIdInput = {
    where: StudentDocumentsWhereUniqueInput
    data: XOR<StudentDocumentsUpdateWithoutStudentIdInput, StudentDocumentsUncheckedUpdateWithoutStudentIdInput>
  }

  export type StudentDocumentsUpdateManyWithWhereWithoutStudentIdInput = {
    where: StudentDocumentsScalarWhereInput
    data: XOR<StudentDocumentsUpdateManyMutationInput, StudentDocumentsUncheckedUpdateManyWithoutStudentDetailInput>
  }

  export type StudentDocumentsScalarWhereInput = {
    AND?: Enumerable<StudentDocumentsScalarWhereInput>
    OR?: Enumerable<StudentDocumentsScalarWhereInput>
    NOT?: Enumerable<StudentDocumentsScalarWhereInput>
    id?: UuidFilter | string
    fkStudentId?: UuidFilter | string
    category?: StringFilter | string
    docUrl?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StudentAddressUpsertWithWhereUniqueWithoutStudentIdInput = {
    where: StudentAddressWhereUniqueInput
    update: XOR<StudentAddressUpdateWithoutStudentIdInput, StudentAddressUncheckedUpdateWithoutStudentIdInput>
    create: XOR<StudentAddressCreateWithoutStudentIdInput, StudentAddressUncheckedCreateWithoutStudentIdInput>
  }

  export type StudentAddressUpdateWithWhereUniqueWithoutStudentIdInput = {
    where: StudentAddressWhereUniqueInput
    data: XOR<StudentAddressUpdateWithoutStudentIdInput, StudentAddressUncheckedUpdateWithoutStudentIdInput>
  }

  export type StudentAddressUpdateManyWithWhereWithoutStudentIdInput = {
    where: StudentAddressScalarWhereInput
    data: XOR<StudentAddressUpdateManyMutationInput, StudentAddressUncheckedUpdateManyWithoutStudentAddressInput>
  }

  export type StudentParentsUpsertWithWhereUniqueWithoutStudentIdInput = {
    where: StudentParentsWhereUniqueInput
    update: XOR<StudentParentsUpdateWithoutStudentIdInput, StudentParentsUncheckedUpdateWithoutStudentIdInput>
    create: XOR<StudentParentsCreateWithoutStudentIdInput, StudentParentsUncheckedCreateWithoutStudentIdInput>
  }

  export type StudentParentsUpdateWithWhereUniqueWithoutStudentIdInput = {
    where: StudentParentsWhereUniqueInput
    data: XOR<StudentParentsUpdateWithoutStudentIdInput, StudentParentsUncheckedUpdateWithoutStudentIdInput>
  }

  export type StudentParentsUpdateManyWithWhereWithoutStudentIdInput = {
    where: StudentParentsScalarWhereInput
    data: XOR<StudentParentsUpdateManyMutationInput, StudentParentsUncheckedUpdateManyWithoutStudentParentsInput>
  }

  export type StudentParentsScalarWhereInput = {
    AND?: Enumerable<StudentParentsScalarWhereInput>
    OR?: Enumerable<StudentParentsScalarWhereInput>
    NOT?: Enumerable<StudentParentsScalarWhereInput>
    id?: UuidFilter | string
    fkStudentId?: UuidFilter | string
    name?: StringFilter | string
    relation?: StringFilter | string
    phone?: StringFilter | string
    email?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StudentMasterCreateWithoutStudentParentsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    dob: Date | string
    admissionId: string
    rollNo: string
    profileImg: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentDetail?: StudentDocumentsCreateNestedManyWithoutStudentIdInput
    StudentAddress?: StudentAddressCreateNestedManyWithoutStudentIdInput
  }

  export type StudentMasterUncheckedCreateWithoutStudentParentsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    dob: Date | string
    admissionId: string
    rollNo: string
    profileImg: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentDetail?: StudentDocumentsUncheckedCreateNestedManyWithoutStudentIdInput
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutStudentIdInput
  }

  export type StudentMasterCreateOrConnectWithoutStudentParentsInput = {
    where: StudentMasterWhereUniqueInput
    create: XOR<StudentMasterCreateWithoutStudentParentsInput, StudentMasterUncheckedCreateWithoutStudentParentsInput>
  }

  export type StudentMasterUpsertWithoutStudentParentsInput = {
    update: XOR<StudentMasterUpdateWithoutStudentParentsInput, StudentMasterUncheckedUpdateWithoutStudentParentsInput>
    create: XOR<StudentMasterCreateWithoutStudentParentsInput, StudentMasterUncheckedCreateWithoutStudentParentsInput>
  }

  export type StudentMasterUpdateWithoutStudentParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionId?: StringFieldUpdateOperationsInput | string
    rollNo?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentDetail?: StudentDocumentsUpdateManyWithoutStudentIdNestedInput
    StudentAddress?: StudentAddressUpdateManyWithoutStudentIdNestedInput
  }

  export type StudentMasterUncheckedUpdateWithoutStudentParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionId?: StringFieldUpdateOperationsInput | string
    rollNo?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentDetail?: StudentDocumentsUncheckedUpdateManyWithoutStudentIdNestedInput
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutStudentIdNestedInput
  }

  export type StudentMasterCreateWithoutStudentDetailInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    dob: Date | string
    admissionId: string
    rollNo: string
    profileImg: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressCreateNestedManyWithoutStudentIdInput
    StudentParents?: StudentParentsCreateNestedManyWithoutStudentIdInput
  }

  export type StudentMasterUncheckedCreateWithoutStudentDetailInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    dob: Date | string
    admissionId: string
    rollNo: string
    profileImg: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutStudentIdInput
    StudentParents?: StudentParentsUncheckedCreateNestedManyWithoutStudentIdInput
  }

  export type StudentMasterCreateOrConnectWithoutStudentDetailInput = {
    where: StudentMasterWhereUniqueInput
    create: XOR<StudentMasterCreateWithoutStudentDetailInput, StudentMasterUncheckedCreateWithoutStudentDetailInput>
  }

  export type StudentMasterUpsertWithoutStudentDetailInput = {
    update: XOR<StudentMasterUpdateWithoutStudentDetailInput, StudentMasterUncheckedUpdateWithoutStudentDetailInput>
    create: XOR<StudentMasterCreateWithoutStudentDetailInput, StudentMasterUncheckedCreateWithoutStudentDetailInput>
  }

  export type StudentMasterUpdateWithoutStudentDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionId?: StringFieldUpdateOperationsInput | string
    rollNo?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUpdateManyWithoutStudentIdNestedInput
    StudentParents?: StudentParentsUpdateManyWithoutStudentIdNestedInput
  }

  export type StudentMasterUncheckedUpdateWithoutStudentDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionId?: StringFieldUpdateOperationsInput | string
    rollNo?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutStudentIdNestedInput
    StudentParents?: StudentParentsUncheckedUpdateManyWithoutStudentIdNestedInput
  }

  export type StudentMasterCreateWithoutStudentAddressInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    dob: Date | string
    admissionId: string
    rollNo: string
    profileImg: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentDetail?: StudentDocumentsCreateNestedManyWithoutStudentIdInput
    StudentParents?: StudentParentsCreateNestedManyWithoutStudentIdInput
  }

  export type StudentMasterUncheckedCreateWithoutStudentAddressInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    dob: Date | string
    admissionId: string
    rollNo: string
    profileImg: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentDetail?: StudentDocumentsUncheckedCreateNestedManyWithoutStudentIdInput
    StudentParents?: StudentParentsUncheckedCreateNestedManyWithoutStudentIdInput
  }

  export type StudentMasterCreateOrConnectWithoutStudentAddressInput = {
    where: StudentMasterWhereUniqueInput
    create: XOR<StudentMasterCreateWithoutStudentAddressInput, StudentMasterUncheckedCreateWithoutStudentAddressInput>
  }

  export type CountryCreateWithoutStudentAddressInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    State?: StateCreateNestedManyWithoutCountryInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutCountryInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutCountryInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutStudentAddressInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    State?: StateUncheckedCreateNestedManyWithoutCountryInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutCountryInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutCountryInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutStudentAddressInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutStudentAddressInput, CountryUncheckedCreateWithoutStudentAddressInput>
  }

  export type StateCreateWithoutStudentAddressInput = {
    id?: string
    StateName: string
    Country: CountryCreateNestedOneWithoutStateInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    City?: CityCreateNestedManyWithoutStateInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutStateInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutStateInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutStudentAddressInput = {
    id?: string
    StateName: string
    fkCountryId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    City?: CityUncheckedCreateNestedManyWithoutStateInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutStateInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutStateInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutStudentAddressInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutStudentAddressInput, StateUncheckedCreateWithoutStudentAddressInput>
  }

  export type CityCreateWithoutStudentAddressInput = {
    id?: string
    CityName: string
    State: StateCreateNestedOneWithoutCityInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutCityInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutCityInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutStudentAddressInput = {
    id?: string
    CityName: string
    fkStateId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutCityInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutCityInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutStudentAddressInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutStudentAddressInput, CityUncheckedCreateWithoutStudentAddressInput>
  }

  export type StudentMasterUpsertWithoutStudentAddressInput = {
    update: XOR<StudentMasterUpdateWithoutStudentAddressInput, StudentMasterUncheckedUpdateWithoutStudentAddressInput>
    create: XOR<StudentMasterCreateWithoutStudentAddressInput, StudentMasterUncheckedCreateWithoutStudentAddressInput>
  }

  export type StudentMasterUpdateWithoutStudentAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionId?: StringFieldUpdateOperationsInput | string
    rollNo?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentDetail?: StudentDocumentsUpdateManyWithoutStudentIdNestedInput
    StudentParents?: StudentParentsUpdateManyWithoutStudentIdNestedInput
  }

  export type StudentMasterUncheckedUpdateWithoutStudentAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionId?: StringFieldUpdateOperationsInput | string
    rollNo?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentDetail?: StudentDocumentsUncheckedUpdateManyWithoutStudentIdNestedInput
    StudentParents?: StudentParentsUncheckedUpdateManyWithoutStudentIdNestedInput
  }

  export type CountryUpsertWithoutStudentAddressInput = {
    update: XOR<CountryUpdateWithoutStudentAddressInput, CountryUncheckedUpdateWithoutStudentAddressInput>
    create: XOR<CountryCreateWithoutStudentAddressInput, CountryUncheckedCreateWithoutStudentAddressInput>
  }

  export type CountryUpdateWithoutStudentAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    State?: StateUpdateManyWithoutCountryNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutCountryNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutCountryNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutStudentAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    State?: StateUncheckedUpdateManyWithoutCountryNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutCountryNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutCountryNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type StateUpsertWithoutStudentAddressInput = {
    update: XOR<StateUpdateWithoutStudentAddressInput, StateUncheckedUpdateWithoutStudentAddressInput>
    create: XOR<StateCreateWithoutStudentAddressInput, StateUncheckedCreateWithoutStudentAddressInput>
  }

  export type StateUpdateWithoutStudentAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    Country?: CountryUpdateOneRequiredWithoutStateNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUpdateManyWithoutStateNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutStateNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutStateNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutStudentAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUncheckedUpdateManyWithoutStateNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutStateNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutStateNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutStateNestedInput
  }

  export type CityUpsertWithoutStudentAddressInput = {
    update: XOR<CityUpdateWithoutStudentAddressInput, CityUncheckedUpdateWithoutStudentAddressInput>
    create: XOR<CityCreateWithoutStudentAddressInput, CityUncheckedCreateWithoutStudentAddressInput>
  }

  export type CityUpdateWithoutStudentAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    State?: StateUpdateOneRequiredWithoutCityNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherAddress?: TeacherAddressUpdateManyWithoutCityNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutCityNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutStudentAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutCityNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutCityNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutCityNestedInput
  }

  export type TeacherMasterCreateWithoutTeacherdepartmentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    profileImg: string
    joiningDate: Date | string
    designation: DesignationCreateNestedOneWithoutTeacherMasterInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherDocuments?: TeacherDocumentsCreateNestedManyWithoutTeacherIdInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutTeacherIdInput
    TeacherExprience?: TeacherExprienceCreateNestedManyWithoutTeacherIdInput
  }

  export type TeacherMasterUncheckedCreateWithoutTeacherdepartmentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    profileImg: string
    joiningDate: Date | string
    fkDesignationId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherDocuments?: TeacherDocumentsUncheckedCreateNestedManyWithoutTeacherIdInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutTeacherIdInput
    TeacherExprience?: TeacherExprienceUncheckedCreateNestedManyWithoutTeacherIdInput
  }

  export type TeacherMasterCreateOrConnectWithoutTeacherdepartmentInput = {
    where: TeacherMasterWhereUniqueInput
    create: XOR<TeacherMasterCreateWithoutTeacherdepartmentInput, TeacherMasterUncheckedCreateWithoutTeacherdepartmentInput>
  }

  export type TeacherMasterCreateManyTeacherdepartmentInputEnvelope = {
    data: Enumerable<TeacherMasterCreateManyTeacherdepartmentInput>
    skipDuplicates?: boolean
  }

  export type TeacherMasterUpsertWithWhereUniqueWithoutTeacherdepartmentInput = {
    where: TeacherMasterWhereUniqueInput
    update: XOR<TeacherMasterUpdateWithoutTeacherdepartmentInput, TeacherMasterUncheckedUpdateWithoutTeacherdepartmentInput>
    create: XOR<TeacherMasterCreateWithoutTeacherdepartmentInput, TeacherMasterUncheckedCreateWithoutTeacherdepartmentInput>
  }

  export type TeacherMasterUpdateWithWhereUniqueWithoutTeacherdepartmentInput = {
    where: TeacherMasterWhereUniqueInput
    data: XOR<TeacherMasterUpdateWithoutTeacherdepartmentInput, TeacherMasterUncheckedUpdateWithoutTeacherdepartmentInput>
  }

  export type TeacherMasterUpdateManyWithWhereWithoutTeacherdepartmentInput = {
    where: TeacherMasterScalarWhereInput
    data: XOR<TeacherMasterUpdateManyMutationInput, TeacherMasterUncheckedUpdateManyWithoutTeacherMasterInput>
  }

  export type TeacherDepartmentCreateWithoutTeacherMasterInput = {
    id?: string
    department: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherDepartmentUncheckedCreateWithoutTeacherMasterInput = {
    id?: string
    department: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherDepartmentCreateOrConnectWithoutTeacherMasterInput = {
    where: TeacherDepartmentWhereUniqueInput
    create: XOR<TeacherDepartmentCreateWithoutTeacherMasterInput, TeacherDepartmentUncheckedCreateWithoutTeacherMasterInput>
  }

  export type DesignationCreateWithoutTeacherMasterInput = {
    id?: string
    roles: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeam?: SalesTeamCreateNestedManyWithoutDesignationInput
  }

  export type DesignationUncheckedCreateWithoutTeacherMasterInput = {
    id?: string
    roles: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    SalesTeam?: SalesTeamUncheckedCreateNestedManyWithoutDesignationInput
  }

  export type DesignationCreateOrConnectWithoutTeacherMasterInput = {
    where: DesignationWhereUniqueInput
    create: XOR<DesignationCreateWithoutTeacherMasterInput, DesignationUncheckedCreateWithoutTeacherMasterInput>
  }

  export type TeacherDocumentsCreateWithoutTeacherIdInput = {
    id?: string
    category: string
    docUrl: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherDocumentsUncheckedCreateWithoutTeacherIdInput = {
    id?: string
    category: string
    docUrl: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherDocumentsCreateOrConnectWithoutTeacherIdInput = {
    where: TeacherDocumentsWhereUniqueInput
    create: XOR<TeacherDocumentsCreateWithoutTeacherIdInput, TeacherDocumentsUncheckedCreateWithoutTeacherIdInput>
  }

  export type TeacherDocumentsCreateManyTeacherIdInputEnvelope = {
    data: Enumerable<TeacherDocumentsCreateManyTeacherIdInput>
    skipDuplicates?: boolean
  }

  export type TeacherAddressCreateWithoutTeacherIdInput = {
    id?: string
    Country: CountryCreateNestedOneWithoutTeacherAddressInput
    State: StateCreateNestedOneWithoutTeacherAddressInput
    City: CityCreateNestedOneWithoutTeacherAddressInput
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressUncheckedCreateWithoutTeacherIdInput = {
    id?: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressCreateOrConnectWithoutTeacherIdInput = {
    where: TeacherAddressWhereUniqueInput
    create: XOR<TeacherAddressCreateWithoutTeacherIdInput, TeacherAddressUncheckedCreateWithoutTeacherIdInput>
  }

  export type TeacherAddressCreateManyTeacherIdInputEnvelope = {
    data: Enumerable<TeacherAddressCreateManyTeacherIdInput>
    skipDuplicates?: boolean
  }

  export type TeacherExprienceCreateWithoutTeacherIdInput = {
    id?: string
    skills?: TeacherExprienceCreateskillsInput | Enumerable<InputJsonValue>
    experience: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherExprienceUncheckedCreateWithoutTeacherIdInput = {
    id?: string
    skills?: TeacherExprienceCreateskillsInput | Enumerable<InputJsonValue>
    experience: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherExprienceCreateOrConnectWithoutTeacherIdInput = {
    where: TeacherExprienceWhereUniqueInput
    create: XOR<TeacherExprienceCreateWithoutTeacherIdInput, TeacherExprienceUncheckedCreateWithoutTeacherIdInput>
  }

  export type TeacherExprienceCreateManyTeacherIdInputEnvelope = {
    data: Enumerable<TeacherExprienceCreateManyTeacherIdInput>
    skipDuplicates?: boolean
  }

  export type TeacherDepartmentUpsertWithoutTeacherMasterInput = {
    update: XOR<TeacherDepartmentUpdateWithoutTeacherMasterInput, TeacherDepartmentUncheckedUpdateWithoutTeacherMasterInput>
    create: XOR<TeacherDepartmentCreateWithoutTeacherMasterInput, TeacherDepartmentUncheckedCreateWithoutTeacherMasterInput>
  }

  export type TeacherDepartmentUpdateWithoutTeacherMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherDepartmentUncheckedUpdateWithoutTeacherMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignationUpsertWithoutTeacherMasterInput = {
    update: XOR<DesignationUpdateWithoutTeacherMasterInput, DesignationUncheckedUpdateWithoutTeacherMasterInput>
    create: XOR<DesignationCreateWithoutTeacherMasterInput, DesignationUncheckedCreateWithoutTeacherMasterInput>
  }

  export type DesignationUpdateWithoutTeacherMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeam?: SalesTeamUpdateManyWithoutDesignationNestedInput
  }

  export type DesignationUncheckedUpdateWithoutTeacherMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeam?: SalesTeamUncheckedUpdateManyWithoutDesignationNestedInput
  }

  export type TeacherDocumentsUpsertWithWhereUniqueWithoutTeacherIdInput = {
    where: TeacherDocumentsWhereUniqueInput
    update: XOR<TeacherDocumentsUpdateWithoutTeacherIdInput, TeacherDocumentsUncheckedUpdateWithoutTeacherIdInput>
    create: XOR<TeacherDocumentsCreateWithoutTeacherIdInput, TeacherDocumentsUncheckedCreateWithoutTeacherIdInput>
  }

  export type TeacherDocumentsUpdateWithWhereUniqueWithoutTeacherIdInput = {
    where: TeacherDocumentsWhereUniqueInput
    data: XOR<TeacherDocumentsUpdateWithoutTeacherIdInput, TeacherDocumentsUncheckedUpdateWithoutTeacherIdInput>
  }

  export type TeacherDocumentsUpdateManyWithWhereWithoutTeacherIdInput = {
    where: TeacherDocumentsScalarWhereInput
    data: XOR<TeacherDocumentsUpdateManyMutationInput, TeacherDocumentsUncheckedUpdateManyWithoutTeacherDocumentsInput>
  }

  export type TeacherDocumentsScalarWhereInput = {
    AND?: Enumerable<TeacherDocumentsScalarWhereInput>
    OR?: Enumerable<TeacherDocumentsScalarWhereInput>
    NOT?: Enumerable<TeacherDocumentsScalarWhereInput>
    id?: UuidFilter | string
    fkTeacherId?: UuidFilter | string
    category?: StringFilter | string
    docUrl?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TeacherAddressUpsertWithWhereUniqueWithoutTeacherIdInput = {
    where: TeacherAddressWhereUniqueInput
    update: XOR<TeacherAddressUpdateWithoutTeacherIdInput, TeacherAddressUncheckedUpdateWithoutTeacherIdInput>
    create: XOR<TeacherAddressCreateWithoutTeacherIdInput, TeacherAddressUncheckedCreateWithoutTeacherIdInput>
  }

  export type TeacherAddressUpdateWithWhereUniqueWithoutTeacherIdInput = {
    where: TeacherAddressWhereUniqueInput
    data: XOR<TeacherAddressUpdateWithoutTeacherIdInput, TeacherAddressUncheckedUpdateWithoutTeacherIdInput>
  }

  export type TeacherAddressUpdateManyWithWhereWithoutTeacherIdInput = {
    where: TeacherAddressScalarWhereInput
    data: XOR<TeacherAddressUpdateManyMutationInput, TeacherAddressUncheckedUpdateManyWithoutTeacherAddressInput>
  }

  export type TeacherExprienceUpsertWithWhereUniqueWithoutTeacherIdInput = {
    where: TeacherExprienceWhereUniqueInput
    update: XOR<TeacherExprienceUpdateWithoutTeacherIdInput, TeacherExprienceUncheckedUpdateWithoutTeacherIdInput>
    create: XOR<TeacherExprienceCreateWithoutTeacherIdInput, TeacherExprienceUncheckedCreateWithoutTeacherIdInput>
  }

  export type TeacherExprienceUpdateWithWhereUniqueWithoutTeacherIdInput = {
    where: TeacherExprienceWhereUniqueInput
    data: XOR<TeacherExprienceUpdateWithoutTeacherIdInput, TeacherExprienceUncheckedUpdateWithoutTeacherIdInput>
  }

  export type TeacherExprienceUpdateManyWithWhereWithoutTeacherIdInput = {
    where: TeacherExprienceScalarWhereInput
    data: XOR<TeacherExprienceUpdateManyMutationInput, TeacherExprienceUncheckedUpdateManyWithoutTeacherExprienceInput>
  }

  export type TeacherExprienceScalarWhereInput = {
    AND?: Enumerable<TeacherExprienceScalarWhereInput>
    OR?: Enumerable<TeacherExprienceScalarWhereInput>
    NOT?: Enumerable<TeacherExprienceScalarWhereInput>
    id?: UuidFilter | string
    fkTeacherId?: UuidFilter | string
    skills?: JsonNullableListFilter
    experience?: StringFilter | string
    status?: BoolFilter | boolean
    createAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TeacherMasterCreateWithoutTeacherExprienceInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    Teacherdepartment: TeacherDepartmentCreateNestedOneWithoutTeacherMasterInput
    profileImg: string
    joiningDate: Date | string
    designation: DesignationCreateNestedOneWithoutTeacherMasterInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherDocuments?: TeacherDocumentsCreateNestedManyWithoutTeacherIdInput
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutTeacherIdInput
  }

  export type TeacherMasterUncheckedCreateWithoutTeacherExprienceInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    fkTeacherDepartmentId: string
    profileImg: string
    joiningDate: Date | string
    fkDesignationId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherDocuments?: TeacherDocumentsUncheckedCreateNestedManyWithoutTeacherIdInput
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutTeacherIdInput
  }

  export type TeacherMasterCreateOrConnectWithoutTeacherExprienceInput = {
    where: TeacherMasterWhereUniqueInput
    create: XOR<TeacherMasterCreateWithoutTeacherExprienceInput, TeacherMasterUncheckedCreateWithoutTeacherExprienceInput>
  }

  export type TeacherMasterUpsertWithoutTeacherExprienceInput = {
    update: XOR<TeacherMasterUpdateWithoutTeacherExprienceInput, TeacherMasterUncheckedUpdateWithoutTeacherExprienceInput>
    create: XOR<TeacherMasterCreateWithoutTeacherExprienceInput, TeacherMasterUncheckedCreateWithoutTeacherExprienceInput>
  }

  export type TeacherMasterUpdateWithoutTeacherExprienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    Teacherdepartment?: TeacherDepartmentUpdateOneRequiredWithoutTeacherMasterNestedInput
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    designation?: DesignationUpdateOneRequiredWithoutTeacherMasterNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherDocuments?: TeacherDocumentsUpdateManyWithoutTeacherIdNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutTeacherIdNestedInput
  }

  export type TeacherMasterUncheckedUpdateWithoutTeacherExprienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    fkTeacherDepartmentId?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fkDesignationId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherDocuments?: TeacherDocumentsUncheckedUpdateManyWithoutTeacherIdNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutTeacherIdNestedInput
  }

  export type TeacherMasterCreateWithoutTeacherDocumentsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    Teacherdepartment: TeacherDepartmentCreateNestedOneWithoutTeacherMasterInput
    profileImg: string
    joiningDate: Date | string
    designation: DesignationCreateNestedOneWithoutTeacherMasterInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherAddress?: TeacherAddressCreateNestedManyWithoutTeacherIdInput
    TeacherExprience?: TeacherExprienceCreateNestedManyWithoutTeacherIdInput
  }

  export type TeacherMasterUncheckedCreateWithoutTeacherDocumentsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    fkTeacherDepartmentId: string
    profileImg: string
    joiningDate: Date | string
    fkDesignationId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherAddress?: TeacherAddressUncheckedCreateNestedManyWithoutTeacherIdInput
    TeacherExprience?: TeacherExprienceUncheckedCreateNestedManyWithoutTeacherIdInput
  }

  export type TeacherMasterCreateOrConnectWithoutTeacherDocumentsInput = {
    where: TeacherMasterWhereUniqueInput
    create: XOR<TeacherMasterCreateWithoutTeacherDocumentsInput, TeacherMasterUncheckedCreateWithoutTeacherDocumentsInput>
  }

  export type TeacherMasterUpsertWithoutTeacherDocumentsInput = {
    update: XOR<TeacherMasterUpdateWithoutTeacherDocumentsInput, TeacherMasterUncheckedUpdateWithoutTeacherDocumentsInput>
    create: XOR<TeacherMasterCreateWithoutTeacherDocumentsInput, TeacherMasterUncheckedCreateWithoutTeacherDocumentsInput>
  }

  export type TeacherMasterUpdateWithoutTeacherDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    Teacherdepartment?: TeacherDepartmentUpdateOneRequiredWithoutTeacherMasterNestedInput
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    designation?: DesignationUpdateOneRequiredWithoutTeacherMasterNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherAddress?: TeacherAddressUpdateManyWithoutTeacherIdNestedInput
    TeacherExprience?: TeacherExprienceUpdateManyWithoutTeacherIdNestedInput
  }

  export type TeacherMasterUncheckedUpdateWithoutTeacherDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    fkTeacherDepartmentId?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fkDesignationId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutTeacherIdNestedInput
    TeacherExprience?: TeacherExprienceUncheckedUpdateManyWithoutTeacherIdNestedInput
  }

  export type TeacherMasterCreateWithoutTeacherAddressInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    Teacherdepartment: TeacherDepartmentCreateNestedOneWithoutTeacherMasterInput
    profileImg: string
    joiningDate: Date | string
    designation: DesignationCreateNestedOneWithoutTeacherMasterInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherDocuments?: TeacherDocumentsCreateNestedManyWithoutTeacherIdInput
    TeacherExprience?: TeacherExprienceCreateNestedManyWithoutTeacherIdInput
  }

  export type TeacherMasterUncheckedCreateWithoutTeacherAddressInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    fkTeacherDepartmentId: string
    profileImg: string
    joiningDate: Date | string
    fkDesignationId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    TeacherDocuments?: TeacherDocumentsUncheckedCreateNestedManyWithoutTeacherIdInput
    TeacherExprience?: TeacherExprienceUncheckedCreateNestedManyWithoutTeacherIdInput
  }

  export type TeacherMasterCreateOrConnectWithoutTeacherAddressInput = {
    where: TeacherMasterWhereUniqueInput
    create: XOR<TeacherMasterCreateWithoutTeacherAddressInput, TeacherMasterUncheckedCreateWithoutTeacherAddressInput>
  }

  export type CountryCreateWithoutTeacherAddressInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    State?: StateCreateNestedManyWithoutCountryInput
    StudentAddress?: StudentAddressCreateNestedManyWithoutCountryInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutCountryInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutTeacherAddressInput = {
    id?: string
    CounrtyName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    State?: StateUncheckedCreateNestedManyWithoutCountryInput
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutCountryInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutCountryInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutTeacherAddressInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutTeacherAddressInput, CountryUncheckedCreateWithoutTeacherAddressInput>
  }

  export type StateCreateWithoutTeacherAddressInput = {
    id?: string
    StateName: string
    Country: CountryCreateNestedOneWithoutStateInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    City?: CityCreateNestedManyWithoutStateInput
    StudentAddress?: StudentAddressCreateNestedManyWithoutStateInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutStateInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutTeacherAddressInput = {
    id?: string
    StateName: string
    fkCountryId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    City?: CityUncheckedCreateNestedManyWithoutStateInput
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutStateInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutStateInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutTeacherAddressInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutTeacherAddressInput, StateUncheckedCreateWithoutTeacherAddressInput>
  }

  export type CityCreateWithoutTeacherAddressInput = {
    id?: string
    CityName: string
    State: StateCreateNestedOneWithoutCityInput
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressCreateNestedManyWithoutCityInput
    SalesTeamAddress?: SalesTeamAddressCreateNestedManyWithoutCityInput
    SchoolMasterAddress?: SchoolMasterAddressCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutTeacherAddressInput = {
    id?: string
    CityName: string
    fkStateId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
    StudentAddress?: StudentAddressUncheckedCreateNestedManyWithoutCityInput
    SalesTeamAddress?: SalesTeamAddressUncheckedCreateNestedManyWithoutCityInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutTeacherAddressInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutTeacherAddressInput, CityUncheckedCreateWithoutTeacherAddressInput>
  }

  export type TeacherMasterUpsertWithoutTeacherAddressInput = {
    update: XOR<TeacherMasterUpdateWithoutTeacherAddressInput, TeacherMasterUncheckedUpdateWithoutTeacherAddressInput>
    create: XOR<TeacherMasterCreateWithoutTeacherAddressInput, TeacherMasterUncheckedCreateWithoutTeacherAddressInput>
  }

  export type TeacherMasterUpdateWithoutTeacherAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    Teacherdepartment?: TeacherDepartmentUpdateOneRequiredWithoutTeacherMasterNestedInput
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    designation?: DesignationUpdateOneRequiredWithoutTeacherMasterNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherDocuments?: TeacherDocumentsUpdateManyWithoutTeacherIdNestedInput
    TeacherExprience?: TeacherExprienceUpdateManyWithoutTeacherIdNestedInput
  }

  export type TeacherMasterUncheckedUpdateWithoutTeacherAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    fkTeacherDepartmentId?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fkDesignationId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherDocuments?: TeacherDocumentsUncheckedUpdateManyWithoutTeacherIdNestedInput
    TeacherExprience?: TeacherExprienceUncheckedUpdateManyWithoutTeacherIdNestedInput
  }

  export type CountryUpsertWithoutTeacherAddressInput = {
    update: XOR<CountryUpdateWithoutTeacherAddressInput, CountryUncheckedUpdateWithoutTeacherAddressInput>
    create: XOR<CountryCreateWithoutTeacherAddressInput, CountryUncheckedCreateWithoutTeacherAddressInput>
  }

  export type CountryUpdateWithoutTeacherAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    State?: StateUpdateManyWithoutCountryNestedInput
    StudentAddress?: StudentAddressUpdateManyWithoutCountryNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutCountryNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutTeacherAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CounrtyName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    State?: StateUncheckedUpdateManyWithoutCountryNestedInput
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutCountryNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutCountryNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type StateUpsertWithoutTeacherAddressInput = {
    update: XOR<StateUpdateWithoutTeacherAddressInput, StateUncheckedUpdateWithoutTeacherAddressInput>
    create: XOR<StateCreateWithoutTeacherAddressInput, StateUncheckedCreateWithoutTeacherAddressInput>
  }

  export type StateUpdateWithoutTeacherAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    Country?: CountryUpdateOneRequiredWithoutStateNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUpdateManyWithoutStateNestedInput
    StudentAddress?: StudentAddressUpdateManyWithoutStateNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutStateNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutTeacherAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUncheckedUpdateManyWithoutStateNestedInput
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutStateNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutStateNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutStateNestedInput
  }

  export type CityUpsertWithoutTeacherAddressInput = {
    update: XOR<CityUpdateWithoutTeacherAddressInput, CityUncheckedUpdateWithoutTeacherAddressInput>
    create: XOR<CityCreateWithoutTeacherAddressInput, CityUncheckedCreateWithoutTeacherAddressInput>
  }

  export type CityUpdateWithoutTeacherAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    State?: StateUpdateOneRequiredWithoutCityNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUpdateManyWithoutCityNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutCityNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutTeacherAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutCityNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutCityNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutCityNestedInput
  }

  export type SalesTeamCreateManyDesignationInput = {
    id?: string
    email: string
    phone: string
    password: string
    dob: Date | string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherMasterCreateManyDesignationInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    fkTeacherDepartmentId: string
    profileImg: string
    joiningDate: Date | string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamUpdateWithoutDesignationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeamDocuments?: SalesTeamDocumentsUpdateManyWithoutSalesTeamNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutSalesTeamNestedInput
    schoolMaster?: schoolMasterUpdateManyWithoutSalesTeamNestedInput
  }

  export type SalesTeamUncheckedUpdateWithoutDesignationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesTeamDocuments?: SalesTeamDocumentsUncheckedUpdateManyWithoutSalesTeamNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutSalesTeamNestedInput
    schoolMaster?: schoolMasterUncheckedUpdateManyWithoutSalesTeamNestedInput
  }

  export type SalesTeamUncheckedUpdateManyWithoutSalesTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherMasterUpdateWithoutDesignationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    Teacherdepartment?: TeacherDepartmentUpdateOneRequiredWithoutTeacherMasterNestedInput
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherDocuments?: TeacherDocumentsUpdateManyWithoutTeacherIdNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutTeacherIdNestedInput
    TeacherExprience?: TeacherExprienceUpdateManyWithoutTeacherIdNestedInput
  }

  export type TeacherMasterUncheckedUpdateWithoutDesignationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    fkTeacherDepartmentId?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherDocuments?: TeacherDocumentsUncheckedUpdateManyWithoutTeacherIdNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutTeacherIdNestedInput
    TeacherExprience?: TeacherExprienceUncheckedUpdateManyWithoutTeacherIdNestedInput
  }

  export type TeacherMasterUncheckedUpdateManyWithoutTeacherMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    fkTeacherDepartmentId?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateCreateManyCountryInput = {
    id?: string
    StateName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressCreateManyCountryInput = {
    id?: string
    fkStudentId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressCreateManyCountryInput = {
    id?: string
    fkTeacherId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressCreateManyCountryInput = {
    id?: string
    fkSalesTeamId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressCreateManyCountryInput = {
    id?: string
    fkSchoolId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StateUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUpdateManyWithoutStateNestedInput
    StudentAddress?: StudentAddressUpdateManyWithoutStateNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutStateNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutStateNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUncheckedUpdateManyWithoutStateNestedInput
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutStateNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutStateNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutStateNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateManyWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    StateName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    StudentId?: StudentMasterUpdateOneRequiredWithoutStudentAddressNestedInput
    State?: StateUpdateOneRequiredWithoutStudentAddressNestedInput
    City?: CityUpdateOneRequiredWithoutStudentAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkStudentId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressUncheckedUpdateManyWithoutStudentAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkStudentId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    TeacherId?: TeacherMasterUpdateOneRequiredWithoutTeacherAddressNestedInput
    State?: StateUpdateOneRequiredWithoutTeacherAddressNestedInput
    City?: CityUpdateOneRequiredWithoutTeacherAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkTeacherId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressUncheckedUpdateManyWithoutTeacherAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkTeacherId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesTeam?: SalesTeamUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    State?: StateUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    City?: CityUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressUncheckedUpdateManyWithoutSalesTeamAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolMasterAddressUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: schoolMasterUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    State?: StateUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    City?: CityUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolMasterAddressUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSchoolId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolMasterAddressUncheckedUpdateManyWithoutSchoolMasterAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSchoolId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateManyStateInput = {
    id?: string
    CityName: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressCreateManyStateInput = {
    id?: string
    fkStudentId: string
    fkCountryId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressCreateManyStateInput = {
    id?: string
    fkTeacherId: string
    fkCountryId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressCreateManyStateInput = {
    id?: string
    fkSalesTeamId: string
    fkCountryId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressCreateManyStateInput = {
    id?: string
    fkSchoolId: string
    fkCountryId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUpdateManyWithoutCityNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutCityNestedInput
    SalesTeamAddress?: SalesTeamAddressUpdateManyWithoutCityNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentAddress?: StudentAddressUncheckedUpdateManyWithoutCityNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutCityNestedInput
    SalesTeamAddress?: SalesTeamAddressUncheckedUpdateManyWithoutCityNestedInput
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    CityName?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    StudentId?: StudentMasterUpdateOneRequiredWithoutStudentAddressNestedInput
    Country?: CountryUpdateOneRequiredWithoutStudentAddressNestedInput
    City?: CityUpdateOneRequiredWithoutStudentAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkStudentId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    TeacherId?: TeacherMasterUpdateOneRequiredWithoutTeacherAddressNestedInput
    Country?: CountryUpdateOneRequiredWithoutTeacherAddressNestedInput
    City?: CityUpdateOneRequiredWithoutTeacherAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkTeacherId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesTeam?: SalesTeamUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    Country?: CountryUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    City?: CityUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolMasterAddressUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: schoolMasterUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    Country?: CountryUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    City?: CityUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolMasterAddressUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSchoolId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressCreateManyCityInput = {
    id?: string
    fkStudentId: string
    fkCountryId: string
    fkStateId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressCreateManyCityInput = {
    id?: string
    fkTeacherId: string
    fkCountryId: string
    fkStateId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressCreateManyCityInput = {
    id?: string
    fkSalesTeamId: string
    fkCountryId: string
    fkStateId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressCreateManyCityInput = {
    id?: string
    fkSchoolId: string
    fkCountryId: string
    fkStateId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    StudentId?: StudentMasterUpdateOneRequiredWithoutStudentAddressNestedInput
    Country?: CountryUpdateOneRequiredWithoutStudentAddressNestedInput
    State?: StateUpdateOneRequiredWithoutStudentAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkStudentId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    TeacherId?: TeacherMasterUpdateOneRequiredWithoutTeacherAddressNestedInput
    Country?: CountryUpdateOneRequiredWithoutTeacherAddressNestedInput
    State?: StateUpdateOneRequiredWithoutTeacherAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkTeacherId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesTeam?: SalesTeamUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    Country?: CountryUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    State?: StateUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolMasterAddressUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: schoolMasterUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    Country?: CountryUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    State?: StateUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolMasterAddressUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkSchoolId?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamDocumentsCreateManySalesTeamInput = {
    id?: string
    category: string
    comment: string
    url: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamAddressCreateManySalesTeamInput = {
    id?: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type schoolMasterCreateManySalesTeamInput = {
    id?: string
    name: string
    afflicationCode: string
    fkSchoolType: string
    fkSchoolBoard: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamDocumentsUpdateWithoutSalesTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamDocumentsUncheckedUpdateWithoutSalesTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamDocumentsUncheckedUpdateManyWithoutSalesTeamDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressUpdateWithoutSalesTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    Country?: CountryUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    State?: StateUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    City?: CityUpdateOneRequiredWithoutSalesTeamAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamAddressUncheckedUpdateWithoutSalesTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type schoolMasterUpdateWithoutSalesTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    schoolType?: schoolTypeUpdateOneRequiredWithoutSchoolMasterNestedInput
    schoolBoard?: SchoolBoardUpdateOneRequiredWithoutSchoolMasterNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutSchoolIdNestedInput
  }

  export type schoolMasterUncheckedUpdateWithoutSalesTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    fkSchoolType?: StringFieldUpdateOperationsInput | string
    fkSchoolBoard?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutSchoolIdNestedInput
  }

  export type schoolMasterUncheckedUpdateManyWithoutSchoolMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    fkSchoolType?: StringFieldUpdateOperationsInput | string
    fkSchoolBoard?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type schoolMasterCreateManySchoolBoardInput = {
    id?: string
    name: string
    afflicationCode: string
    fkSchoolType: string
    fkSalesTeamId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type schoolMasterUpdateWithoutSchoolBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    schoolType?: schoolTypeUpdateOneRequiredWithoutSchoolMasterNestedInput
    salesTeam?: SalesTeamUpdateOneRequiredWithoutSchoolMasterNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutSchoolIdNestedInput
  }

  export type schoolMasterUncheckedUpdateWithoutSchoolBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    fkSchoolType?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutSchoolIdNestedInput
  }

  export type schoolMasterCreateManySchoolTypeInput = {
    id?: string
    name: string
    afflicationCode: string
    fkSchoolBoard: string
    fkSalesTeamId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type schoolMasterUpdateWithoutSchoolTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    schoolBoard?: SchoolBoardUpdateOneRequiredWithoutSchoolMasterNestedInput
    salesTeam?: SalesTeamUpdateOneRequiredWithoutSchoolMasterNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SchoolMasterAddress?: SchoolMasterAddressUpdateManyWithoutSchoolIdNestedInput
  }

  export type schoolMasterUncheckedUpdateWithoutSchoolTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    afflicationCode?: StringFieldUpdateOperationsInput | string
    fkSchoolBoard?: StringFieldUpdateOperationsInput | string
    fkSalesTeamId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SchoolMasterAddress?: SchoolMasterAddressUncheckedUpdateManyWithoutSchoolIdNestedInput
  }

  export type SchoolMasterAddressCreateManySchoolIdInput = {
    id?: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolMasterAddressUpdateWithoutSchoolIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    Country?: CountryUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    State?: StateUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    City?: CityUpdateOneRequiredWithoutSchoolMasterAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolMasterAddressUncheckedUpdateWithoutSchoolIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentsCreateManyStudentIdInput = {
    id?: string
    category: string
    docUrl: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAddressCreateManyStudentIdInput = {
    id?: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentsCreateManyStudentIdInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentDocumentsUpdateWithoutStudentIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentsUncheckedUpdateWithoutStudentIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentsUncheckedUpdateManyWithoutStudentDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressUpdateWithoutStudentIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    Country?: CountryUpdateOneRequiredWithoutStudentAddressNestedInput
    State?: StateUpdateOneRequiredWithoutStudentAddressNestedInput
    City?: CityUpdateOneRequiredWithoutStudentAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAddressUncheckedUpdateWithoutStudentIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentsUpdateWithoutStudentIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentsUncheckedUpdateWithoutStudentIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentsUncheckedUpdateManyWithoutStudentParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherMasterCreateManyTeacherdepartmentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    password: string
    gender: string
    dob: Date | string
    teacherId: string
    profileImg: string
    joiningDate: Date | string
    fkDesignationId: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherMasterUpdateWithoutTeacherdepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    designation?: DesignationUpdateOneRequiredWithoutTeacherMasterNestedInput
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherDocuments?: TeacherDocumentsUpdateManyWithoutTeacherIdNestedInput
    TeacherAddress?: TeacherAddressUpdateManyWithoutTeacherIdNestedInput
    TeacherExprience?: TeacherExprienceUpdateManyWithoutTeacherIdNestedInput
  }

  export type TeacherMasterUncheckedUpdateWithoutTeacherdepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: StringFieldUpdateOperationsInput | string
    profileImg?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fkDesignationId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TeacherDocuments?: TeacherDocumentsUncheckedUpdateManyWithoutTeacherIdNestedInput
    TeacherAddress?: TeacherAddressUncheckedUpdateManyWithoutTeacherIdNestedInput
    TeacherExprience?: TeacherExprienceUncheckedUpdateManyWithoutTeacherIdNestedInput
  }

  export type TeacherDocumentsCreateManyTeacherIdInput = {
    id?: string
    category: string
    docUrl: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherAddressCreateManyTeacherIdInput = {
    id?: string
    fkCountryId: string
    fkStateId: string
    fkCityId: string
    Address: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherExprienceCreateManyTeacherIdInput = {
    id?: string
    skills?: TeacherExprienceCreateskillsInput | Enumerable<InputJsonValue>
    experience: string
    status: boolean
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherDocumentsUpdateWithoutTeacherIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherDocumentsUncheckedUpdateWithoutTeacherIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherDocumentsUncheckedUpdateManyWithoutTeacherDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    docUrl?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressUpdateWithoutTeacherIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    Country?: CountryUpdateOneRequiredWithoutTeacherAddressNestedInput
    State?: StateUpdateOneRequiredWithoutTeacherAddressNestedInput
    City?: CityUpdateOneRequiredWithoutTeacherAddressNestedInput
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherAddressUncheckedUpdateWithoutTeacherIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    fkCountryId?: StringFieldUpdateOperationsInput | string
    fkStateId?: StringFieldUpdateOperationsInput | string
    fkCityId?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherExprienceUpdateWithoutTeacherIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: TeacherExprienceUpdateskillsInput | Enumerable<InputJsonValue>
    experience?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherExprienceUncheckedUpdateWithoutTeacherIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: TeacherExprienceUpdateskillsInput | Enumerable<InputJsonValue>
    experience?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherExprienceUncheckedUpdateManyWithoutTeacherExprienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: TeacherExprienceUpdateskillsInput | Enumerable<InputJsonValue>
    experience?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}